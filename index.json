[{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/","title":"AWS CDK Intro Workshop","tags":[],"description":"","content":"Welcome Developers! AWS Cloud Development Kit (AWS CDK) ワークショップへようこそ！\nAWS CDKはAWSの新しいソフトウェア開発フレームワークです。 好きなプログラミング言語で楽しく簡単にクラウドインフラストラクチャを定義し、AWS CloudFormationを使ってデプロイできるようにすることを唯一の目的にしています。\nこのワークショップでは開発環境のセットアップから始まり、CDK Toolkitを使ってAWS環境にアプリケーションをデプロイする方法について学びます。 小さなAWS Lambdaの関数を書き、Amazon API Gatewayのエンドポイントをフロントに置くことで、ユーザーが HTTPリクエストを用いてそれを呼び出せるようにします。\n次に、CDK constructsという強力な概念を紹介します。 コンストラクトを使用すると、多くのインフラストラクチャを再利用可能なコンポーネントにまとめ、誰でも自分のアプリケーションに組み入れることができます。\n最後に、独自のコンストラクトを作成する方法を説明します。\nこのワークショップの終了時には、次のことができるようになります。\n新しい CDK アプリケーションを作成する AWS Construct Library を使用して、アプリケーションのインフラストラクチャを定義する AWSアカウントへのCDKアプリケーションをデプロイする 再利用可能な独自のコンストラクトを定義する 免責事項: 本資料は、AWSが提供するCDK Workshopを元にJAWS-UG CDK支部のメンバーで作成しています。 記載誤りがある場合は、Twitterスペース、またはGitHubにてお知らせください。\nSee Also AWS CDK User Guide AWS CDK Reference Construct Hub "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/90-cloud9.html","title":"開発環境(Cloud9)の準備","tags":[],"description":"","content":"CDKを動かす環境である「Cloud9」の構築 AWSのサービスの一つであるAWS Cloud9を用いることで、 CDKを用いた開発に必要なソフトウェアがインストールされた環境とIDEを簡単に手に入れることができます。\n前提事項 AWSアカウントを所有していること AdministratorAccessポリシー相当のIAMユーザーもしくはIAMロールで作業可能なこと 作業は東京リージョン(ap-northeast-1)で実施すること（下図参照） Cloud9の作成 AWS Cloud9(以降、Cloud9）インスタンスを作成します。\nAWSマネジメントコンソール上部の [サービス] タブより [Cloud9] を選択します。 Cloud9ダッシュボードの左側ナビゲーションメニューから [Account environments] を選択し、[Create environment] ボタンを押します。 Step1 [Name environment] では、次のように各項目を入力後、 [Next step] ボタンを押します。 項目名 値 Name cdk-workshop-playground Description cdk-workshopで利用をするCloud9インスタンス Step2 [Configure settings] では、次のように各項目を入力・選択後、 [Next step] ボタンを押します。 ネットワークVPC及びサブネットはデフォルトのものを選択してください（デフォルトVPCが存在しない場合、インターネットに接続可能なVPCとサブネットを選択してください）。 項目名 値 Environment type Create a new EC2 instance for environment(direct access) Instance type t3.small (2 GiB RAM + 2 vCPU) Platform Amazon Linux2 (recommended) Cost-saving setting After 30 minutes(default) Network(VPC) vpc-xxxxxxx(default) ※インターネットに接続可能なVPC Subnet subnet-xxxxxxx [Review] にて入力内容を確認し、 [Create environment] ボタンを押します。 以下のようにCloud9コンソールが利用可能であることを確認してください。 以上でCloud9の作成完了です。 以降は、CDKのコマンドを実行する際はCloud9の画面下部にあるターミナルから実施をします。\n動作検証済みの各ソフトウェアバージョン 今回の和訳版を作成するにあたっての、各ソフトウェアバージョンは以下のとおりです。\nソフトウェア バージョン Node.js v16.17.0 CDK 2.39.1 AWS CLI 1.19.112 "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript.html","title":"TypeScript ワークショップ","tags":[],"description":"","content":"TypeScript ワークショップ 本項では、TypeScriptの入門編を体験できます。\nAWS利用料についての免責事項: このワークショップのいくつかのステップでは、請求が発生する可能性のあるリソースをあなたのアカウントに作成します。 このワークショップを最後まで実施しなくても、アカウントに課金が発生するAWSリソースが作られているかもしれません。 あなたのアカウントがクリーンであることを確認するには、TypeScriptワークショップの最後にある cleanup sectionのセクションを確認してください。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/20-create-project.html","title":"新しいプロジェクト","tags":[],"description":"","content":"CDKプロジェクトを作成する この章では、 cdk init コマンドを使用し、新しいAWS CDK TypeScriptプロジェクトを作成します。\nまた、CDK Toolkitを使用してスターターアプリ用のAWS CloudFormationテンプレートを生成する方法と、アプリをAWSにデプロイする方法についても学習します。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/30-hello-cdk.html","title":"Hello, CDK!","tags":[],"description":"","content":"Hello, CDK! この章では、CDKコードを書いていきます。 サンプルアプリにあるSNS / SQSの代わりに、API Gatewayのエンドポイントを持つLambda関数を追加します。\nエンドポイントの任意のパスにアクセスするとレスポンスを受け取ることができるようになります。\nはじめに、サンプルコードをクリーンアップしましょう。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/40-hit-counter.html","title":"コンストラクトの作成","tags":[],"description":"","content":"コンストラクトの作成 この章では、HitCounterと呼ばれる新しいコンストラクトを定義します。 このコンストラクトは、API Gatewayバックエンドとして使用されるLambda関数にアタッチでき、 各URLのパスに発行されたリクエストの数をカウントします。 この結果をDynamoDBテーブルに保存します。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/60-cleanups.html","title":"Clean up","tags":[],"description":"","content":"リソースのクリーンアップ スタックのクリーンアップ スタックを破棄するとき、リソースはその削除ポリシーに従って「削除」、「保持」、「スナップショット」のいずれかで処理されます。 デフォルトでは、ほとんどのリソースはスタック削除時に削除されますが、すべてのリソースがそうなるわけではありません。 DynamoDBのテーブルは、デフォルトで保持されます。このテーブルを保持したくない場合は、CDKのコードで RemovalPolicy を使って設定ができます。 今回はクリーンアップを簡単にするため、DynamoDBのテーブル作成時にRemovalPolicy.DESTROYを指定しています。 そのためスタックを破棄するだけでテーブルもあわせて削除されます。\nまた、作成されたLambda関数は、永久に保持されるCloudWatchのログを生成します。 これらはスタックの一部ではないので、CloudFormationでは追跡されず、ログは削除されずに残ります。 CloudWatchのログを削除する場合は、コンソールでこれらを手動で削除する必要があります。\nどのリソースが削除されるかがわかったので、スタックの削除を進めましょう。 CloudFormationのコンソールからスタックを削除するか、cdk destroyを使用するかのどちらかです。\ncdk destroy 以下のように聞かれるはずです。\nAre you sure you want to delete: CdkWorkshopStack (y/n)? yを押すと、スタックが削除されていく進捗が表示されます。\ncdk bootstrap によって作成されたブートストラップスタックは削除されません。 将来的にCDKを使う予定がある場合は、このスタックを削除しないでください。\ncdk bootstrap によって作成されたスタックを削除したい場合は、CloudFormationコンソールから行う必要があります。 CloudFormationコンソールからCDKToolkitスタックを削除してください。 作成されたS3バケットは、デフォルトで保持されます。 予期せぬ課金を避けたい場合はS3コンソールから、ブートストラップで生成されたバケットを空にして、削除しておいてください。\nCloud9 のクリーンアップ CDK の実行環境として使用した Cloud 9 を削除します。AWS マネージメントコンソールから Cloud 9 を開いて、「Delete」ボタンを押します。\n確認画面で「Delete」と入力すると削除できます。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/20-create-project/100-cdk-init.html","title":"cdk init","tags":[],"description":"","content":"プロジェクトディレクトリを作成する 空のディレクトリを作成します。\nmkdir cdk-workshop \u0026amp;\u0026amp; cd cdk-workshop cdk init cdk initコマンドを実行して、TypeScript製の新しいCDKプロジェクトを作成します。\ncdk init sample-app --language typescript 出力は次のようになります。\n# Welcome to your CDK TypeScript project You should explore the contents of this project. It demonstrates a CDK app with an instance of a stack (`CdkWorkshopStack`) which contains an Amazon SQS queue that is subscribed to an Amazon SNS topic. The `cdk.json` file tells the CDK Toolkit how to execute your app. ## Useful commands * `npm run build` compile typescript to js * `npm run watch` watch for changes and compile * `npm run test` perform the jest unit tests * `cdk deploy` deploy this stack to your default AWS account/region * `cdk diff` compare deployed stack with current state * `cdk synth` emits the synthesized CloudFormation template Initializing a new git repository... Executing npm install... ✅ All done! 上記出力にあるとおり、CDKを開始するための便利なコマンドがたくさんあります。\nSee Also AWS CDK Command Line Toolkit (cdk) in the AWS CDK User Guide "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/40-hit-counter/100-api.html","title":"HitCounter APIの定義","tags":[],"description":"","content":"HitCounterコンストラクト用のファイルの作成 libフォルダ配下に次のようなhitcounter.tsファイルを作成します。\nimport { IFunction } from \u0026#39;aws-cdk-lib/aws-lambda\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; export interface HitCounterProps { /** the function for which we want to count url hits **/ downstream: IFunction; } export class HitCounter extends Construct { constructor(scope: Construct, id: string, props: HitCounterProps) { super(scope, id); // TODO } } ファイルを保存すると、エラーが発生しますが心配いりません。 この後すぐに props プロパティを追加します。\nコードの解説 HitCounterという名前のコンストラクトクラスを新しく定義しています。 今までどおり、scope, id, props のコンストラクター引数を設定し、基底クラスである Construct に伝搬させます。 propsは、IFunction型のdownstream というプロパティを含む、HitCounterProps型の引数です。 前の章で作成したLambda関数をここに接続して、HitCountが機能するようにします。 次に、HitCounterのハンドラーコードを記述します。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/40-hit-counter/200-handler.html","title":"HitCounterハンドラー","tags":[],"description":"","content":"HitCounter Lambda ハンドラー HitCounterのLambdaハンドラーコードを記述しましょう。\nlambda/hitcounter.tsを作成し、次のコードを追記してください。\nimport { DynamoDB, Lambda } from \u0026#39;aws-sdk\u0026#39;; export const handler: AWSLambda.APIGatewayProxyHandler = async (event) =\u0026gt; { console.log(\u0026#39;request:\u0026#39;, JSON.stringify(event, undefined, 2)); // create AWS SDK clients const dynamo = new DynamoDB(); const lambda = new Lambda(); // update dynamo entry for \u0026#34;path\u0026#34; with hits++ await dynamo .updateItem({ TableName: process.env.HITS_TABLE_NAME!, Key: { path: { S: event.path } }, UpdateExpression: \u0026#39;ADD hits :incr\u0026#39;, ExpressionAttributeValues: { \u0026#39;:incr\u0026#39;: { N: \u0026#39;1\u0026#39; } }, }) .promise(); // call downstream function and capture response const resp = await lambda .invoke({ FunctionName: process.env.DOWNSTREAM_FUNCTION_NAME!, Payload: JSON.stringify(event), }) .promise(); console.log(\u0026#39;downstream response:\u0026#39;, JSON.stringify(resp, undefined, 2)); // return response back to upstream caller return JSON.parse(resp.Payload!.toString()); }; 実行時のリソース検出 このコードは、次の2つの環境変数を参照していることがわかります。\nHITS_TABLE_NAME データストアとして使用するDynamoDBのテーブル名 DOWNSTREAM_FUNCTION_NAME ダウンストリームLambda関数 テーブルとダウンストリーム関数の名前はアプリをデプロイするときに決まるため、これらの値をコンストラクトコードから関連付ける必要があります。 次のセクションでそれを行います。\nLambda関数がさらに別のLambda関数を呼び出すようになっています。 呼び出される側のLambda関数をダウンストリームLambda関数、あるいは単にダウンストリーム関数とここでは呼んでいます。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/70-advanced-topics/100-construct-testing.html","title":"Testing Constructs","tags":[],"description":"","content":"Testing Constructs (Optional) The CDK Developer Guide has a good guide on testing constructs. For this section of the workshop we are going to use the Fine-Grained Assertions and Validation type tests.\nCDK assert Library We will be using the CDK assertions (aws-cdk-lib/assertions) library throughout this section. The library contains several helper functions for writing unit and integration tests.\nFor this workshop we will mostly be using the hasResourceProperties function. This helper is used when you only care that a resource of a particular type exists (regardless of its logical identfier), and that some properties are set to specific values.\nExample:\ntemplate.hasResourceProperties(\u0026#39;AWS::CertificateManager::Certificate\u0026#39;, { DomainName: \u0026#39;test.example.com\u0026#39;, ShouldNotExist: Match.absent(), // Note: some properties omitted here }); Match.absent() can be used to assert that a particular key in an object is not set (or set to undefined).\nTo see the rest of the documentation, please read the docs here.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/30-hello-cdk/100-cleanup.html","title":"サンプルコードの削除","tags":[],"description":"","content":"スタックからサンプルコードを削除する cdk init sample-app によって作成されたプロジェクトには、SQSキューとSNSトピックが含まれます。 このプロジェクトではそれらを使用する予定はないので、 CdkWorkshopStack コンストラクタから削除しましょう。\nlib/cdk-workshop-stack.ts を開き、削除します。 最終的には次のようになります。\nimport { Stack, StackProps } from \u0026#39;aws-cdk-lib\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; export class CdkWorkshopStack extends Stack { constructor(scope: Construct, id: string, props?: StackProps) { super(scope, id, props); // nothing here! } } cdk diff これでスタックの中身を修正したことになります。 cdk diffを実行することで、スタックの修正によってどのような変更が発生するのかを画面で確認できます。 これは cdk deploy を実行したときに何が起こるかを確認する安全な方法であり、いつでも使える良いプラクティスです。\ncdk diff 出力は次のようになります。\nStack CdkWorkshopStack IAM Statement Changes ┌───┬─────────────────────────────────┬────────┬─────────────────┬───────────────────────────┬──────────────────────────────────────────────────┐ │ │ Resource │ Effect │ Action │ Principal │ Condition │ ├───┼─────────────────────────────────┼────────┼─────────────────┼───────────────────────────┼──────────────────────────────────────────────────┤ │ - │ ${CdkWorkshopQueue50D9D426.Arn} │ Allow │ sqs:SendMessage │ Service:sns.amazonaws.com │ \u0026#34;ArnEquals\u0026#34;: { │ │ │ │ │ │ │ \u0026#34;aws:SourceArn\u0026#34;: \u0026#34;${CdkWorkshopTopicD368A42F}\u0026#34; │ │ │ │ │ │ │ } │ └───┴─────────────────────────────────┴────────┴─────────────────┴───────────────────────────┴──────────────────────────────────────────────────┘ (NOTE: There may be security-related changes not in this list. See https://github.com/aws/aws-cdk/issues/1299) Resources [-] AWS::SQS::Queue CdkWorkshopQueue50D9D426 destroy [-] AWS::SQS::QueuePolicy CdkWorkshopQueuePolicyAF2494A5 destroy [-] AWS::SNS::Subscription CdkWorkshopQueueCdkWorkshopStackCdkWorkshopTopicD7BE96438B5AD106 destroy [-] AWS::SNS::Topic CdkWorkshopTopicD368A42F destroy 想定の通り、既存のリソースがすっかり削除されることになります。\ncdk deploy cdk deployを実行したら、次のセクションに進みます。\ncdk deploy リソースが削除されていくのが確認できます。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/70-advanced-topics/200-pipelines/1000-setting-up.html","title":"Getting Started with Pipelines","tags":[],"description":"","content":" Note: This segment of the workshop assumes you have completed the previous sections of the workshop. If you have not, and just want to follow this segment, or you are returning to try this workshop, you can use the code here that represents the last state of the project after adding the tests.\nCreate Pipeline Stack The first step is to create the stack that will contain our pipeline. Since this is separate from our actual \u0026ldquo;production\u0026rdquo; application, we want this to be entirely self-contained.\nCreate a new file under lib called lib/pipeline-stack.ts. Add the following to that file.\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; export class WorkshopPipelineStack extends cdk.Stack { constructor(scope: Construct, id: string, props?: cdk.StackProps) { super(scope, id, props); // Pipeline code goes here } } Look familiar? At this point, the pipeline is like any other CDK stack.\nUpdate CDK Deploy Entrypoint Next, since the purpose of our pipeline is to deploy our application stack, we no longer want the main CDK application to deploy our original app. Instead, we can change the entry point to deploy our pipeline, which will in turn deploy the application.\nTo do this, edit the code in bin/cdk-workshop.ts as follows:\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import { WorkshopPipelineStack } from \u0026#39;../lib/pipeline-stack\u0026#39;; const app = new cdk.App(); new WorkshopPipelineStack(app, \u0026#39;CdkWorkshopPipelineStack\u0026#39;); And now we\u0026rsquo;re ready!\nLets build a pipeline! "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/70-advanced-topics/200-pipelines/2000-create-repo.html","title":"Create Repository","tags":[],"description":"","content":"Create Repo in Pipeline Stack The first step in any good CD pipeline is source control. Here we will create a CodeCommit repository to contain our project code.\nEdit the file lib/pipeline-stack.ts as follows.\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import * as codecommit from \u0026#39;aws-cdk-lib/aws-codecommit\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; export class WorkshopPipelineStack extends cdk.Stack { constructor(scope: Construct, id: string, props?: cdk.StackProps) { super(scope, id, props); // Creates a CodeCommit repository called \u0026#39;WorkshopRepo\u0026#39; new codecommit.Repository(this, \u0026#39;WorkshopRepo\u0026#39;, { repositoryName: \u0026#34;WorkshopRepo\u0026#34; }); // Pipeline code goes here } } Deploy npx cdk deploy Get Repo Info and Commit Before we can do anything with our repo, we must add our code to it!\nGit Credentials Before we can do that, we will need Git credentials for the repo. To do this, go to the IAM Console, then navigate to Users and then your user of choice. Inside the manage user interface, navigate to the Security credentials tab and scroll until you see \u0026ldquo;HTTPS Git credentials for AWS CodeCommit\u0026rdquo;. Click generate credentials and follow the instructions on downloading those credentials. We will need them in a moment.\nAdd Git remote The last console step we will need here is to navigate to the CodeCommit Console and look for your repo. You will see a column called \u0026ldquo;Clone URL\u0026rdquo;; click \u0026ldquo;HTTPS\u0026rdquo; to copy the https link so we can add it to your local repo.\nNote: If you do not see your repo here, ensure you are in the interface for the correct region\nWhile you are here, feel free to explore your repo. You will see that it is still empty, but you do have access to the repo configuration information.\nIn your terminal, first make sure that all the changes you have made during the workshop are committed by issuing git status. If you have unstaged or uncommitted changes, you can execute git commit -am \u0026quot;SOME_COMMIT_MESSAGE_HERE\u0026quot;. This will stage and commit all your files so you are ready to go!\nNote: If you copied the code from the repo rather than following through the workshop from the beginning, first issue git init \u0026amp;\u0026amp; git add -A \u0026amp;\u0026amp; git commit -m \u0026quot;init\u0026quot;\nBy default, the CDK .gitignore file includes a reference to ignore all *.js files as those are typically generated by npm-ts. However, since we have lambda files written in js, those must not be ignored. Edit the .gitignore file, adding !lambda/*.js at the end of the file as shown below. This will instruct git to include all *.js files in the directory lambda/\n*.js !jest.config.js *.d.ts node_modules # CDK asset staging directory .cdk.staging cdk.out !lambda/*.js You will also need to commit the changes to your local git before we push the code to CodeCommit:\ngit add -A \u0026amp;\u0026amp; git commit -m \u0026#34;Updated .gitignore\u0026#34; Next, we add the remote repo to our Git config. You can do this with the command (XXXXX represents the Clone URL you copied from the console):\ngit remote add origin XXXXX Now all we need to do is to push our code to the repo (--set-upstream tells Git to override the current empty master branch on your repo):\ngit push --set-upstream origin master Here, CodeCommit will request the credentials you generated in the Git Credentials section. You will only have to provide them once.\nSee Result Now you can return to the CodeCommit console and see that your code is all there!\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/70-advanced-topics/200-pipelines/3000-new-pipeline.html","title":"Create New Pipeline","tags":[],"description":"","content":"Define an Empty Pipeline Now we are ready to define the basics of the pipeline.\nReturn to the file lib/pipeline-stack.ts and edit as follows:\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import * as codecommit from \u0026#39;aws-cdk-lib/aws-codecommit\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; import {CodeBuildStep, CodePipeline, CodePipelineSource} from \u0026#34;aws-cdk-lib/pipelines\u0026#34;; export class WorkshopPipelineStack extends cdk.Stack { constructor(scope: Construct, id: string, props?: cdk.StackProps) { super(scope, id, props); // This creates a new CodeCommit repository called \u0026#39;WorkshopRepo\u0026#39; const repo = new codecommit.Repository(this, \u0026#39;WorkshopRepo\u0026#39;, { repositoryName: \u0026#34;WorkshopRepo\u0026#34; }); // The basic pipeline declaration. This sets the initial structure // of our pipeline const pipeline = new CodePipeline(this, \u0026#39;Pipeline\u0026#39;, { pipelineName: \u0026#39;WorkshopPipeline\u0026#39;, synth: new CodeBuildStep(\u0026#39;SynthStep\u0026#39;, { input: CodePipelineSource.codeCommit(repo, \u0026#39;master\u0026#39;), installCommands: [ \u0026#39;npm install -g aws-cdk\u0026#39; ], commands: [ \u0026#39;npm ci\u0026#39;, \u0026#39;npm run build\u0026#39;, \u0026#39;npx cdk synth\u0026#39; ] } ) }); } } Component Breakdown The above code does several things:\nnew CodePipeline(...): This initializes the pipeline with the required values. This will serve as the base component moving forward. Every pipeline requires at bare minimum: synth(...): The synthAction of the pipeline describes the commands necessary to install dependencies, build, and synth the CDK application from source. This should always end in a synth command, for NPM-based projects this is always npx cdk synth. The input of the synth step specifies the repository where the CDK source code is stored. Deploy Pipeline and See Result All that\u0026rsquo;s left to get our pipeline up and running is to commit our changes and run one last cdk deploy.\ngit commit -am \u0026#34;MESSAGE\u0026#34; \u0026amp;\u0026amp; git push npx cdk deploy CDK Pipelines auto-update for each commit in a source repo, so this is the last time we will need to execute this command!\nOnce deployment is finished, you can go to the CodePipeline console and you will see a new pipeline! If you navigate to it, it should look like this:\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/70-advanced-topics/200-pipelines/4000-build-stage.html","title":"Add Application to Pipeline","tags":[],"description":"","content":"Create Stage At this point, you have a fully operating CDK pipeline that will automatically update itself on every commit, BUT at the moment, that is all it does. We need to add a stage to the pipeline that will deploy our application.\nCreate a new file in lib called pipeline-stage.ts with the code below:\nimport { CdkWorkshopStack } from \u0026#39;./cdk-workshop-stack\u0026#39;; import { Stage, StageProps } from \u0026#39;aws-cdk-lib\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; export class WorkshopPipelineStage extends Stage { constructor(scope: Construct, id: string, props?: StageProps) { super(scope, id, props); new CdkWorkshopStack(this, \u0026#39;WebService\u0026#39;); } } All this does is declare a new Stage (component of a pipeline), and in that stage instantiate our application stack.\nNow, at this point your code editor may be telling you that you are doing something wrong. This is because the application stack as it stands now is not configured to be deployed by a pipeline. Open lib/cdk-workshop-stack.ts and make the following changes:\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import * as lambda from \u0026#39;aws-cdk-lib/aws-lambda\u0026#39;; import * as apigw from \u0026#39;aws-cdk-lib/aws-apigateway\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; import { HitCounter } from \u0026#39;./hitcounter\u0026#39;; import { TableViewer } from \u0026#39;cdk-dynamo-table-viewer\u0026#39;; export class CdkWorkshopStack extends cdk.Stack { constructor(scope: Construct, id: string, props?: cdk.StackProps) { super(scope, id, props); // The rest of your code... This stack\u0026rsquo;s scope parameter was defined as being a cdk.App, which means that in the construct tree, it must be a child of the app. Since the stack is being deployed by the pipeline, it is no longer a child of the app, so its type must be changed to Construct.\nAdd stage to pipeline Now we must add the stage to the pipeline by adding the following code to lib/pipeline-stack.ts:\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import * as codecommit from \u0026#39;aws-cdk-lib/aws-codecommit\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; import {WorkshopPipelineStage} from \u0026#39;./pipeline-stage\u0026#39;; import {CodeBuildStep, CodePipeline, CodePipelineSource} from \u0026#34;aws-cdk-lib/pipelines\u0026#34;; export class WorkshopPipelineStack extends cdk.Stack { constructor(scope: Construct, id: string, props?: cdk.StackProps) { super(scope, id, props); // This creates a new CodeCommit repository called \u0026#39;WorkshopRepo\u0026#39; const repo = new codecommit.Repository(this, \u0026#39;WorkshopRepo\u0026#39;, { repositoryName: \u0026#34;WorkshopRepo\u0026#34; }); // The basic pipeline declaration. This sets the initial structure // of our pipeline const pipeline = new CodePipeline(this, \u0026#39;Pipeline\u0026#39;, { pipelineName: \u0026#39;WorkshopPipeline\u0026#39;, synth: new CodeBuildStep(\u0026#39;SynthStep\u0026#39;, { input: CodePipelineSource.codeCommit(repo, \u0026#39;master\u0026#39;), installCommands: [ \u0026#39;npm install -g aws-cdk\u0026#39; ], commands: [ \u0026#39;npm ci\u0026#39;, \u0026#39;npm run build\u0026#39;, \u0026#39;npx cdk synth\u0026#39; ] } ) }); const deploy = new WorkshopPipelineStage(this, \u0026#39;Deploy\u0026#39;); const deployStage = pipeline.addStage(deploy); } } This imports and creates an instance of the WorkshopPipelineStage. Later, you might instantiate this stage multiple times (e.g. you want a Production deployment and a separate development/test deployment).\nThen we add that stage to our pipeline (pipeline.addStage(deploy);). A Stage in a CDK Pipeline represents a set of one or more CDK Stacks that should be deployed together, to a particular environment.\nCommit/Deploy Now that we have added the code to deploy our application, all that\u0026rsquo;s left is to commit and push those changes to the repo.\ngit commit -am \u0026#34;Add deploy stage to pipeline\u0026#34; \u0026amp;\u0026amp; git push Once that is done, we can go back to the CodePipeline console and take a look as the pipeline runs (this may take a while).\nSuccess!\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/70-advanced-topics/200-pipelines/5000-test-actions.html","title":"Polish Pipeline","tags":[],"description":"","content":"Get Endpoints Stepping back, we can see a problem now that our app is being deployed by our pipeline. There is no easy way to find the endpoints of our application (the TableViewer and APIGateway endpoints), so we can\u0026rsquo;t call it! Let\u0026rsquo;s add a little bit of code to expose these more obviously.\nFirst edit lib/cdk-workshop-stack.ts to get these values and expose them as properties of our stack:\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import * as lambda from \u0026#39;aws-cdk-lib/aws-lambda\u0026#39;; import * as apigw from \u0026#39;aws-cdk-lib/aws-apigateway\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; import { HitCounter } from \u0026#39;./hitcounter\u0026#39;; import { TableViewer } from \u0026#39;cdk-dynamo-table-viewer\u0026#39;; export class CdkWorkshopStack extends cdk.Stack { public readonly hcViewerUrl: cdk.CfnOutput; public readonly hcEndpoint: cdk.CfnOutput; constructor(scope: Construct, id: string, props?: cdk.StackProps) { super(scope, id, props); const hello = new lambda.Function(this, \u0026#39;HelloHandler\u0026#39;, { runtime: lambda.Runtime.NODEJS_14_X, code: lambda.Code.fromAsset(\u0026#39;lambda\u0026#39;), handler: \u0026#39;hello.handler\u0026#39;, }); const helloWithCounter = new HitCounter(this, \u0026#39;HelloHitCounter\u0026#39;, { downstream: hello }); // defines an API Gateway REST API resource backed by our \u0026#34;hello\u0026#34; function. const gateway = new apigw.LambdaRestApi(this, \u0026#39;Endpoint\u0026#39;, { handler: helloWithCounter.handler }); const tv = new TableViewer(this, \u0026#39;ViewHitCounter\u0026#39;, { title: \u0026#39;Hello Hits\u0026#39;, table: helloWithCounter.table, sortBy: \u0026#39;-hits\u0026#39; }); this.hcEndpoint = new cdk.CfnOutput(this, \u0026#39;GatewayUrl\u0026#39;, { value: gateway.url }); this.hcViewerUrl = new cdk.CfnOutput(this, \u0026#39;TableViewerUrl\u0026#39;, { value: tv.endpoint }); } } By adding outputs hcViewerUrl and hcEnpoint, we expose the necessary endpoints to our HitCounter application. We are using the core construct CfnOutput to declare these as Cloudformation stack outputs (we will get to this in a minute).\nLet\u0026rsquo;s commit these changes to our repo (git commit -am \u0026quot;MESSAGE\u0026quot; \u0026amp;\u0026amp; git push), and navigate to the Cloudformation console. You can see there are three stacks.\nCDKToolkit: The first is the integrated CDK stack (you should always see this on bootstrapped accounts). You can ignore this. WorkshopPipelineStack: This is the stack that declares our pipeline. It isn\u0026rsquo;t the one we need right now. Deploy-WebService: Here is our application! Select this, and under details, select the Outputs tab. Here you should see four endpoints (two pairs of duplicate values). Two of them, EndpointXXXXXX and ViewerHitCounterViewerEndpointXXXXXXX, are defaults generated by Cloudformation, and the other two are the outputs we declared ourselves. If you click the TableViewerUrl value, you should see our pretty hitcounter table that we created in the initial workshop.\nAdd Validation Test Now we have our application deployed, but no CD pipeline is complete without tests!\nLet\u0026rsquo;s start with a simple test to ping our endpoints to see if they are alive. Return to lib/pipeline-stack.ts and add the following:\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import * as codecommit from \u0026#39;aws-cdk-lib/aws-codecommit\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; import {WorkshopPipelineStage} from \u0026#39;./pipeline-stage\u0026#39;; import {CodeBuildStep, CodePipeline, CodePipelineSource} from \u0026#34;aws-cdk-lib/pipelines\u0026#34;; export class WorkshopPipelineStack extends cdk.Stack { constructor(scope: Construct, id: string, props?: cdk.StackProps) { super(scope, id, props); // PIPELINE CODE HERE... const deploy = new WorkshopPipelineStage(this, \u0026#39;Deploy\u0026#39;); const deployStage = pipeline.addStage(deploy); deployStage.addPost( new CodeBuildStep(\u0026#39;TestViewerEndpoint\u0026#39;, { projectName: \u0026#39;TestViewerEndpoint\u0026#39;, envFromCfnOutputs: { ENDPOINT_URL: //TBD }, commands: [ \u0026#39;curl -Ssf $ENDPOINT_URL\u0026#39; ] }), new CodeBuildStep(\u0026#39;TestAPIGatewayEndpoint\u0026#39;, { projectName: \u0026#39;TestAPIGatewayEndpoint\u0026#39;, envFromCfnOutputs: { ENDPOINT_URL: //TBD }, commands: [ \u0026#39;curl -Ssf $ENDPOINT_URL\u0026#39;, \u0026#39;curl -Ssf $ENDPOINT_URL/hello\u0026#39;, \u0026#39;curl -Ssf $ENDPOINT_URL/test\u0026#39; ] }) ) } } We add post-deployment steps via deployStage.addPost(...) from CDK Pipelines. We add two actions to our deployment stage: to test our TableViewer endpoint and our APIGateway endpoint, respectively.\nNote: We submit several curl requests to the APIGateway endpoint so that when we look at our tableviewer, there are several values already populated.\nYou may notice that we have not yet set the URLs of these endpoints. This is because they are not yet exposed to this stack!\nWith a slight modification to lib/pipeline-stage.ts we can expose them:\nimport { CdkWorkshopStack } from \u0026#39;./cdk-workshop-stack\u0026#39;; import { Stage, CfnOutput, StageProps } from \u0026#39;aws-cdk-lib\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; export class WorkshopPipelineStage extends Stage { public readonly hcViewerUrl: CfnOutput; public readonly hcEndpoint: CfnOutput; constructor(scope: Construct, id: string, props?: StageProps) { super(scope, id, props); const service = new CdkWorkshopStack(this, \u0026#39;WebService\u0026#39;); this.hcEndpoint = service.hcEndpoint; this.hcViewerUrl = service.hcViewerUrl; } } Now we can add those values to our actions in lib/pipeline-stack.ts by getting the stackOutput of our pipeline stack: // CODE HERE... deployStage.addPost( new CodeBuildStep(\u0026#39;TestViewerEndpoint\u0026#39;, { projectName: \u0026#39;TestViewerEndpoint\u0026#39;, envFromCfnOutputs: { ENDPOINT_URL: deploy.hcViewerUrl }, commands: [ \u0026#39;curl -Ssf $ENDPOINT_URL\u0026#39; ] }), new CodeBuildStep(\u0026#39;TestAPIGatewayEndpoint\u0026#39;, { projectName: \u0026#39;TestAPIGatewayEndpoint\u0026#39;, envFromCfnOutputs: { ENDPOINT_URL: deploy.hcEndpoint }, commands: [ \u0026#39;curl -Ssf $ENDPOINT_URL\u0026#39;, \u0026#39;curl -Ssf $ENDPOINT_URL/hello\u0026#39;, \u0026#39;curl -Ssf $ENDPOINT_URL/test\u0026#39; ] }) )\nCommit and View! Commit those changes, wait for the pipeline to re-deploy the app, and navigate back to the CodePipeline Console and you can now see that there are two test actions contained within the Deploy stage!\nCongratulations! You have successfully created a CD pipeline for your application complete with tests and all! Feel free to explore the console to see the details of the stack created, or check out the API Reference section on CDK Pipelines and build one for your application.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/70-advanced-topics/200-pipelines/6000-cleanup.html","title":"Cleanup","tags":[],"description":"","content":"To clean up the stacks from this workshop, navigate to the Cloudformation Console, select your stacks, and hit \u0026ldquo;Delete\u0026rdquo;. This may take some time.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/70-advanced-topics/100-construct-testing/1000-assertion-test.html","title":"Assertion Tests","tags":[],"description":"","content":"Fine-Grained Assertion Tests Create a test for the DynamoDB table This section assumes that you have created the hit counter construct Our HitCounter construct creates a simple DynamoDB table. Lets create a test that validates that the table is getting created.\nIf cdk init created a test directory for you, then you should have a cdk-workshop.test.ts file. Delete this file.\nIf you do not already have a test directory (usually created automatically when you run cdk init), then create a test directory at the same level as bin and lib and then create a file called hitcounter.test.ts with the following code.\nimport { Template, Capture } from \u0026#39;aws-cdk-lib/assertions\u0026#39;; import * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import * as lambda from \u0026#39;aws-cdk-lib/aws-lambda\u0026#39;; import { HitCounter } from \u0026#39;../lib/hitcounter\u0026#39;; test(\u0026#39;DynamoDB Table Created\u0026#39;, () =\u0026gt; { const stack = new cdk.Stack(); // WHEN new HitCounter(stack, \u0026#39;MyTestConstruct\u0026#39;, { downstream: new lambda.Function(stack, \u0026#39;TestFunction\u0026#39;, { runtime: lambda.Runtime.NODEJS_14_X, handler: \u0026#39;hello.handler\u0026#39;, code: lambda.Code.fromAsset(\u0026#39;lambda\u0026#39;) }) }); // THEN const template = Template.fromStack(stack); template.resourceCountIs(\u0026#34;AWS::DynamoDB::Table\u0026#34;, 1); }); This test is simply testing to ensure that the synthesized stack includes a DynamoDB table.\nRun the test.\n$ npm run test You should see output like this:\n$ npm run test \u0026gt; cdk-workshop@0.1.0 test /home/aws-cdk-intro-workshop \u0026gt; jest PASS test/hitcounter.test.ts ✓ DynamoDB Table Created (182ms) Test Suites: 1 passed, 1 total Tests: 1 passed, 1 total Snapshots: 0 total Time: 3.273s Ran all test suites. Create a test for the Lambda function Now lets add another test, this time for the Lambda function that the HitCounter construct creates. This time in addition to testing that the Lambda function is created, we also want to test that it is created with the two environment variables DOWNSTREAM_FUNCTION_NAME \u0026amp; HITS_TABLE_NAME.\nAdd another test below the DynamoDB test. If you remember, when we created the lambda function the environment variable values were references to other constructs.\nthis.handler = new lambda.Function(this, \u0026#39;HitCounterHandler\u0026#39;, { runtime: lambda.Runtime.NODEJS_14_X, handler: \u0026#39;hitcounter.handler\u0026#39;, code: lambda.Code.fromAsset(\u0026#39;lambda\u0026#39;), environment: { DOWNSTREAM_FUNCTION_NAME: props.downstream.functionName, HITS_TABLE_NAME: table.tableName } }); At this point we don\u0026rsquo;t really know what the value of the functionName or tableName will be since the CDK will calculate a hash to append to the end of the name of the constructs, so we will just use a dummy value for now. Once we run the test it will fail and show us the expected value.\nCreate a new test in hitcounter.test.ts with the below code:\ntest(\u0026#39;Lambda Has Environment Variables\u0026#39;, () =\u0026gt; { const stack = new cdk.Stack(); // WHEN new HitCounter(stack, \u0026#39;MyTestConstruct\u0026#39;, { downstream: new lambda.Function(stack, \u0026#39;TestFunction\u0026#39;, { runtime: lambda.Runtime.NODEJS_14_X, handler: \u0026#39;hello.handler\u0026#39;, code: lambda.Code.fromAsset(\u0026#39;lambda\u0026#39;) }) }); // THEN const template = Template.fromStack(stack); const envCapture = new Capture(); template.hasResourceProperties(\u0026#34;AWS::Lambda::Function\u0026#34;, { Environment: envCapture, }); expect(envCapture.asObject()).toEqual( { Variables: { DOWNSTREAM_FUNCTION_NAME: { Ref: \u0026#34;TestFunctionXXXXX\u0026#34;, }, HITS_TABLE_NAME: { Ref: \u0026#34;MyTestConstructHitsXXXXX\u0026#34;, }, }, } ); }); Save the file and run the test again.\n$ npm run test This time the test should fail and you should be able to grab the correct value for the variables from the expected output.\n$ npm run test \u0026gt; cdk-workshop@0.1.0 test /home/aws-cdk-intro-workshop \u0026gt; jest FAIL test/hitcounter.test.ts ✓ DynamoDB Table Created (184ms) ✕ Lambda Has Environment Variables (53ms) ● Lambda Has Environment Variables expect(received).toEqual(expected) // deep equality - Expected - 2 + Received + 2 Object { \u0026#34;Variables\u0026#34;: Object { \u0026#34;DOWNSTREAM_FUNCTION_NAME\u0026#34;: Object { - \u0026#34;Ref\u0026#34;: \u0026#34;TestFunctionXXXXX\u0026#34;, + \u0026#34;Ref\u0026#34;: \u0026#34;TestFunction22AD90FC\u0026#34;, }, \u0026#34;HITS_TABLE_NAME\u0026#34;: Object { - \u0026#34;Ref\u0026#34;: \u0026#34;MyTestConstructHitsXXXXX\u0026#34;, + \u0026#34;Ref\u0026#34;: \u0026#34;MyTestConstructHits24A357F0\u0026#34;, }, }, } 37 | Environment: envCapture, 38 | }); \u0026gt; 39 | expect(envCapture.asObject()).toEqual( | ^ 40 | { 41 | Variables: { 42 | DOWNSTREAM_FUNCTION_NAME: { at Object.\u0026lt;anonymous\u0026gt; (test/hitcounter.test.ts:39:33) Test Suites: 1 failed, 1 total Tests: 1 failed, 1 passed, 2 total Snapshots: 0 total Time: 3.971 s, estimated 4 s Ran all test suites. Grab the real values for the environment variables and update your test\ntest(\u0026#39;Lambda Has Environment Variables\u0026#39;, () =\u0026gt; { const stack = new cdk.Stack(); // WHEN new HitCounter(stack, \u0026#39;MyTestConstruct\u0026#39;, { downstream: new lambda.Function(stack, \u0026#39;TestFunction\u0026#39;, { runtime: lambda.Runtime.NODEJS_14_X, handler: \u0026#39;hello.handler\u0026#39;, code: lambda.Code.fromAsset(\u0026#39;lambda\u0026#39;) }) }); // THEN const template = Template.fromStack(stack); const envCapture = new Capture(); template.hasResourceProperties(\u0026#34;AWS::Lambda::Function\u0026#34;, { Environment: envCapture, }); expect(envCapture.asObject()).toEqual( { Variables: { DOWNSTREAM_FUNCTION_NAME: { Ref: \u0026#34;VALUE_GOES_HERE\u0026#34;, }, HITS_TABLE_NAME: { Ref: \u0026#34;VALUE_GOES_HERE\u0026#34;, }, }, } ); }); Now run the test again. This time is should pass.\n$ npm run test You should see output like this:\n$ npm run test \u0026gt; cdk-workshop@0.1.0 test /home/aws-cdk-intro-workshop \u0026gt; jest PASS test/hitcounter.test.ts ✓ DynamoDB Table Created (182ms) ✓ Lambda Has Environment Variables (50ms) Test Suites: 1 passed, 1 total Tests: 2 passed, 2 total Snapshots: 0 total Time: 3.294s Ran all test suites. You can also apply TDD (Test Driven Development) to developing CDK Constructs. For a very simple example, lets add a new requirement that our DynamoDB table be encrypted.\nFirst we\u0026rsquo;ll update the test to reflect this new requirement.\nimport { Template, Capture } from \u0026#39;aws-cdk-lib/assertions\u0026#39;; import cdk = require(\u0026#39;aws-cdk-lib\u0026#39;); import * as lambda from \u0026#39;aws-cdk-lib/aws-lambda\u0026#39;; import { HitCounter } from \u0026#39;../lib/hitcounter\u0026#39;; test(\u0026#39;DynamoDB Table Created With Encryption\u0026#39;, () =\u0026gt; { const stack = new cdk.Stack(); // WHEN new HitCounter(stack, \u0026#39;MyTestConstruct\u0026#39;, { downstream: new lambda.Function(stack, \u0026#39;TestFunction\u0026#39;, { runtime: lambda.Runtime.NODEJS_14_X, handler: \u0026#39;hello.handler\u0026#39;, code: lambda.Code.fromAsset(\u0026#39;lambda\u0026#39;) }) }); // THEN const template = Template.fromStack(stack); template.hasResourceProperties(\u0026#39;AWS::DynamoDB::Table\u0026#39;, { SSESpecification: { SSEEnabled: true } }); }); Now run the test, which should fail.\n$ npm run test \u0026gt; cdk-workshop@0.1.0 test /home/aws-cdk-intro-workshop \u0026gt; jest FAIL test/hitcounter.test.ts ✓ DynamoDB Table Created (170ms) ✓ Lambda Has Environment Variables (50ms) ✕ DynamoDB Table Created With Encryption (49ms) ● DynamoDB Table Created With Encryption Template has 1 resources with type AWS::DynamoDB::Table, but none match as expected. The closest result is: { \u0026#34;Type\u0026#34;: \u0026#34;AWS::DynamoDB::Table\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;KeySchema\u0026#34;: [ { \u0026#34;AttributeName\u0026#34;: \u0026#34;path\u0026#34;, \u0026#34;KeyType\u0026#34;: \u0026#34;HASH\u0026#34; } ], \u0026#34;AttributeDefinitions\u0026#34;: [ { \u0026#34;AttributeName\u0026#34;: \u0026#34;path\u0026#34;, \u0026#34;AttributeType\u0026#34;: \u0026#34;S\u0026#34; } ], \u0026#34;ProvisionedThroughput\u0026#34;: { \u0026#34;ReadCapacityUnits\u0026#34;: 5, \u0026#34;WriteCapacityUnits\u0026#34;: 5 } }, \u0026#34;UpdateReplacePolicy\u0026#34;: \u0026#34;Retain\u0026#34;, \u0026#34;DeletionPolicy\u0026#34;: \u0026#34;Retain\u0026#34; } with the following mismatches: Missing key at /Properties/SSESpecification (using objectLike matcher) 63 | 64 | const template = Template.fromStack(stack); \u0026gt; 65 | template.hasResourceProperties(\u0026#34;AWS::DynamoDB::Table\u0026#34;, { | ^ 66 | SSESpecification: { 67 | SSEEnabled: true 68 | } at Template.hasResourceProperties (node_modules/aws-cdk-lib/assertions/lib/template.ts:50:13) at Object.\u0026lt;anonymous\u0026gt; (test/hitcounter.test.ts:65:12) Test Suites: 1 failed, 1 total Tests: 1 failed, 3 passed, 4 total Snapshots: 0 total Time: 3.947 s, estimated 4 s Ran all test suites. Now lets fix the broken test. Update the hitcounter code to enable encryption by default.\nexport class HitCounter extends Construct { /** allows accessing the counter function */ public readonly handler: lambda.Function; /** the hit counter table */ public readonly table: dynamodb.Table; constructor(scope: Construct, id: string, props: HitCounterProps) { super(scope, id); const table = new dynamodb.Table(this, \u0026#39;Hits\u0026#39;, { partitionKey: { name: \u0026#39;path\u0026#39;, type: dynamodb.AttributeType.STRING }, encryption: dynamodb.TableEncryption.AWS_MANAGED }); ... } } Now run the test again, which should now pass.\nnpm run test \u0026gt; cdk-workshop@0.1.0 test /home/aws-cdk-intro-workshop \u0026gt; jest PASS test/hitcounter.test.ts ✓ DynamoDB Table Created (171ms) ✓ Lambda Has Environment Variables (52ms) ✓ DynamoDB Table Created With Encryption (47ms) Test Suites: 1 passed, 1 total Tests: 3 passed, 3 total Snapshots: 0 total Time: 3.913s Ran all test suites. "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/70-advanced-topics/200-pipelines.html","title":"CDK Pipelines","tags":[],"description":"","content":"CDK Pipelines In this chapter we will create a Continuous Deployment (CD) pipeline for the app developed in previous chapters.\nCD is an important component to most web project, but can be challenging to set up with all the moving parts required. The CDK Pipelines construct makes that process easy and streamlined from within your existing CDK infrastructure design.\nThese pipelines consist of \u0026ldquo;stages\u0026rdquo; that represent the phases of your deployment process from how the source code is managed, to how the fully built artifacts are deployed.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/30-hello-cdk/200-lambda.html","title":"Hello Lambda","tags":[],"description":"","content":"Lambda handler code まずは、Lambda handlerのコードから書いていきます。\n次のコマンドでLambdaをTypeScriptで記述しやすくするモジュールをインストールします。 npm install --save-dev esbuild@0 @types/aws-lambda aws-sdk cdk-workshopディレクトリにlambdaディレクトリを作成します。 lambda/hello.tsというファイルを追加し、以下の内容を記述します。 export const handler: AWSLambda.APIGatewayProxyHandler = async (event) =\u0026gt; { console.log(\u0026#34;request:\u0026#34;, JSON.stringify(event, undefined, 2)); return { statusCode: 200, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/plain\u0026#34; }, body: `Hello, CDK! You\u0026#39;ve hit ${event.path}\\n` }; }; これは、「Hello, CDK! You’ve hit [url path]」というテキストを返す単純なLambda関数です。 HTTPステータスコードとHTTPヘッダーが付加されたHTTPレスポンスとしてユーザーに応答するために、API Gatewayを使用します。\nこのLambda関数はTypeScriptで実装されていますが、実際のLambda上ではJavaScriptに変換されたコードが動作します。 これは、デプロイ時にはCDKがesbuildでJavaScriptにビルドしてくれるためです。 その他の言語での実装についてはAWS Lambdaのドキュメントを参照してください。\nコピー＆ペーストは使わずにコードを書いてみましょう このワークショップでは、コピー\u0026amp;ペーストをするのではなく、実際にCDKのコードを入力することを強く推奨します（通常、入力する量は多くありません）。 これにより、CDKの使い方についてより理解していただけます。 IDEがオートコンプリート、インラインドキュメント、およびタイプセーフに対応しているのがご理解いただけるでしょう。\nAWS Lambda関数をスタックに追加する importステートメントをlib/cdk-workshop-stack.tsの冒頭に挿入し、lambda.Functionをスタックに追加します。\nimport { Stack, StackProps } from \u0026#39;aws-cdk-lib\u0026#39;; import { Runtime } from \u0026#39;aws-cdk-lib/aws-lambda\u0026#39;; import { NodejsFunction } from \u0026#39;aws-cdk-lib/aws-lambda-nodejs\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; export class CdkWorkshopStack extends Stack { constructor(scope: Construct, id: string, props?: StackProps) { super(scope, id, props); // AWS Lambdaリソースを定義 const hello = new NodejsFunction(this, \u0026#39;HelloHandler\u0026#39;, { runtime: Runtime.NODEJS_16_X, // 実行環境 entry: \u0026#39;lambda/hello.ts\u0026#39;, // エントリーファイルはhello.ts }); } } 注目すべきいくつかの点：\nこの関数はNODEJS_16_X(Nodejs v16.x)ランタイムを使用します。 ハンドラーコードは、先程作った lambda ディレクトリからロードされます。 パスは、cdk コマンドが実行されたディレクトリから相対パスです。 コンストラクト(constructs) と コンストラクター(constructors) について ご覧のとおり、CdkWorkshopStackとNodejsFunctionの両方のコンストラクタークラス（およびCDKの他の多くのクラス）は(scope, id, props)という同じような引数を受け取ります。 これは、これらのクラスがすべてコンストラクタであるためです。\nコンストラクトはCDKアプリの基本的な構成要素です。 それらは「クラウドコンポーネント」を表現します。クラウドコンポーネントはスコープを介してより高いレベルの抽象化に構築できます。 スコープにはコンストラクトを含めることができ、そのコンストラクトには他のコンストラクトなどを含めることができます。\nコンストラクトは常に別のコンストラクトのスコープ内で作成され、作成されたスコープ内で一意でなければならない識別子（id）を持っている必要があります。 したがって、コンストラクト初期化子（コンストラクター）には常に次のシグネチャが必要です。\nscope： : 最初の引数には、この構成が作成されるスコープを必ず指定します。 ほとんどすべての場合、現在の コンストラクトスコープ内でコンストラクトを定義することになります。 つまり、通常最初の引数にはthisを渡すだけです。\nid ： 2番目の引数は、構造のローカルIDです。 これは、同じスコープ内のコンストラクト間で一意である必要があるIDです。 CDKはこのIDを使用して、 このスコープ内で定義された各リソースのCloudFormation 論理IDを計算します。 CDKのIDの詳細については、CDKユーザーマニュアルを参照してください。\nprops : 最後の（場合によっては不要である場合もある）引数は、初期化プロパティのセットです。 これらは各コンストラクトで固有です。 たとえば、NodejsFunctionコンストラクトはruntime、entryのようなプロパティを受け取ります。 IDEのオートコンプリートまたはオンラインドキュメントを使用して、さまざまなオプションを調べられます。\nDiff コードを保存し、デプロイする前に差分を見てみましょう。\ncdk diff 出力は次のようになります。\nStack CdkWorkshopStack IAM Statement Changes ┌───┬─────────────────────────────────┬────────┬────────────────┬──────────────────────────────┬───────────┐ │ │ Resource │ Effect │ Action │ Principal │ Condition │ ├───┼─────────────────────────────────┼────────┼────────────────┼──────────────────────────────┼───────────┤ │ + │ ${HelloHandler/ServiceRole.Arn} │ Allow │ sts:AssumeRole │ Service:lambda.amazonaws.com │ │ └───┴─────────────────────────────────┴────────┴────────────────┴──────────────────────────────┴───────────┘ IAM Policy Changes ┌───┬─────────────────────────────┬────────────────────────────────────────────────────────────────────────────────┐ │ │ Resource │ Managed Policy ARN │ ├───┼─────────────────────────────┼────────────────────────────────────────────────────────────────────────────────┤ │ + │ ${HelloHandler/ServiceRole} │ arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole │ └───┴─────────────────────────────┴────────────────────────────────────────────────────────────────────────────────┘ (NOTE: There may be security-related changes not in this list. See https://github.com/aws/aws-cdk/issues/1299) Resources [+] AWS::IAM::Role HelloHandler/ServiceRole HelloHandlerServiceRole11EF7C63 [+] AWS::Lambda::Function HelloHandler HelloHandler2E4FBA4D 上記のとおり、このコードから AWS::Lambda::Function リソース用のCloudFormationテンプレートを生成しました。 また、ツールキットがハンドラーコードの場所を伝達するためにいくつかのCloudFormationパラメーターを利用しています。\nDeploy 次にデプロイをします。\ncdk deploy cdk deploy を実行すると、CloudFormationスタックをデプロイするだけでなく、 初期構築したS3バケットに対して、ローカルの lambda ディレクトリを圧縮後、アップロードしていることがが分かるでしょう。\nLambda関数のテスト AWS Lambdaコンソールに移動して、Lambda関数をテストしましょう。\nAWS Lambdaコンソール を開きます （正しいリージョンにいることを確認してください）。\nLambda関数が表示されます。\n関数名をクリックして、コンソールを移動します。\nテストタブをクリックします。\nイベント名にtestを入力します。\nテンプレートリストからAmazon API Gateway AWS Proxyを選択します。\n保存をクリックします。\nテストをクリックし、実行が完了するまで待ちます。\n実行結果ペインで詳細を展開すると、出力が表示されます。\n👏 "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/70-advanced-topics/100-construct-testing/2000-validation-tests.html","title":"Validation Tests","tags":[],"description":"","content":"Validation Tests Sometimes we want the inputs to be configurable, but we also want to put constraints on those inputs or validate that the input is valid.\nSuppose for the HitCounter construct we want to allow the user to specify the readCapacity on the DynamoDB table, but we also want to ensure the value is within a reasonable range. We can write a test to make sure that the validation logic works: pass in invalid values and see what happens.\nFirst, add a readCapacity property to the HitCounterProps interface:\nexport interface HitCounterProps { /** the function for which we want to count url hits **/ downstream: lambda.IFunction; /** * The read capacity units for the table * * Must be greater than 5 and lower than 20 * * @default 5 */ readCapacity?: number; } Then update the DynamoDB table resource to add the readCapacity property.\nconst table = new dynamodb.Table(this, \u0026#39;Hits\u0026#39;, { partitionKey: { name: \u0026#39;path\u0026#39;, type: dynamodb.AttributeType.STRING }, encryption: dynamodb.TableEncryption.AWS_MANAGED, readCapacity: props.readCapacity ?? 5 }); Now add a validation which will throw an error if the readCapacity is not in the allowed range.\nexport class HitCounter extends Construct { /** allows accessing the counter function */ public readonly handler: lambda.Function; /** the hit counter table */ public readonly table: dynamodb.Table; constructor(scope: Construct, id: string, props: HitCounterProps) { if (props.readCapacity !== undefined \u0026amp;\u0026amp; (props.readCapacity \u0026lt; 5 || props.readCapacity \u0026gt; 20)) { throw new Error(\u0026#39;readCapacity must be greater than 5 and less than 20\u0026#39;); } super(scope, id); // ... } } Now lets add a test that validates the error is thrown.\ntest(\u0026#39;read capacity can be configured\u0026#39;, () =\u0026gt; { const stack = new cdk.Stack(); expect(() =\u0026gt; { new HitCounter(stack, \u0026#39;MyTestConstruct\u0026#39;, { downstream: new lambda.Function(stack, \u0026#39;TestFunction\u0026#39;, { runtime: lambda.Runtime.NODEJS_14_X, handler: \u0026#39;hello.handler\u0026#39;, code: lambda.Code.fromAsset(\u0026#39;lambda\u0026#39;) }), readCapacity: 3 }); }).toThrowError(/readCapacity must be greater than 5 and less than 20/); }); Run the test.\n$ npm run test You should see an output like this:\n$ npm run test \u0026gt; cdk-workshop@0.1.0 test /home/aws-cdk-intro-workshop \u0026gt; jest PASS test/hitcounter.test.ts ✓ DynamoDB Table Created (206 ms) ✓ Lambda Has Environment Variables (61 ms) ✓ DynamoDB Table Created With Encryption (55 ms) ✓ Read Capacity can be configured (14 ms) Test Suites: 1 passed, 1 total Tests: 4 passed, 4 total Snapshots: 0 total Time: 4.755 s, estimated 5 s Ran all test suites. "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/20-create-project/300-structure.html","title":"プロジェクト構造","tags":[],"description":"","content":"IDEを開く 使い慣れたIDEでプロジェクトを開いてみましょう。\nCloud9 を使用する場合は、すでにIDEの画面で操作を行っています。\nVSCodeを使用する場合は、 code . コマンドをプロジェクトディレクトリ内で実行すれば簡単に開けます。\nプロジェクトディレクトリを確認する 以下のようなディレクトリ構成が確認できます。\nlib/cdk-workshop-stack.ts CDKアプリケーションのメインスタックが定義されます。 今回のワークショップではこのファイルを主に修正します。 bin/cdk-workshop.ts CDKアプリケーションのエントリポイントです。 lib/cdk-workshop-stack.ts で定義されたスタックをロードします。 package.json npmモジュールのマニフェストです。 アプリの名前、バージョン、依存関係、\u0026ldquo;watch\u0026rdquo; や \u0026ldquo;build\u0026rdquo; 用のビルドスクリプトなどの情報が含まれます（package-lock.json はnpmによって管理されます） cdk.json アプリの実行方法をツールキットに指示させるためのファイルです。 今回の場合は、 \u0026quot;npx ts-node bin/cdk-workshop.ts\u0026quot; です。 tsconfig.json プロジェクトの TypeScript設定 です。 .gitignore, .npmignore Gitとnpm用のファイルです。 ソースコードの管理に含める/除外するファイルと、パッケージマネージャーへの公開用設定が含まれています。 node_modules npmによって管理され、プロジェクトのすべての依存関係が含まれます。 アプリのエントリポイント bin/cdk-workshop.tsを簡単に見てみましょう。\n#!/usr/bin/env node import * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import { CdkWorkshopStack } from \u0026#39;../lib/cdk-workshop-stack\u0026#39;; const app = new cdk.App(); new CdkWorkshopStack(app, \u0026#39;CdkWorkshopStack\u0026#39;); このコードは、lib/cdk-workshop-stack.tsファイルを開き、 CdkWorkshopStack クラス をロードして初期化するものです。 一度読んだら、もうこのファイルを見る必要はありません。\nメインスタック lib/cdk-workshop-stack.tsを開いてみましょう。これがアプリケーションの要です。\nimport { Duration, Stack, StackProps } from \u0026#39;aws-cdk-lib\u0026#39;; import * as sns from \u0026#39;aws-cdk-lib/aws-sns\u0026#39;; import * as subs from \u0026#39;aws-cdk-lib/aws-sns-subscriptions\u0026#39;; import * as sqs from \u0026#39;aws-cdk-lib/aws-sqs\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; export class CdkWorkshopStack extends Stack { constructor(scope: Construct, id: string, props?: StackProps) { super(scope, id, props); const queue = new sqs.Queue(this, \u0026#39;CdkWorkshopQueue\u0026#39;, { visibilityTimeout: Duration.seconds(300) }); const topic = new sns.Topic(this, \u0026#39;CdkWorkshopTopic\u0026#39;); topic.addSubscription(new subs.SqsSubscription(queue)); } } ご覧のとおり、アプリはサンプルCDKスタック(CdkWorkshopStack)です.\nこのスタックは次のものを含みます。\nSQS キュー (new sqs.Queue) SNS トピック (new sns.Topic) キューをサブスクライブして、トピックに発行されたメッセージを受信します (topic.addSubscription) "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/40-hit-counter/300-resources.html","title":"リソースの定義","tags":[],"description":"","content":"HitCounterコンストラクトにリソースを追加する 次に、Lambda関数とDynamoDBテーブルをHitCounterコンストラクトに定義します。\nlib/hitcounter.ts に戻って、以下のコードを追記しましょう。\nimport { AttributeType, Table } from \u0026#39;aws-cdk-lib/aws-dynamodb\u0026#39;; import { IFunction, Runtime } from \u0026#39;aws-cdk-lib/aws-lambda\u0026#39;; import { NodejsFunction } from \u0026#39;aws-cdk-lib/aws-lambda-nodejs\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; import { RemovalPolicy } from \u0026#39;aws-cdk-lib\u0026#39; export interface HitCounterProps { /** the function for which we want to count url hits **/ downstream: IFunction; } export class HitCounter extends Construct { /** allows accessing the counter function */ public readonly handler: IFunction; constructor(scope: Construct, id: string, props: HitCounterProps) { super(scope, id); const table = new Table(this, \u0026#39;Hits\u0026#39;, { partitionKey: { name: \u0026#39;path\u0026#39;, type: AttributeType.STRING }, // Note: プロダクションではDBテーブルは保持することが多いが今回はハンズオンのためDESTROYを指定 removalPolicy: cdk.RemovalPolicy.DESTROY, }); this.handler = new NodejsFunction(this, \u0026#39;HitCounterHandler\u0026#39;, { runtime: Runtime.NODEJS_16_X, entry: \u0026#39;lambda/hitcounter.ts\u0026#39;, environment: { DOWNSTREAM_FUNCTION_NAME: props.downstream.functionName, HITS_TABLE_NAME: table.tableName, }, }); // Lambda関数に対してテーブルを読み書き/別のLambdaを実行する権限を付与 // CDKでは「grant」を利用してリソースに権限を付与できる table.grantReadWriteData(this.handler); props.downstream.grantInvoke(this.handler); } } コードの解説 DynamoDBテーブルにpathパーティションキーを定義しました。 lambda/hitcounter.tsにバインドされるLambda関数を定義しました。 Lambdaの環境変数とdownstream.functionName、table.tableNameとを紐付けました。 遅延バインディング値 functionNameとtableNameプロパティは、CloudFormationスタックをデプロイするタイミングで解決される値です （テーブル/関数を定義した時点では、まだ物理名が決まっていないことに注目してください。論理IDだけが決まっています。）。 CloudFormationテンプレート生成時にそれらの値を表示すると、\u0026ldquo;TOKEN\u0026rdquo; という値が得られます。 この値は、CDKがこれらの遅延バインディング値をどのように表現するかを示しています。 CDKはこれらの遅延バインディング値を未定の値として扱う必要があります。 例えば、それらを連結することはできますが、コード内でそれらを解析（splitやsubstringなど）しても正しく動作することはありません。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/30-hello-cdk/300-cdk-watch.html","title":"参考：CDK Watch","tags":[],"description":"","content":"より高速なデプロイ このセクションはワークショップを完了するために必要ではありませんが、 cdk deploy --hotswap と cdk watch がどのようにデプロイを高速化するのか見てみましょう。\nlambdaが動作するようになりましたね！ しかし、もしlambdaのコードを微調整して正しく動作させたい場合はどうしたらよいでしょうか？ 例えば、lambda関数を「Hello, CDK」ではなく「Good Morning, CDK!」と応答させることに決めたとしましょう。\n今のところ、スタックを更新するために使えるツールは cdk deploy しかないように思えます。 しかし、cdk deployには時間がかかります。 CloudFormationスタックをデプロイして、lambdaディレクトリをbootstrapバケットにアップロードしなければならないからです。 lambdaのコードを変更するだけならCloudFormationスタックを更新する必要はないので、cdk deployの部分は無駄な労力となります。\n本当に必要なのは、lambdaコードの更新だけなのです。 それだけを行うための他のメカニズムがあれば最高なのですが\u0026hellip;。\ncdk deploy にかかる時間を測ってみる まず、cdk deployを実行するのにかかる時間を計ってみましょう。 これは、CloudFormationのフルデプロイにどれくらい時間がかかるかの基準値になります。 そのために、lambda/hello.ts 内のコードを変更します。\nexport const handler: AWSLambda.APIGatewayProxyHandler = async (event) =\u0026gt; { console.log(\u0026#34;request:\u0026#34;, JSON.stringify(event, undefined, 2)); return { statusCode: 200, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/plain\u0026#34; }, body: `Good Morning, CDK! You\u0026#39;ve hit ${event.path}\\n` }; }; 変更が cdk deploy を実行してみましょう。\ncdk deploy 出力は次のようになります。\n✨ Synthesis time: 42.35s CdkWorkshopStack: deploying... CdkWorkshopStack: creating CloudFormation changeset... ✅ CdkWorkshopStack ✨ Deployment time: 27.48s Stack ARN: arn:aws:cloudformation:REGION:ACCOUNT-ID:stack/CdkWorkshopStack/STACK-ID ✨ Total time: 69.83s 正確な時間にはばらつきがありますが、通常のデプロイにかかる時間については、かなりの目安になるはずです！\nHotswap deployments このコマンドは、デプロイを高速化するために、CloudFormationのスタックに意図的にドリフトを発生させるものです。 このため、開発目的にのみ使用してください。 本番デプロイには絶対にhotswapを使わないでください！\nCDK deploy --hotswap を使えばデプロイ時間を短縮することができます。これはCloudFormation のデプロイの代わりにホットスワップデプロイが実行可能かどうかを評価してくれます。 ホットスワップデプロイが可能であれば、CDK CLIはAWSサービスAPIを使用して直接変更を行います。そうでない場合は、CloudFormationのフルデプロイメントを実行します。\nここでは、cdk deploy --hotswap を使用して、AWS Lambda のアセットコードにホットスワップ可能な変更をデプロイします。\ncdk deploy --hotswap にかかる時間を測ってみる lambda/hello.tsのlambdaコードをもう一度変えてみましょう。\nexport const handler: AWSLambda.APIGatewayProxyHandler = async (event) =\u0026gt; { console.log(\u0026#34;request:\u0026#34;, JSON.stringify(event, undefined, 2)); return { statusCode: 200, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/plain\u0026#34; }, body: `Good Afternoon, CDK! You\u0026#39;ve hit ${event.path}\\n` }; }; そして cdk deploy --hotswap を実行してみます。\ncdk deploy --hotswap 出力は次のようになります。\n✨ Synthesis time: 21.51s ⚠️ The --hotswap flag deliberately introduces CloudFormation drift to speed up deployments ⚠️ It should only be used for development - never use it for your production Stacks! CdkWorkshopStack: deploying... ✨ hotswapping resources: ✨ Lambda Function \u0026#39;CdkWorkshopStack-HelloHandler2E4FBA4D-Cho6nu1hDGKg\u0026#39; ✨ Lambda Function \u0026#39;CdkWorkshopStack-HelloHandler2E4FBA4D-Cho6nu1hDGKg\u0026#39; hotswapped! ✅ CdkWorkshopStack ✨ Deployment time: 2.81s Stack ARN: arn:aws:cloudformation:REGION:ACCOUNT-ID:stack/CdkWorkshopStack/STACK-ID ✨ Total time: 24.31s さきほどのフルデプロイメントには69秒かかりましたが、ホットスワップデプロイは24秒でデプロイが完了しました！ しかし、警告メッセージが出ていますね。--hotswapフラグの使用上の注意ですのでよく読んでください。\n⚠️ The --hotswap flag deliberately introduces CloudFormation drift to speed up deployments ⚠️ It should only be used for development - never use it for your production Stacks! --hotswap フラグは、デプロイメントを高速化するために意図的に CloudFormation のドリフトを導入しています。 これは開発のみに使用すべきです - 決して本番のStacksには使用しないでください！\n本当にデプロイできたのでしょうか？ 高速にデプロイされることが確認できたと思います。 実際にコードは変更されたのでしょうか？ AWS Lambda Consoleで再確認してみましょう!\nAWS Lambda Consoleを開きます。 (正しいリージョンにいることを確認してください)\nデプロイした関数を見つけてください。\n関数の名前をクリックします。\nデプロイされたコードが表示されます。変更されていることは確認できましたでしょうか？\nCDK Watch 毎回 cdk deploy や cdk deploy --hotswap を呼び出すよりも、もっと良い方法があるはずです。 cdk watch は cdk deploy と似ていますが、ワンショットの操作ではなく、 コードやアセットの変更を監視して、変更が検出されたときに自動的にデプロイを実行してくれます。 デフォルトでは、cdk watch は --hotswap フラグを使用し、変更を検査し、その変更がホットスワップ可能かどうかを決定します。 cdk watch --no-hotswapを呼び出すと、ホットスワップの動作が無効化されます。\n一度設定すれば、cdk watchを使用して、ホットスワップ可能な変更とCloudFormationのフルデプロイを必要とする変更の両方を検出することができます。\ncdk watch にかかる時間を測ってみる まず cdk watch を実行してみます。\ncdk watch これで初期デプロイが始まり、すぐに cdk.json で指定したファイルの監視を開始します。\nもう一度、lambda/hello.ts を変更してみましょう。\nexport const handler: AWSLambda.APIGatewayProxyHandler = async (event) =\u0026gt; { console.log(\u0026#34;request:\u0026#34;, JSON.stringify(event, undefined, 2)); return { statusCode: 200, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/plain\u0026#34; }, body: `Good Night, CDK! You\u0026#39;ve hit ${event.path}\\n` }; }; Lambda コードファイルの変更を保存すると、cdk watch がファイルが変更されたことを認識し、新しいデプロイメントが開始されます。 今回は、lambdaアセットコードをホットスワップできることを認識し、CloudFormation のデプロイを回避して、代わりに Lambda サービスに直接デプロイされます。\nデプロイはどれくらいの速度で行われたのでしょうか？\nDetected change to \u0026#39;lambda/hello.ts\u0026#39; (type: change) while \u0026#39;cdk deploy\u0026#39; is still running. Will queue for another deployment after this one finishes ✨ Synthesis time: 18.63s ⚠️ The --hotswap flag deliberately introduces CloudFormation drift to speed up deployments ⚠️ It should only be used for development - never use it for your production Stacks! CdkWorkshopStack: deploying... ✨ hotswapping resources: ✨ Lambda Function \u0026#39;CdkWorkshopStack-HelloHandler2E4FBA4D-Cho6nu1hDGKg\u0026#39; ✨ Lambda Function \u0026#39;CdkWorkshopStack-HelloHandler2E4FBA4D-Cho6nu1hDGKg\u0026#39; hotswapped! ✅ CdkWorkshopStack ✨ Deployment time: 2.93s Stack ARN: arn:aws:cloudformation:REGION:ACCOUNT-ID:stack/CdkWorkshopStack/STACK-ID ✨ Total time: 21.56s まとめ このチュートリアルの残りの部分では、cdk watchの代わりにcdk deployを使い続けます。 しかし、必要であれば、単に cdk watch をオンにしておくこともできます。 もし、完全なデプロイが必要な場合は、cdk watch が cdk deploy を呼び出します。\ncdk watch の使用例についての詳細は、Increasing Development Speed with CDK Watchを参照してください。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/30-hello-cdk/400-apigw.html","title":"API Gateway","tags":[],"description":"","content":"次のステップでは、Amazon API Gateway（以降、API Gateway）を関数の前に追加していきます。 API GatewayはパブリックHTTPエンドポイントを公開します。このエンドポイントは、インターネット上の誰もが curlやウェブブラウザのようなHTTPクライアントでヒットできます。\nAPI Gatewayのルートには、 Lambda proxy integrationを利用します。 これは、どのURLパスへのリクエストも、直接Lambda関数にプロキシされ、関数からのレスポンスがユーザーに返される動作となります。\nLambdaRestApi コンストラクトを追加する lib/cdk-workshop-stack.ts に戻り、APIエンドポイントを定義してLambda関数に関連付けましょう。\nimport { Stack, StackProps } from \u0026#39;aws-cdk-lib\u0026#39;; import { LambdaRestApi } from \u0026#39;aws-cdk-lib/aws-apigateway\u0026#39;; import { Runtime } from \u0026#39;aws-cdk-lib/aws-lambda\u0026#39;; import { NodejsFunction } from \u0026#39;aws-cdk-lib/aws-lambda-nodejs\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; export class CdkWorkshopStack extends Stack { constructor(scope: Construct, id: string, props?: StackProps) { super(scope, id, props); // AWS Lambdaリソースを定義 const hello = new NodejsFunction(this, \u0026#39;HelloHandler\u0026#39;, { runtime: Runtime.NODEJS_16_X, entry: \u0026#39;lambda/hello.ts\u0026#39;, }); // \u0026#34;hello\u0026#34; 関数をバックに持つAPI Gateway REST APIリソースを定義 new LambdaRestApi(this, \u0026#39;Endpoint\u0026#39;, { handler: hello, }); } } 以上です。これで、すべてのリクエストをAWS Lambda関数にプロキシするAPI Gatewayが定義されました。\ncdk diff これをデプロイするとどうなるのか見てみましょう。\ncdk diff 出力は次のようになります。\nStack CdkWorkshopStack IAM Statement Changes ┌───┬─────────────────────┬────────┬───────────────────────┬──────────────────────────────────────────────────────────────────┬───────────────────────────────────────────────────────────────────┐ │ │ Resource │ Effect │ Action │ Principal │ Condition │ ├───┼─────────────────────┼────────┼───────────────────────┼──────────────────────────────────────────────────────────────────┼───────────────────────────────────────────────────────────────────┤ │ + │ ${HelloHandler.Arn} │ Allow │ lambda:InvokeFunction │ Service:apigateway.amazonaws.com │ \u0026#34;ArnLike\u0026#34;: { │ │ │ │ │ │ │ \u0026#34;AWS:SourceArn\u0026#34;: \u0026#34;arn:${AWS::Partition}:execute-api:${AWS::Regi │ │ │ │ │ │ │ on}:${AWS::AccountId}:${EndpointEEF1FD8F}/${Endpoint/DeploymentSt │ │ │ │ │ │ │ age.prod}/*/*\u0026#34; │ │ │ │ │ │ │ } │ │ + │ ${HelloHandler.Arn} │ Allow │ lambda:InvokeFunction │ Service:apigateway.amazonaws.com │ \u0026#34;ArnLike\u0026#34;: { │ │ │ │ │ │ │ \u0026#34;AWS:SourceArn\u0026#34;: \u0026#34;arn:${AWS::Partition}:execute-api:${AWS::Regi │ │ │ │ │ │ │ on}:${AWS::AccountId}:${EndpointEEF1FD8F}/test-invoke-stage/*/*\u0026#34; │ │ │ │ │ │ │ } │ │ + │ ${HelloHandler.Arn} │ Allow │ lambda:InvokeFunction │ Service:apigateway.amazonaws.com │ \u0026#34;ArnLike\u0026#34;: { │ │ │ │ │ │ │ \u0026#34;AWS:SourceArn\u0026#34;: \u0026#34;arn:${AWS::Partition}:execute-api:${AWS::Regi │ │ │ │ │ │ │ on}:${AWS::AccountId}:${EndpointEEF1FD8F}/${Endpoint/DeploymentSt │ │ │ │ │ │ │ age.prod}/*/\u0026#34; │ │ │ │ │ │ │ } │ │ + │ ${HelloHandler.Arn} │ Allow │ lambda:InvokeFunction │ Service:apigateway.amazonaws.com │ \u0026#34;ArnLike\u0026#34;: { │ │ │ │ │ │ │ \u0026#34;AWS:SourceArn\u0026#34;: \u0026#34;arn:${AWS::Partition}:execute-api:${AWS::Regi │ │ │ │ │ │ │ on}:${AWS::AccountId}:${EndpointEEF1FD8F}/test-invoke-stage/*/\u0026#34; │ │ │ │ │ │ │ } │ └───┴─────────────────────┴────────┴───────────────────────┴──────────────────────────────────────────────────────────────────┴───────────────────────────────────────────────────────────────────┘ (NOTE: There may be security-related changes not in this list. See https://github.com/aws/aws-cdk/issues/1299) Resources [+] AWS::ApiGateway::RestApi Endpoint EndpointEEF1FD8F [+] AWS::ApiGateway::Deployment Endpoint/Deployment EndpointDeployment318525DA5f8cdfe532107839d82cbce31f859259 [+] AWS::ApiGateway::Stage Endpoint/DeploymentStage.prod EndpointDeploymentStageprodB78BEEA0 [+] AWS::ApiGateway::Resource Endpoint/Default/{proxy+} Endpointproxy39E2174E [+] AWS::Lambda::Permission Endpoint/Default/{proxy+}/ANY/ApiPermission.CdkWorkshopStackEndpoint018E8349.ANY..{proxy+} EndpointproxyANYApiPermissionCdkWorkshopStackEndpoint018E8349ANYproxy747DCA52 [+] AWS::Lambda::Permission Endpoint/Default/{proxy+}/ANY/ApiPermission.Test.CdkWorkshopStackEndpoint018E8349.ANY..{proxy+} EndpointproxyANYApiPermissionTestCdkWorkshopStackEndpoint018E8349ANYproxy41939001 [+] AWS::ApiGateway::Method Endpoint/Default/{proxy+}/ANY EndpointproxyANYC09721C5 [+] AWS::Lambda::Permission Endpoint/Default/ANY/ApiPermission.CdkWorkshopStackEndpoint018E8349.ANY.. EndpointANYApiPermissionCdkWorkshopStackEndpoint018E8349ANYE84BEB04 [+] AWS::Lambda::Permission Endpoint/Default/ANY/ApiPermission.Test.CdkWorkshopStackEndpoint018E8349.ANY.. EndpointANYApiPermissionTestCdkWorkshopStackEndpoint018E8349ANYB6CC1B64 [+] AWS::ApiGateway::Method Endpoint/Default/ANY EndpointANY485C938B Outputs [+] Output Endpoint/Endpoint Endpoint8024A810: {\u0026#34;Value\u0026#34;:{\u0026#34;Fn::Join\u0026#34;:[\u0026#34;\u0026#34;,[\u0026#34;https://\u0026#34;,{\u0026#34;Ref\u0026#34;:\u0026#34;EndpointEEF1FD8F\u0026#34;},\u0026#34;.execute-api.\u0026#34;,{\u0026#34;Ref\u0026#34;:\u0026#34;AWS::Region\u0026#34;},\u0026#34;.\u0026#34;,{\u0026#34;Ref\u0026#34;:\u0026#34;AWS::URLSuffix\u0026#34;},\u0026#34;/\u0026#34;,{\u0026#34;Ref\u0026#34;:\u0026#34;EndpointDeploymentStageprodB78BEEA0\u0026#34;},\u0026#34;/\u0026#34;]]}} 追加したコードにより、10個の新しいリソースがスタックに追加されることがわかります。\ncdk deploy デプロイする準備が整いました。\ncdk deploy Stack outputs デプロイが完了すると、次の内容が出力されているはずです。\nCdkWorkshopStack.Endpoint8024A810 = https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ これは、API Gatewayコンストラクトによって自動的に追加されるstack outputであり、API GatewayエンドポイントのURLが含まれます。\nアプリをテストする。 次に、このエンドポイントを curl で叩いてみましょう。 URLをコピーして実行します。（プレフィックスとリージョンは異なる可能性があります）\ncurlをインストールしていない場合は、WebブラウザでこのURLにアクセスしてみてください。\ncurl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ 出力は次のようになります。\nHello, CDK! You\u0026#39;ve hit / Webブラウザでも確認できます。\nこの出力がされていれば、アプリは正常に動作しています。\n正常に動作していないとき API Gatewayから5xxエラーを受け取った場合、次の2つの問題のいずれかが該当しています。\nlambda関数が返した応答は、API Gatewayが期待するものと一致していません。 手順を戻って、Lambdaのhandler関数の返り値にstatusCode, body, header フィールドが含まれているか確認してください。 (参照: Lambdaのhandler関数のコード) 何らかの理由で関数が失敗しています。 Lambda関数をデバッグするには、このセクションで、Lambdaログをどのように表示するか学べます。 お疲れさまでした！ 次の章では再利用可能な独自のコンストラクトを作成します。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/20-create-project/400-synth.html","title":"cdk synth","tags":[],"description":"","content":"アプリからテンプレートを生成する AWS CDKアプリ自体はコードを使用したインフラストラクチャの 定義 にすぎません。 CDKアプリが実行されると、アプリケーションで定義された各スタックのAWS CloudFormationテンプレートが生成（CDKの用語では \u0026quot;synthesize\u0026quot; ）されます。\nCDKアプリを生成するには、 cdk synth コマンドを実行してください。 サンプルアプリから生成されたCloudFormationテンプレートを確認してみましょう。\nCDK CLI はcdk.jsonファイルが配置されているプロジェクトのルートディレクトリで実行する必要があります。 ディレクトリを移動している場合はプロジェクトのルートディレクトリに戻ってからCDKコマンドを実行してください。\ncdk synth 上記コマンドを実行すると、次のCloudFormationテンプレートを出力します。\nResources: CdkWorkshopQueue50D9D426: Type: AWS::SQS::Queue Properties: VisibilityTimeout: 300 UpdateReplacePolicy: Delete DeletionPolicy: Delete Metadata: aws:cdk:path: CdkWorkshopStack/CdkWorkshopQueue/Resource CdkWorkshopQueuePolicyAF2494A5: Type: AWS::SQS::QueuePolicy Properties: PolicyDocument: Statement: - Action: sqs:SendMessage Condition: ArnEquals: aws:SourceArn: Ref: CdkWorkshopTopicD368A42F Effect: Allow Principal: Service: sns.amazonaws.com Resource: Fn::GetAtt: - CdkWorkshopQueue50D9D426 - Arn Version: \u0026#34;2012-10-17\u0026#34; Queues: - Ref: CdkWorkshopQueue50D9D426 Metadata: aws:cdk:path: CdkWorkshopStack/CdkWorkshopQueue/Policy/Resource CdkWorkshopQueueCdkWorkshopStackCdkWorkshopTopicD7BE96438B5AD106: Type: AWS::SNS::Subscription Properties: Protocol: sqs TopicArn: Ref: CdkWorkshopTopicD368A42F Endpoint: Fn::GetAtt: - CdkWorkshopQueue50D9D426 - Arn Metadata: aws:cdk:path: CdkWorkshopStack/CdkWorkshopQueue/CdkWorkshopStackCdkWorkshopTopicD7BE9643/Resource CdkWorkshopTopicD368A42F: Type: AWS::SNS::Topic Metadata: aws:cdk:path: CdkWorkshopStack/CdkWorkshopTopic/Resource CDKMetadata: Type: AWS::CDK::Metadata Properties: Analytics: v2:deflate64:H4sIAAAAAAAA/1WNQQrCMBBFz9J9OhoFxXUvoK17aZMI09akZhJFQu5uk4DgZv7/jwezg/0JeNW/qRZyqmccIHSuFxNb0S3QkyBcvPKKNXddSr5nM6P4/GCZkZFe/c4PJCwuDo1Oxt++mgVFornEmGqryHgr8o/GaInJjEwbqWCkzYsfgB9hW42EWFuvHT4UtCW/VHqIZsEAAAA= Metadata: aws:cdk:path: CdkWorkshopStack/CDKMetadata/Default Condition: CDKMetadataAvailable Conditions: CDKMetadataAvailable: Fn::Or: - Fn::Or: - Fn::Equals: - Ref: AWS::Region - af-south-1 - Fn::Equals: - Ref: AWS::Region - ap-east-1 - Fn::Equals: - Ref: AWS::Region - ap-northeast-1 - Fn::Equals: - Ref: AWS::Region - ap-northeast-2 - Fn::Equals: - Ref: AWS::Region - ap-south-1 - Fn::Equals: - Ref: AWS::Region - ap-southeast-1 - Fn::Equals: - Ref: AWS::Region - ap-southeast-2 - Fn::Equals: - Ref: AWS::Region - ca-central-1 - Fn::Equals: - Ref: AWS::Region - cn-north-1 - Fn::Equals: - Ref: AWS::Region - cn-northwest-1 - Fn::Or: - Fn::Equals: - Ref: AWS::Region - eu-central-1 - Fn::Equals: - Ref: AWS::Region - eu-north-1 - Fn::Equals: - Ref: AWS::Region - eu-south-1 - Fn::Equals: - Ref: AWS::Region - eu-west-1 - Fn::Equals: - Ref: AWS::Region - eu-west-2 - Fn::Equals: - Ref: AWS::Region - eu-west-3 - Fn::Equals: - Ref: AWS::Region - me-south-1 - Fn::Equals: - Ref: AWS::Region - sa-east-1 - Fn::Equals: - Ref: AWS::Region - us-east-1 - Fn::Equals: - Ref: AWS::Region - us-east-2 - Fn::Or: - Fn::Equals: - Ref: AWS::Region - us-west-1 - Fn::Equals: - Ref: AWS::Region - us-west-2 Parameters: BootstrapVersion: Type: AWS::SSM::Parameter::Value\u0026lt;String\u0026gt; Default: /cdk-bootstrap/hnb659fds/version Description: Version of the CDK Bootstrap resources in this environment, automatically retrieved from SSM Parameter Store. [cdk:skip] Rules: CheckBootstrapVersion: Assertions: - Assert: Fn::Not: - Fn::Contains: - - \u0026#34;1\u0026#34; - \u0026#34;2\u0026#34; - \u0026#34;3\u0026#34; - \u0026#34;4\u0026#34; - \u0026#34;5\u0026#34; - Ref: BootstrapVersion AssertDescription: CDK bootstrap stack version 6 required. Please run \u0026#39;cdk bootstrap\u0026#39; with a recent version of the CDK CLI. ご覧のとおり、このテンプレートには4つのリソースが含まれています。\nAWS::SQS::Queue - キュー AWS::SNS::Topic - トピック AWS::SNS::Subscription - キューとトピックの間のサブスクリプション AWS::SQS::QueuePolicy - このトピックがメッセージをキューに送信できるようにするリソースポリシー AWS::CDK::Metadata リソースは、ツールキットによって自動的に各スタックに追加されます。 AWS CDKチームはこれを分析のために使用し、セキュリティ上の問題があるバージョンを特定できるようにします。 詳細については、AW​​S CDKユーザーガイドのVersion Reportingを参照してください。 このワークショップの残りの説明では、メタデータリソースに関する詳細は省略します。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/40-hit-counter/400-use.html","title":"HitCounterの使用","tags":[],"description":"","content":"スタックにHitCounterを追加する HitCounterの準備ができましたのでアプリに実装していきましょう。 lib/cdk-workshop-stack.tsを開き、次の強調表示されたコードを追加します。\nimport { Stack, StackProps } from \u0026#39;aws-cdk-lib\u0026#39;; import { LambdaRestApi } from \u0026#39;aws-cdk-lib/aws-apigateway\u0026#39;; import { Runtime } from \u0026#39;aws-cdk-lib/aws-lambda\u0026#39;; import { NodejsFunction } from \u0026#39;aws-cdk-lib/aws-lambda-nodejs\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; import { HitCounter } from \u0026#39;./hitcounter\u0026#39;; export class CdkWorkshopStack extends Stack { constructor(scope: Construct, id: string, props?: StackProps) { super(scope, id, props); // AWS Lambdaリソースを定義 const hello = new NodejsFunction(this, \u0026#39;HelloHandler\u0026#39;, { runtime: Runtime.NODEJS_16_X, entry: \u0026#39;lambda/hello.ts\u0026#39;, }); const helloWithCounter = new HitCounter(this, \u0026#39;HelloHitCounter\u0026#39;, { downstream: hello, }); // \u0026#34;hello\u0026#34; 関数をバックに持つAPI Gateway REST APIリソースを定義 new LambdaRestApi(this, \u0026#39;Endpoint\u0026#39;, { handler: helloWithCounter.handler, }); } } API GatewayのハンドラーをhelloからhelloWithCounter.handlerに変更しています。 これは、エンドポイントが実行されるたびに、API GatewayがHitCounterハンドラーにリクエストをルーティングし、 HitCounterハンドラーが実行されてログに記録し、hello関数に中継することを意味します。 レスポンスはユーザーに返されるまで逆順でリレーされます。\nデプロイ cdk deploy デプロイには少し時間がかかります。\n出力は次のとおりです。\nCdkWorkshopStack.Endpoint8024A810 = https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ デプロイが完了したら、次の章でテストをしましょう。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/20-create-project/500-deploy.html","title":"cdk deploy","tags":[],"description":"","content":"CloudFormationテンプレートが作成されました。次は何を行うでしょうか？ AWSへのデプロイをしましょう！\n環境の初期構築 AWS CDKアプリを環境（アカウント/リージョン）に初めてデプロイするときは、Bootstrapスタックを構築する必要があります。 このスタックには、ツールキットの操作に必要なリソースが含まれています。 たとえば、スタックにはデプロイプロセスで使われるCloudformationテンプレートとアセットを保存するために使用されるS3バケットが含まれます。\ncdk bootstrap コマンドを実行すれば、bootstrapスタックがAWS環境にデプロイされます。\ncdk bootstrap 実行すると以下のように表示されます。\n⏳ Bootstrapping environment aws://999999999999/us-east-1... ... アクセス拒否エラーとなるときはAWS CLIのクレデンシャル情報が正しく設定されているか、 現在のプロファイルが CloudFormationのcloudformation:CreateChangeSetを実行する権限を持っているか確認してください。\nデプロイしましょう！ cdk deploy コマンドを使用することで、CDKアプリをデプロイできます。\ncdk deploy 次のような警告が表示されるはずです。\nThis deployment will make potentially sensitive changes according to your current security approval level (--require-approval broadening). Please confirm you intend to make the following modifications: IAM Statement Changes ┌───┬─────────────────────────┬────────┬─────────────────┬───────────────────────────┬─────────────────────────────────────────────────────────┐ │ │ Resource │ Effect │ Action │ Principal │ Condition │ ├───┼─────────────────────────┼────────┼─────────────────┼───────────────────────────┼─────────────────────────────────────────────────────────┤ │ + │ ${CdkWorkshopQueue.Arn} │ Allow │ sqs:SendMessage │ Service:sns.amazonaws.com │ \u0026#34;ArnEquals\u0026#34;: { │ │ │ │ │ │ │ \u0026#34;aws:SourceArn\u0026#34;: \u0026#34;${CdkWorkshopTopic}\u0026#34; │ │ │ │ │ │ │ } │ └───┴─────────────────────────┴────────┴─────────────────┴───────────────────────────┴─────────────────────────────────────────────────────────┘ (NOTE: There may be security-related changes not in this list. See https://github.com/aws/aws-cdk/issues/1299) Do you wish to deploy these changes (y/n)? これは、アプリのデプロイにはリスクが伴うことを警告しています（具体的には、IAMに変更が入る場合などです）。 今回は、SNSトピックがメッセージをSQSキューに送信できるIAM権限が必要になるためです。 yを入力してスタックをデプロイし、リソースを作成します。\n出力は次のようになります。 ACCOUNT-IDはアカウントID、REGIONはアプリを作成したリージョン、STACK-IDはスタックを一意に特定する識別子です。\nCdkWorkshopStack: deploying... CdkWorkshopStack: creating CloudFormation changeset... ✅ CdkWorkshopStack ✨ Deployment time: 93.21s Stack ARN: arn:aws:cloudformation:REGION:ACCOUNT-ID:stack/CdkWorkshopStack/STACK-ID ✨ Total time: 107.65s CloudFormationコンソール CDKアプリケーションはAWS CloudFormationを介してデプロイされます。 各CDKスタックはCloudFormationスタックと1：1に対応します。\nそのため、AWS CloudFormationコンソールでスタックを管理できます。\nAWS CloudFormationコンソールを見てみましょう。\n次のようなものが表示されるはずです（表示されない場合、正しいリージョンにいるか確認してください）。\nCdkWorkshopStack を選択し、リソースタブを開けば、リソースの物理IDを確認できます。\nこれでコーディングの準備が整いました！ "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/40-hit-counter/700-test.html","title":"HitCounterのテスト","tags":[],"description":"","content":"テスト呼び出し いくつかのリクエストを実行して、HitCounterが機能するかどうかを確認しましょう。curlコマンド、またはWebブラウザから確認ができます。\ncurl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hello curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hello/world curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hello/world もし、5XXエラーとなる場合は、Lambdaのコンソール画面からHitCounterのログを確認してみてください。 問題点がある場合は問い合わせをお願いします。\nDynamoDBコンソールを開く DynamoDBコンソールに移動します。\nテーブルを作成したリージョンにいることを確認してください。手順どおりであれば東京リージョンにいることを確認しましょう。\nナビゲーションペインから「テーブル」を選択し、CdkWorkShopStack-HelloHitCounterHitsで始まるテーブルを選択してください。\nテーブルを開き、「テーブルアイテムの探索」を選択します。\n各パスで取得したヒット数を確認します。\n新しいパスでAPIを叩き、アイテムビューを更新してください。 hitsカウントが1の新しいアイテムが表示されます。\nGood job! HitCounterは便利だということがご理解いただけたと思います。 基本的に、誰でもAPI Gatewayのプロキシバックエンドとして機能するLambda関数にアタッチでき、このAPIのカウントを記録できます。\nHitCounterはTypeScriptクラスであるため、npmモジュールをパッケージ化して、 JavaScriptパッケージマネージャーであるnpmjs.orgに公開できます。 公開後は誰でもnpm install でインストールでき、CDKアプリに追加できます。\n現時点で用意しているハンズオンはコンテンツは以上です。おつかれさまでした。 cleanup sectionを参考に、リソースの削除を忘れないようにしましょう。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/categories.html","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/tags.html","title":"Tags","tags":[],"description":"","content":""}]