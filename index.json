[{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/","title":"AWS CDK Intro Workshop","tags":[],"description":"","content":"Welcome Developers! Hey there, and thanks for joining us! Hope you can\u0026rsquo;t wait to play with this new thing we call the \u0026ldquo;AWS Cloud Development Kit\u0026rdquo; or in short, the AWS CDK.\nThe AWS CDK is a new software development framework from AWS with the sole purpose of making it fun and easy to define cloud infrastructure in your favorite programming language and deploy it using AWS CloudFormation.\nSo what are we going to build? Nothing too fancy\u0026hellip;\nWe\u0026rsquo;ll spend some time setting up your development environment and learning a little about how to work with the CDK Toolkit to deploy your app to an AWS environment.\nThen, you\u0026rsquo;ll write a little \u0026ldquo;Hello, world\u0026rdquo; Lambda function and front it with an API Gateway endpoint so users can call it via an HTTP request.\nNext, we\u0026rsquo;ll introduce the powerful concept of CDK constructs. Constructs allow you to bundle up a bunch of infrastructure into reusable components which anyone can compose into their apps. We\u0026rsquo;ll walk you through writing your own construct.\nFinally, we\u0026rsquo;ll show you how to use a construct from a pre-packaged library in your stack.\nBy the end of this workshop, you\u0026rsquo;ll be able to:\nCreate new CDK applications. Define your app\u0026rsquo;s infrastructure using the AWS Construct Library Deploy your CDK apps to your AWS account Define your own reusable constructs Consume constructs published by other people You can also find a short guide on utilizing our Construct Hub at the end of this workshop. This will be a useful tool for all future endeavors with the CDKs.\nSee Also AWS CDK User Guide AWS CDK Reference "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/15-prerequisites.html","title":"Prerequisites","tags":[],"description":"","content":"Prerequisites for the Workshop To perform this workshop, you\u0026rsquo;ll need the following:\nAWS CLI AWS Account and User Node.js IDE for your programming language AWS CDK Toolkit Python .NET Java Node.js is always required to use CDK, but all other language prerequisites are only required if building a CDK app in that specific language\nYou can skip any of these steps if you have these tools already installed on your machine.\nClick on the arrow to the right to continue to the first step.\nSee Also Prerequisites in the AWS CDK User Guide "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/20-create-project.html","title":"New Project","tags":[],"description":"","content":"Creating your first CDK project In this chapter we will use cdk init to create a new AWS CDK Python project.\nWe will also learn how to use the CDK Toolkit to synthesize an AWS CloudFormation template for the starter app and how to deploy your app into your account.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/20-create-project.html","title":"New Project","tags":[],"description":"","content":"Creating your first CDK project In this chapter we will use cdk init to create a new AWS CDK .NET project.\nWe will also learn how to use the CDK Toolkit to synthesize an AWS CloudFormation template for the starter app and how to deploy your app into your account.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/20-create-project.html","title":"New Project","tags":[],"description":"","content":"Creating your first CDK project In this chapter we will use cdk init to create a new AWS CDK Java project.\nWe will also learn how to use the CDK Toolkit to synthesize an AWS CloudFormation template for the starter app and how to deploy your app into your account.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript.html","title":"TypeScript ワークショップ","tags":[],"description":"","content":"TypeScript ワークショップ 本項では、TypeScriptの入門編を体験できます。\nAWS利用料についての免責事項: このワークショップのいくつかのステップでは、請求が発生する可能性のあるリソースをあなたのアカウントに作成します。 このワークショップを最後まで実施しなくても、アカウントに課金が発生するAWSリソースが作られているかもしれません。 あなたのアカウントがクリーンであることを確認するには、TypeScriptワークショップの最後にある cleanup sectionのセクションを確認してください。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/20-create-project.html","title":"新しいプロジェクト","tags":[],"description":"","content":"CDKプロジェクトを作成する この章では、 cdk init コマンドを使用し、新しいAWS CDK TypeScriptプロジェクトを作成します。\nまた、CDK Toolkitを使用してスターターアプリ用のAWS CloudFormationテンプレートを生成する方法と、アプリをAWSにデプロイする方法についても学習します。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/30-hello-cdk.html","title":"Hello, CDK!","tags":[],"description":"","content":"Hello, CDK! この章では、CDKコードを書いていきます。 サンプルアプリにあるSNS / SQSの代わりに、API Gatewayのエンドポイントを持つLambda関数を追加します。\nエンドポイントの任意のパスにアクセスするとレスポンスを受け取ることができるようになります。\nはじめに、サンプルコードをクリーンアップしましょう。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/30-hello-cdk.html","title":"Hello, CDK!","tags":[],"description":"","content":"Hello, CDK! In this chapter, we will finally write some CDK code. Instead of the SNS/SQS code that we have in our app now, we\u0026rsquo;ll add a Lambda function with an API Gateway endpoint in front of it.\nUsers will be able to hit any URL in the endpoint and they\u0026rsquo;ll receive a heartwarming greeting from our function.\nFirst, let\u0026rsquo;s clean up the sample code.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/30-hello-cdk.html","title":"Hello, CDK!","tags":[],"description":"","content":"Hello, CDK! In this chapter, we will finally write some CDK code. Instead of the SNS/SQS code that we have in our app now, we\u0026rsquo;ll add a Lambda function with an API Gateway endpoint in front of it.\nUsers will be able to hit any URL in the endpoint and they\u0026rsquo;ll receive a heartwarming greeting from our function.\nFirst, let\u0026rsquo;s clean up the sample code.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/30-hello-cdk.html","title":"Hello, CDK!","tags":[],"description":"","content":"Hello, CDK! In this chapter, we will finally write some CDK code. Instead of the SNS/SQS code that we have in our app now, we\u0026rsquo;ll add a Lambda function with an API Gateway endpoint in front of it.\nUsers will be able to hit any URL in the endpoint and they\u0026rsquo;ll receive a heartwarming greeting from our function.\nFirst, let\u0026rsquo;s clean up the sample code.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python.html","title":"Python Workshop","tags":[],"description":"","content":"The Python Workshop This version of the workshop will guide you through a getting started experience in Python.\nA disclaimer about cost: Some of the steps in this workshop will create resources that may bill your account. If you do not complete the workshop, you may still have AWS resources that are unknowingly charging your account. To ensure your account is clean after starting this workshop, check out the cleanup section at the end of the Python Workshop.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet.html","title":".NET Workshop","tags":[],"description":"","content":"The .NET Workshop This version of the workshop will guide you through a \u0026ldquo;getting started\u0026rdquo; experience in C# using the .NET Core library.\nA disclaimer about cost: Some of the steps in this workshop will create resources that may bill your account. If you do not complete the workshop, you may still have AWS resources that are unknowingly charging your account. To ensure your account is clean after starting this workshop, check out the cleanup section at the end of the .NET Workshop.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/40-hit-counter.html","title":"Writing constructs","tags":[],"description":"","content":"Writing constructs In this chapter we will define a new construct called HitCounter. This construct can be attached to any Lambda function that\u0026rsquo;s used as an API Gateway backend, and it will count how many requests were issued to each URL path. It will store this in a DynamoDB table.\nSee Also Writing Constructs in the AWS CDK User Guide "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/40-hit-counter.html","title":"Writing constructs","tags":[],"description":"","content":"Writing constructs In this chapter we will define a new construct called HitCounter. This construct can be attached to any Lambda function that\u0026rsquo;s used as an API Gateway backend, and it will count how many requests were issued to each URL path. It will store this in a DynamoDB table.\nSee Also Writing Constructs in the AWS CDK User Guide "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/40-hit-counter.html","title":"Writing constructs","tags":[],"description":"","content":"Writing constructs In this chapter we will define a new construct called HitCounter. This construct can be attached to any Lambda function that\u0026rsquo;s used as an API Gateway backend, and it will count how many requests were issued to each URL path. It will store this in a DynamoDB table.\nSee Also Writing Constructs in the AWS CDK User Guide "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/40-hit-counter.html","title":"コンストラクトの作成","tags":[],"description":"","content":"コンストラクトの作成 この章では、HitCounterと呼ばれる新しいコンストラクトを定義します。 このコンストラクトは、API Gatewayバックエンドとして使用されるLambda関数にアタッチでき、 各URLのパスに発行されたリクエストの数をカウントします。 この結果をDynamoDBテーブルに保存します。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java.html","title":"Java Workshop","tags":[],"description":"","content":"The Java Workshop This version of the workshop will guide you through a \u0026ldquo;getting started\u0026rdquo; experience in Java.\nA disclaimer about cost: Some of the steps in this workshop will create resources that may bill your account. If you do not complete the workshop, you may still have AWS resources that are unknowingly charging your account. To ensure your account is clean after starting this workshop, check out the cleanup section at the end of the Java Workshop.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/50-table-viewer.html","title":"Using construct libraries","tags":[],"description":"","content":"Using construct libraries In this chapter we will import a construct library called cdk-dynamo-table-viewer into our project and install it on our hit counter table.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/50-table-viewer.html","title":"Using construct libraries","tags":[],"description":"","content":"Using construct libraries In this chapter we will import a construct library called cdk-dynamo-table-viewer into our project and install it on our hit counter table.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/50-table-viewer.html","title":"Using construct libraries","tags":[],"description":"","content":"Using construct libraries In this chapter we will import a construct library called DynamoTableViewer into our project and install it on our hit counter table.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/50-table-viewer.html","title":"Using construct libraries","tags":[],"description":"","content":"Using construct libraries In this chapter we will import a construct library called cdk-dynamo-table-view into our project and install it on our hit counter table.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/60-cleanups.html","title":"Clean up","tags":[],"description":"","content":"スタックのクリーンアップ スタックを破棄するとき、リソースはその削除ポリシーに従って「削除」、「保持」、「スナップショット」のいずれかで処理されます。 デフォルトでは、ほとんどのリソースはスタック削除時に削除されますが、すべてのリソースがそうなるわけではありません。 DynamoDBのテーブルは、デフォルトで保持されます。このテーブルを保持したくない場合は、CDKのコードで RemovalPolicy を使って設定ができます。\nスタック削除時に削除するDynamoDBテーブルを設定する hitcounter.ts を編集して、テーブルに removalPolicy プロパティを追加します。\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import * as lambda from \u0026#39;aws-cdk-lib/aws-lambda\u0026#39;; import * as dynamodb from \u0026#39;aws-cdk-lib/aws-dynamodb\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; export interface HitCounterProps { /** the function for which we want to count url hits **/ downstream: lambda.IFunction; } export class HitCounter extends Construct { /** allows accessing the counter function */ public readonly handler: lambda.Function; /** the hit counter table */ public readonly table: dynamodb.Table; constructor(scope: Construct, id: string, props: HitCounterProps) { super(scope, id); const table = new dynamodb.Table(this, \u0026#34;Hits\u0026#34;, { partitionKey: { name: \u0026#34;path\u0026#34;, type: dynamodb.AttributeType.STRING }, removalPolicy: cdk.RemovalPolicy.DESTROY }); this.table = table; this.handler = new lambda.Function(this, \u0026#39;HitCounterHandler\u0026#39;, { runtime: lambda.Runtime.NODEJS_14_X, handler: \u0026#39;hitcounter.handler\u0026#39;, code: lambda.Code.fromAsset(\u0026#39;lambda\u0026#39;), environment: { DOWNSTREAM_FUNCTION_NAME: props.downstream.functionName, HITS_TABLE_NAME: table.tableName } }); // grant the lambda role read/write permissions to our table table.grantReadWriteData(this.handler); // grant the lambda role invoke permissions to the downstream function props.downstream.grantInvoke(this.handler); } } さらに、作成されたLambda関数は、永久に保持されるCloudWatchのログを生成します。 これらはスタックの一部ではないので、CloudFormationでは追跡されず、ログは削除されずに残ります。 CloudWatchのログを削除する場合は、コンソールでこれらを手動で削除する必要があります。\nどのリソースが削除されるかがわかったので、スタックの削除を進めましょう。 CloudFormationのコンソールからスタックを削除するか、cdk destroyを使用するかのどちらかです。\ncdk destroy 以下のように聞かれるはずです。\nAre you sure you want to delete: CdkWorkshopStack (y/n)? yを押すと、スタックが削除されていく進捗が表示されます。\ncdk bootstrap によって作成されたブートストラップスタックは削除されません。 将来的にCDKを使う予定がある場合は、このスタックを削除しないでください。\ncdk bootstrap によって作成されたスタックを削除したい場合は、CloudFormationコンソールから行う必要があります。 CloudFormationコンソールからCDKToolkitスタックを削除してください。 作成されたS3バケットは、デフォルトで保持されます。 予期せぬ課金を避けたい場合はS3コンソールから、ブートストラップで生成されたバケットを空にして、削除しておいてください。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/60-cleanups.html","title":"Clean up","tags":[],"description":"","content":"Clean up your stack When destroying a stack, resources may be deleted, retained, or snapshotted according to their deletion policy. By default, most resources will get deleted upon stack deletion, however that\u0026rsquo;s not the case for all resources. The DynamoDB table will be retained by default. If you don\u0026rsquo;t want to retain this table, we can set this in CDK code by using RemovalPolicy:\nSet the DynamoDB table to be deleted upon stack deletion Edit hitcounter.py and add the removalPolicy prop to the table\nfrom constructs import Construct from aws_cdk import ( aws_lambda as _lambda, aws_dynamodb as ddb, RemovalPolicy ) class HitCounter(Construct): @property def handler(self): return self._handler @property def table(self): return self._table def __init__(self, scope: Construct, id: str, downstream: _lambda.IFunction, **kwargs): super().__init__(scope, id, **kwargs) self._table = ddb.Table( self, \u0026#39;Hits\u0026#39;, partition_key={\u0026#39;name\u0026#39;: \u0026#39;path\u0026#39;, \u0026#39;type\u0026#39;: ddb.AttributeType.STRING}, removal_policy=RemovalPolicy.DESTROY ) self._handler = _lambda.Function( self, \u0026#39;HitCountHandler\u0026#39;, runtime=_lambda.Runtime.PYTHON_3_7, handler=\u0026#39;hitcount.handler\u0026#39;, code=_lambda.Code.from_asset(\u0026#39;lambda\u0026#39;), environment={ \u0026#39;DOWNSTREAM_FUNCTION_NAME\u0026#39;: downstream.function_name, \u0026#39;HITS_TABLE_NAME\u0026#39;: self._table.table_name, } ) self._table.grant_read_write_data(self.handler) downstream.grant_invoke(self.handler) Additionally, the Lambda function created will generate CloudWatch logs that are permanently retained. These will not be tracked by CloudFormation since they are not part of the stack, so the logs will still persist. You will have to manually delete these in the console if desired.\nNow that we know which resources will be deleted, we can proceed with deleting the stack. You can either delete the stack through the AWS CloudFormation console or use cdk destroy:\ncdk destroy You\u0026rsquo;ll be asked:\nAre you sure you want to delete: CdkWorkshopStack (y/n)? Hit \u0026ldquo;y\u0026rdquo; and you\u0026rsquo;ll see your stack being destroyed.\nThe bootstrapping stack created through cdk bootstrap still exists. If you plan on using the CDK in the future (we hope you do!) do not delete this stack.\nIf you would like to delete this stack, it will have to be done through the CloudFormation console. Head over to the CloudFormation console and delete the CDKToolkit stack. The S3 bucket created will be retained by default, so if you want to avoid any unexpected charges, be sure to head to the S3 console and empty + delete the bucket generated from bootstrapping.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/60-cleanups.html","title":"Clean up","tags":[],"description":"","content":"Clean up your stack When destroying a stack, resources may be deleted, retained, or snapshotted according to their deletion policy. By default, most resources will get deleted upon stack deletion, however that\u0026rsquo;s not the case for all resources. The DynamoDB table will be retained by default. If you don\u0026rsquo;t want to retain this table, we can set this in CDK code by using RemovalPolicy:\nSet the DynamoDB table to be deleted upon stack deletion Edit src/CdkWorkshop/HitCounter.cs and add the RemovalPolicy prop to the table\nusing Amazon.CDK; using Amazon.CDK.AWS.DynamoDB; using Amazon.CDK.AWS.Lambda; using Constructs; using System.Collections.Generic; namespace CdkWorkshop { public class HitCounterProps { // The function for which we want to count url hits public IFunction Downstream { get; set; } } public class HitCounter : Construct { public readonly Function Handler; public readonly Table MyTable; public HitCounter(Construct scope, string id, HitCounterProps props) : base(scope, id) { var table = new Table(this, \u0026#34;Hits\u0026#34;, new TableProps { PartitionKey = new Attribute { Name = \u0026#34;path\u0026#34;, Type = AttributeType.STRING }, RemovalPolicy = RemovalPolicy.DESTROY }); MyTable = table; Handler = new Function(this, \u0026#34;HitCounterHandler\u0026#34;, new FunctionProps { Runtime = Runtime.NODEJS_14_X, Handler = \u0026#34;hitcounter.handler\u0026#34;, Code = Code.FromAsset(\u0026#34;lambda\u0026#34;), Environment = new Dictionary\u0026lt;string, string\u0026gt; { [\u0026#34;DOWNSTREAM_FUNCTION_NAME\u0026#34;] = props.Downstream.FunctionName, [\u0026#34;HITS_TABLE_NAME\u0026#34;] = table.TableName } }); // Grant the lambda role read/write permissions to our table table.GrantReadWriteData(Handler); // Grant the lambda role invoke permissions to the downstream function props.Downstream.GrantInvoke(Handler); } } } Additionally, the Lambda function created will generate CloudWatch logs that are permanently retained. These will not be tracked by CloudFormation since they are not part of the stack, so the logs will still persist. You will have to manually delete these in the console if desired.\nNow that we know which resources will be deleted, we can proceed with deleting the stack. You can either delete the stack through the AWS CloudFormation console or use cdk destroy:\ncdk destroy You\u0026rsquo;ll be asked:\nAre you sure you want to delete: CdkWorkshopStack (y/n)? Hit \u0026ldquo;y\u0026rdquo; and you\u0026rsquo;ll see your stack being destroyed.\nThe bootstrapping stack created through cdk bootstrap still exists. If you plan on using the CDK in the future (we hope you do!) do not delete this stack.\nIf you would like to delete this stack, it will have to be done through the CloudFormation console. Head over to the CloudFormation console and delete the CDKToolkit stack. The S3 bucket created will be retained by default, so if you want to avoid any unexpected charges, be sure to head to the S3 console and empty + delete the bucket generated from bootstrapping.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/60-cleanups.html","title":"Clean up","tags":[],"description":"","content":"Clean up your stack When destroying a stack, resources may be deleted, retained, or snapshotted according to their deletion policy. By default, most resources will get deleted upon stack deletion, however that\u0026rsquo;s not the case for all resources. The DynamoDB table will be retained by default. If you don\u0026rsquo;t want to retain this table, we can set this in CDK code by using RemovalPolicy:\nSet the DynamoDB table to be deleted upon stack deletion Edit src/CdkWorkshop/HitCounter.java and add the removalPolicy prop to the table\npackage com.myorg; import java.util.HashMap; import java.util.Map; import software.constructs.Construct; import software.amazon.awscdk.RemovalPolicy; import software.amazon.awscdk.services.dynamodb.Attribute; import software.amazon.awscdk.services.dynamodb.AttributeType; import software.amazon.awscdk.services.dynamodb.Table; import software.amazon.awscdk.services.lambda.Code; import software.amazon.awscdk.services.lambda.Function; import software.amazon.awscdk.services.lambda.Runtime; public class HitCounter extends Construct { private final Function handler; private final Table table; public HitCounter(final Construct scope, final String id, final HitCounterProps props) { super(scope, id); this.table = Table.Builder.create(this, \u0026#34;Hits\u0026#34;) .partitionKey(Attribute.builder() .name(\u0026#34;path\u0026#34;) .type(AttributeType.STRING) .build()) .removalPolicy(RemovalPolicy.DESTROY) .build(); final Map\u0026lt;String, String\u0026gt; environment = new HashMap\u0026lt;\u0026gt;(); environment.put(\u0026#34;DOWNSTREAM_FUNCTION_NAME\u0026#34;, props.getDownstream().getFunctionName()); environment.put(\u0026#34;HITS_TABLE_NAME\u0026#34;, this.table.getTableName()); this.handler = Function.Builder.create(this, \u0026#34;HitCounterHandler\u0026#34;) .runtime(Runtime.NODEJS_14_X) .handler(\u0026#34;hitcounter.handler\u0026#34;) .code(Code.fromAsset(\u0026#34;lambda\u0026#34;)) .environment(environment) .build(); // Grants the lambda function read/write permissions to our table this.table.grantReadWriteData(this.handler); // Grants the lambda function invoke permissions to the downstream function props.getDownstream().grantInvoke(this.handler); } /** * @return the counter definition */ public Function getHandler() { return this.handler; } /** * @return the counter table */ public Table getTable() { return this.table; } } Additionally, the Lambda function created will generate CloudWatch logs that are permanently retained. These will not be tracked by CloudFormation since they are not part of the stack, so the logs will still persist. You will have to manually delete these in the console if desired.\nNow that we know which resources will be deleted, we can proceed with deleting the stack. You can either delete the stack through the AWS CloudFormation console or use cdk destroy:\ncdk destroy You\u0026rsquo;ll be asked:\nAre you sure you want to delete: CdkWorkshopStack (y/n)? Hit \u0026ldquo;y\u0026rdquo; and you\u0026rsquo;ll see your stack being destroyed.\nThe bootstrapping stack created through cdk bootstrap still exists. If you plan on using the CDK in the future (we hope you do!) do not delete this stack.\nIf you would like to delete this stack, it will have to be done through the CloudFormation console. Head over to the CloudFormation console and delete the CDKToolkit stack. The S3 bucket created will be retained by default, so if you want to avoid any unexpected charges, be sure to head to the S3 console and empty + delete the bucket generated from bootstrapping.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/60-construct-hub.html","title":"Construct Hub","tags":[],"description":"","content":"The Construct Hub The Construct Hub is a one-stop destination for finding, reusing and sharing constructs authored by AWS, AWS Partner Network partners, third parties, and the developer community. The site currently lists constructs for our supported programming languages Typescript, Java, Python, and .NET (with listings for Go coming soon). CDK constructs are cloud architecture building blocks and patterns that you can use to stand up complete production-ready cloud applications. The constructs listed in the Construct Hub are authored using the AWS Cloud Development Kit (AWS CDK), CDK for Kubernetes (CDK8s) and CDK for Terraform (CDKtf). Please see the individual product sites/repositories for more in-depth information on each of these CDK libraries.\nWe define constructs as classes, which define a “piece of system state”. Constructs can be composed together to form higher-level building blocks which represent more complex state. AWS, enterprises, start-ups, and individual developers use CDK constructs to share proven architecture patterns as reusable code libraries, so that everyone can benefit from the collective wisdom of the community.\nIn addition to AWS\u0026rsquo; cloud service offerings, you can find hundreds of integrations with cloud service providers and utilities, products and technologies like: Twitter, Slack. Grafana, Prometheus, Next.js, Gitlab and more.\nThe Construct Hub is the central location where CDK users can find a comprehensive collection of constructs to help them build their applications. The Construct Hub makes it easier for developers to find the high-level building blocks they need to build their applications by listing publicly released construct libraries.\nDiscovering and Using Constructs Browse to https://constructs.dev and search for constructs based on keywords such as names of AWS services used (e.g., “eks”, “dynamodb”), the library’s author (e.g., “pahud”), or the CDK type (e.g., “cdktf”, “cdk8s”). Examples of constructs you can find include datadog-cdk-constructs that instruments Python and Node.js Lambda functions with Datadog, cdk-gitlab-runner that creates a GitLab Runner and executes a pipeline job, cdk-k3s-cluster that deploys a K3s cluster, and many more. The Construct Hub website also includes links to Getting Started resources. Below is an example of search results for constructs that include the “bucket” keyword and support the Python programming language:\nConstruct libraries listed on the Construct Hub include a detail page with instructions on how to install the package (click “Use Construct”) and an API reference that describes all the classes, interfaces, enums and data types in this library. The API reference and code samples are displayed in the selected programming language and are automatically generated from type information produced by the jsii compiler (jsii is a TypeScript-based programming language for creating multi-language libraries).\nListing Constructs on the Hub In order for your construct to be listed on the Construct Hub, you need to make sure it is authored with the following criteria:\nPublished to the npmjs.com registry Uses one of the following licenses: Apache, BSD, EPL, MPL-2.0, ISC and CDDL or MIT Annotated with one of the supported keywords (awscdk, cdk8s or cdktf) Compiled with jsii As a construct library publisher, you can improve the presentation of your construct library on the Construct Hub by:\nAdding links to the construct source code and documentation Including a README file with usage instructions Adding relevant keywords that will be displayed on the package page and can be used for search Each package is owned by its publisher, so contributions, such as bug reports and pull requests, should be made via the repository link provided by the publisher. You may press the ‘Provide feedback’ link at the package page to open a new issue in at the package’s repository.\nFor additional information and to submit your own construct, please see our contributing page\nInternal Use If you are interested in using an instance of the Construct Hub for internal purposes, we are developing a library to allow anyone to deploy their own instance. This library is currently in active development and should be considered experimental. We would appreciate any feedback or assistance you can give on that repo!\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/70-advanced-topics.html","title":"Advanced Topics","tags":[],"description":"","content":"Advanced Topics In this chapter we will explore some advanced topics in the CDK that are not required in order to complete the workshop.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/70-advanced-topics.html","title":"Advanced Topics","tags":[],"description":"","content":"Advanced Topics In this chapter we will explore some advanced topics in the CDK that are not required in order to complete the workshop.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/70-advanced-topics.html","title":"Advanced Topics","tags":[],"description":"","content":"Advanced Topics In this chapter we will explore some advanced topics in the CDK that are not required in order to complete the workshop.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/70-advanced-topics.html","title":"Advanced Topics","tags":[],"description":"","content":"Advanced Topics In this chapter we will explore some advanced topics in the CDK that are not required in order to complete the workshop.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/70-conclusion.html","title":"Congrats!","tags":[],"description":"","content":"Congratulations! You\u0026rsquo;ve successfully finished our Introduction to the CDK workshop!\nIn this workshop, you\u0026rsquo;ve learned how to:\nCreate a new CDK project in TypeScript using cdk init Add resources to your CDK application stack Use cdk diff and cdk deploy to deploy your app to an AWS environment Author and use your own custom construct (HitCounter) Consume a construct from another npm module (cdk-dynamo-table-viewer) Use the AWS Lambda, API Gateway and DynamoDB AWS construct libraries What\u0026rsquo;s next? The AWS CDK is a work in progress. It is currently in Developer Preview. We\u0026rsquo;d love to hear what you think about every aspect of the framework.\nHere are a few things you can do from here:\nBuild something: build something real with the CDK and let us know how it went. What worked? What was intuitive? What was completely misleading? Publish construct libraries: start thinking about infrastructure in terms of small reusable modules instead of monolithic templates. Pick up a useful thing you\u0026rsquo;ve built and try to design a beautiful API for it. Share it with the community and let us know about it. We\u0026rsquo;ll be curating a list of constructs, and would love to list yours. Create a simple app in the Hello World Tutorial with the CDK in one of the supported languages: Java, .NET, JavaScript and TypeScript Dive deeper into CDK Concepts: Constructs, Apps and Stacks, Logical IDs, Environments, Contexts, and Assets Explore the AWS Construct Library and the reference documentation which already contains constructs for many AWS resources such as EC2, AutoScaling, S3, SNS, SQS, CodePipeline, Step Functions and many more\u0026hellip; Read guidelines on how to write your own constructs Learn about jsii, the technology behind the CDK\u0026rsquo;s multi-language support Browse some examples on our GitHub repository Join the conversation on our Gitter channel Ask questions on Stack Overflow Raise an issue on GitHub Learn how to submit contributions to the project. "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/15-prerequisites/100-awscli.html","title":"AWS CLI","tags":[],"description":"","content":"The AWS CLI allows you to interact with AWS services from a terminal session. Make sure you have the latest version of the AWS CLI installed on your system.\nWindows: MSI installer Linux, macOS or Unix: Bundled installer See the AWS Command Line Interface installation page for more details.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/20-create-project/100-cdk-init.html","title":"cdk init","tags":[],"description":"","content":"プロジェクトディレクトリを作成する 空のディレクトリを作成します。\nmkdir cdk-workshop \u0026amp;\u0026amp; cd cdk-workshop cdk init cdk initコマンドを実行して、TypeScript製の新しいCDKプロジェクトを作成します。\ncdk init sample-app --language typescript 出力は次のようになります。\n# Welcome to your CDK TypeScript project You should explore the contents of this project. It demonstrates a CDK app with an instance of a stack (`CdkWorkshopStack`) which contains an Amazon SQS queue that is subscribed to an Amazon SNS topic. The `cdk.json` file tells the CDK Toolkit how to execute your app. ## Useful commands * `npm run build` compile typescript to js * `npm run watch` watch for changes and compile * `npm run test` perform the jest unit tests * `cdk deploy` deploy this stack to your default AWS account/region * `cdk diff` compare deployed stack with current state * `cdk synth` emits the synthesized CloudFormation template Initializing a new git repository... Executing npm install... ✅ All done! 上記出力にあるとおり、CDKを開始するための便利なコマンドがたくさんあります。\nSee Also AWS CDK Command Line Toolkit (cdk) in the AWS CDK User Guide "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/20-create-project/100-cdk-init.html","title":"cdk init","tags":[],"description":"","content":"Create project directory Create an empty directory on your system:\nmkdir cdk_workshop \u0026amp;\u0026amp; cd cdk_workshop cdk init We will use cdk init to create a new Python CDK project:\ncdk init sample-app --language python Output should look like this (you can safely ignore warnings about initialization of a git repository, this probably means you don\u0026rsquo;t have git installed, which is fine for this workshop):\nApplying project template sample-app for python Initializing a new git repository... Executing Creating virtualenv... # Welcome to your CDK Python project! You should explore the contents of this project. It demonstrates a CDK app with an instance of a stack (`CdkWorkshopStack`) which contains an Amazon SQS queue that is subscribed to an Amazon SNS topic. The `cdk.json` file tells the CDK Toolkit how to execute your app. This project is set up like a standard Python project. The initialization process also creates a virtualenv within this project, stored under the .venv directory. To create the virtualenv it assumes that there is a `python3` executable in your path with access to the `venv` package. If for any reason the automatic creation of the virtualenv fails, you can create the virtualenv manually once the init process completes. To manually create a virtualenv on MacOS and Linux: ``` $ python3 -m venv .venv ``` After the init process completes and the virtualenv is created, you can use the following step to activate your virtualenv. ``` $ source .venv/bin/activate ``` If you are a Windows platform, you would activate the virtualenv like this: ``` % .venv\\Scripts\\activate.bat ``` Once the virtualenv is activated, you can install the required dependencies. ``` $ pip install -r requirements.txt ``` At this point you can now synthesize the CloudFormation template for this code. ``` $ cdk synth ``` You can now begin exploring the source code, contained in the cdk_workshop directory. There is also a very trivial test included that can be run like this: ``` $ pytest ``` To add additional dependencies, for example other CDK libraries, just add to your requirements.txt file and rerun the `pip install -r requirements.txt` command. ## Useful commands * `cdk ls` list all stacks in the app * `cdk synth` emits the synthesized CloudFormation template * `cdk deploy` deploy this stack to your default AWS account/region * `cdk diff` compare deployed stack with current state * `cdk docs` open CDK documentation Enjoy! As you can see, it shows us a bunch of useful commands to get us started.\nSee Also AWS CDK Command Line Toolkit (cdk) in the AWS CDK User Guide "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/20-create-project/100-cdk-init.html","title":"cdk init","tags":[],"description":"","content":"Create project directory Create an empty directory on your system:\nmkdir cdk-workshop \u0026amp;\u0026amp; cd cdk-workshop cdk init We will use cdk init to create a new C# CDK project:\ncdk init sample-app --language csharp Output should look like this (you can safely ignore warnings about initialization of a git repository, this probably means you don\u0026rsquo;t have git installed, which is fine for this workshop):\nApplying project template sample-app for csharp Project \u0026#39;CdkWorkshop/CdkWorkshop.csproj\u0026#39; ajouté à la solution. Initializing a new git repository... # Welcome to your CDK C# project! You should explore the contents of this project. It demonstrates a CDK app with an instance of a stack (`CdkWorkshopStack`) which contains an Amazon SNS topic that is subscribed to an Amazon SQS queue. The `cdk.json` file tells the CDK Toolkit how to execute your app. It uses the [.NET Core CLI](https://docs.microsoft.com/dotnet/articles/core/) to compile and execute your project. ## Useful commands * `dotnet build src` compile this app * `cdk ls` list all stacks in the app * `cdk synth` emits the synthesized CloudFormation template * `cdk deploy` deploy this stack to your default AWS account/region * `cdk diff` compare deployed stack with current state * `cdk docs` open CDK documentation Enjoy! As you can see, it shows us a bunch of useful commands to get us started.\nSee Also AWS CDK Command Line Toolkit (cdk) in the AWS CDK User Guide "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/20-create-project/100-cdk-init.html","title":"cdk init","tags":[],"description":"","content":"Create project directory Create an empty directory on your system:\nmkdir cdk-workshop \u0026amp;\u0026amp; cd cdk-workshop cdk init We will use cdk init to create a new Java CDK project:\ncdk init sample-app --language java Output should look like this (you can safely ignore warnings about initialization of a git repository, this probably means you don\u0026rsquo;t have git installed, which is fine for this workshop):\nApplying project template sample-app for java # Welcome to your CDK Java project! You should explore the contents of this project. It demonstrates a CDK app with an instance of a stack (`CdkWorkshopStack`) which contains an Amazon SNS topic that is subscribed to an Amazon SQS queue. The `cdk.json` file tells the CDK Toolkit how to execute your app. It is a [Maven](https://maven.apache.org/) based project, so you can open this project with any Maven compatible Java IDE to build and run tests. ## Tutorial See [this useful workshop](https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java.html) on working with the AWS CDK for Java projects. ## Useful commands * `mvn package` compile and run tests * `cdk ls` list all stacks in the app * `cdk synth` emits the synthesized CloudFormation template * `cdk deploy` deploy this stack to your default AWS account/region * `cdk diff` compare deployed stack with current state * `cdk docs` open CDK documentation Enjoy! Initializing a new git repository... Executing \u0026#39;mvn package\u0026#39; ✅ All done! As you can see, it shows us a bunch of useful commands to get us started.\nSee Also AWS CDK Command Line Toolkit (cdk) in the AWS CDK User Guide "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/70-advanced-topics/100-pipelines.html","title":"CDK Pipelines","tags":[],"description":"","content":"CDK Pipelines In this chapter we will create a Continuous Deployment (CD) pipeline for the app developed in previous chapters.\nCD is an important component to most web projects, but can be challenging to set up with all the moving parts required. The CDK Pipelines construct makes that process easy and streamlined from within your existing CDK infrastructure design.\nThese pipelines consist of \u0026ldquo;stages\u0026rdquo; that represent the phases of your deployment process from how the source code is managed, to how the fully built artifacts are deployed.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/70-advanced-topics/100-pipelines.html","title":"CDK Pipelines","tags":[],"description":"","content":"CDK Pipelines In this chapter we will create a Continuous Deployment (CD) pipeline for the app developed in previous chapters.\nCD is an important component to most web projects, but can be challenging to set up with all the moving parts required. The CDK Pipelines construct makes that process easy and streamlined from within your existing CDK infrastructure design.\nThese pipelines consist of \u0026ldquo;stages\u0026rdquo; that represent the phases of your deployment process from how the source code is managed, to how the fully built artifacts are deployed.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/30-hello-cdk/100-cleanup.html","title":"Cleanup sample","tags":[],"description":"","content":"Delete the sample code from your stack The project created by cdk init sample-app includes an SQS queue and queue policy, an SNS topic and subscription. We\u0026rsquo;re not going to use them in our project, so remove them from the CdkWorkshopStack constructor.\nOpen cdk_workshop/cdk_workshop_stack.py and clean it up. Eventually it should look like this:\nfrom constructs import Construct from aws_cdk import ( Stack, ) class CdkWorkshopStack(Stack): def __init__(self, scope: Construct, id: str, **kwargs) -\u0026gt; None: super().__init__(scope, id, **kwargs) # Nothing here! cdk diff Now that we modified our stack\u0026rsquo;s contents, we can ask the toolkit to show us the difference between our CDK app and what\u0026rsquo;s currently deployed. This is a safe way to check what will happen once we run cdk deploy and is always good practice:\ncdk diff Output should look like the following:\nStack cdk-workshop IAM Statement Changes ┌───┬─────────────────────────────────┬────────┬─────────────────┬───────────────────────────┬─────────────────────────────────────────────────────────────────┐ │ │ Resource │ Effect │ Action │ Principal │ Condition │ ├───┼─────────────────────────────────┼────────┼─────────────────┼───────────────────────────┼─────────────────────────────────────────────────────────────────┤ │ - │ ${CdkworkshopQueue18864164.Arn} │ Allow │ sqs:SendMessage │ Service:sns.amazonaws.com │ \u0026#34;ArnEquals\u0026#34;: { │ │ │ │ │ │ │ \u0026#34;aws:SourceArn\u0026#34;: \u0026#34;${CdkworkshopTopic58CFDD3D}\u0026#34; │ │ │ │ │ │ │ } │ └───┴─────────────────────────────────┴────────┴─────────────────┴───────────────────────────┴─────────────────────────────────────────────────────────────────┘ (NOTE: There may be security-related changes not in this list. See https://github.com/aws/aws-cdk/issues/1299) Resources [-] AWS::SQS::Queue CdkworkshopQueue18864164 destroy [-] AWS::SQS::QueuePolicy CdkworkshopQueuePolicy78D5BF45 destroy [-] AWS::SNS::Subscription CdkworkshopQueuecdkworkshopCdkworkshopTopic7642CC2FCF70B637 destroy [-] AWS::SNS::Topic CdkworkshopTopic58CFDD3D destroy As expected, all of our resources are going to be brutally destroyed.\ncdk deploy Run cdk deploy and proceed to the next section (no need to wait):\ncdk deploy You should see the resources being deleted.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/30-hello-cdk/100-cleanup.html","title":"Cleanup sample","tags":[],"description":"","content":"Delete the sample code from your stack The project created by cdk init sample-app includes an SQS queue, and an SNS topic. We\u0026rsquo;re not going to use them in our project, so remove them from the CdkWorkshopStack constructor.\nOpen src/CdkWorkshop/CdkWorkshopStack.cs and clean it up. Eventually it should look like this:\nusing Amazon.CDK; using Constructs; namespace CdkWorkshop { public class CdkWorkshopStack : Stack { public CdkWorkshopStack(Construct scope, string id, IStackProps props = null) : base(scope, id, props) { // Nothing here! } } } cdk diff Now that we modified our stack\u0026rsquo;s contents, we can ask the toolkit to show us the difference between our CDK app and what\u0026rsquo;s currently deployed. This is a safe way to check what will happen once we run cdk deploy and is always good practice:\ncdk diff Output should look like the following:\nIAM Statement Changes ┌───┬─────────────────────────────────┬────────┬─────────────────┬───────────────────────────┬──────────────────────────────────────────────────┐ │ │ Resource │ Effect │ Action │ Principal │ Condition │ ├───┼─────────────────────────────────┼────────┼─────────────────┼───────────────────────────┼──────────────────────────────────────────────────┤ │ - │ ${CdkWorkshopQueue50D9D426.Arn} │ Allow │ sqs:SendMessage │ Service:sns.amazonaws.com │ \u0026#34;ArnEquals\u0026#34;: { │ │ │ │ │ │ │ \u0026#34;aws:SourceArn\u0026#34;: \u0026#34;${CdkWorkshopTopicD368A42F}\u0026#34; │ │ │ │ │ │ │ } │ └───┴─────────────────────────────────┴────────┴─────────────────┴───────────────────────────┴──────────────────────────────────────────────────┘ (NOTE: There may be security-related changes not in this list. See http://bit.ly/cdk-2EhF7Np) Resources [-] AWS::SQS::Queue CdkWorkshopQueue50D9D426 destroy [-] AWS::SQS::QueuePolicy CdkWorkshopQueuePolicyAF2494A5 destroy [-] AWS::SNS::Topic CdkWorkshopTopicD368A42F destroy [-] AWS::SNS::Subscription CdkWorkshopTopicCdkWorkshopQueueSubscription88D211C7 destroy As expected, all of our resources are going to be brutally destroyed.\ncdk deploy Run cdk deploy and proceed to the next section (no need to wait):\ncdk deploy You should see the resources being deleted.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/30-hello-cdk/100-cleanup.html","title":"Cleanup sample","tags":[],"description":"","content":"Delete the sample code from your stack The project created by cdk init sample-app includes an SQS queue, and an SNS topic. We\u0026rsquo;re not going to use them in our project, so remove them from your the CdkWorkshopStack constructor.\nOpen ~/CdkWorkshopStack.java and clean it up. Eventually it should look like this:\npackage com.myorg; import software.constructs.Construct; import software.amazon.awscdk.Stack; import software.amazon.awscdk.StackProps; public class CdkWorkshopStack extends Stack { public CdkWorkshopStack(final Construct parent, final String id) { this(parent, id, null); } public CdkWorkshopStack(final Construct parent, final String id, final StackProps props) { super(parent, id, props); // Nothing here! } } Delete the test directory The test directory can be used to create tests for your project using the junit library. For the purposes of this workshop, do not need it, so delete the directory from root.\ncdk diff Now that we modified our stack\u0026rsquo;s contents, we can ask the toolkit to show us the difference between our CDK app and what\u0026rsquo;s currently deployed. This is a safe way to check what will happen once we run cdk deploy and is always good practice:\nmvn clean package cdk diff Output should look like the following:\nIAM Statement Changes ┌───┬─────────────────────────────────┬────────┬─────────────────┬───────────────────────────┬──────────────────────────────────────────────────┐ │ │ Resource │ Effect │ Action │ Principal │ Condition │ ├───┼─────────────────────────────────┼────────┼─────────────────┼───────────────────────────┼──────────────────────────────────────────────────┤ │ - │ ${CdkWorkshopQueue50D9D426.Arn} │ Allow │ sqs:SendMessage │ Service:sns.amazonaws.com │ \u0026#34;ArnEquals\u0026#34;: { │ │ │ │ │ │ │ \u0026#34;aws:SourceArn\u0026#34;: \u0026#34;${CdkWorkshopTopicD368A42F}\u0026#34; │ │ │ │ │ │ │ } │ └───┴─────────────────────────────────┴────────┴─────────────────┴───────────────────────────┴──────────────────────────────────────────────────┘ (NOTE: There may be security-related changes not in this list. See http://bit.ly/cdk-2EhF7Np) Resources [-] AWS::SQS::Queue CdkWorkshopQueue50D9D426 destroy [-] AWS::SQS::QueuePolicy CdkWorkshopQueuePolicyAF2494A5 destroy [-] AWS::SNS::Topic CdkWorkshopTopicD368A42F destroy [-] AWS::SNS::Subscription CdkWorkshopTopicCdkWorkshopQueueSubscription88D211C7 destroy As expected, all of our resources are going to be brutally destroyed.\ncdk deploy Run cdk deploy and proceed to the next section (no need to wait):\ncdk deploy You should see the resources being deleted.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/40-hit-counter/100-api.html","title":"Define the HitCounter API","tags":[],"description":"","content":"Create a new file for our hit counter construct Create a new file under cdk_workshop called hitcounter.py with the following content:\nfrom constructs import Construct from aws_cdk import ( aws_lambda as _lambda, ) class HitCounter(Construct): def __init__(self, scope: Construct, id: str, downstream: _lambda.IFunction, **kwargs): super().__init__(scope, id, **kwargs) # TODO Save the file.\nWhat\u0026rsquo;s going on here? We declared a new construct class called HitCounter. As usual, constructor arguments are scope, id and kwargs, and we propagate them to the cdk.Construct base class. The HitCounter class also takes one explicit keyword parameter downstream of type lambda.IFunction. This is where we are going to \u0026ldquo;plug in\u0026rdquo; the Lambda function we created in the previous chapter so it can be hit-counted. Next, are are going to write the handler code of our hit counter.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/40-hit-counter/100-api.html","title":"Define the HitCounter API","tags":[],"description":"","content":"Create a new file for our hit counter construct Create a new file under src/CdkWorkshop called HitCounter.cs with the following content:\nusing Amazon.CDK; using Amazon.CDK.AWS.Lambda; using Constructs; namespace CdkWorkshop { public class HitCounterProps { // The function for which we want to count url hits public IFunction Downstream { get; set; } } public class HitCounter : Construct { public HitCounter(Construct scope, string id, HitCounterProps props) : base(scope, id) { // TODO } } } Save the file.\nWhat\u0026rsquo;s going on here? We declared a new construct class called HitCounter. As usual, constructor arguments are scope, id and props, and we propagate them to the Construct base class. The props argument is of type HitCounterProps which includes a single property Downstream of type IFunction. This is where we are going to \u0026ldquo;plug in\u0026rdquo; the Lambda function we created in the previous chapter so it can be hit-counted. Next, we are going to write the handler code of our hit counter.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/40-hit-counter/100-api.html","title":"Define the HitCounter API","tags":[],"description":"","content":"Create a new file for our hit counter construct Create two new files under src/main/java/com/myorg called HitCounterProps.java with the following content:\npackage com.myorg; import software.amazon.awscdk.services.lambda.IFunction; public interface HitCounterProps { // Public constructor for the props builder public static Builder builder() { return new Builder(); } // The function for which we want to count url hits IFunction getDownstream(); // The builder for the props interface public static class Builder { private IFunction downstream; public Builder downstream(final IFunction function) { this.downstream = function; return this; } public HitCounterProps build() { if(this.downstream == null) { throw new NullPointerException(\u0026#34;The downstream property is required!\u0026#34;); } return new HitCounterProps() { @Override public IFunction getDownstream() { return downstream; } }; } } } AND HitCounter.java with this content:\npackage com.myorg; import software.constructs.Construct; public class HitCounter extends Construct { public HitCounter(final Construct scope, final String id, final HitCounterProps props) { super(scope, id); // TODO } } Save the files.\nWhat\u0026rsquo;s going on here? We declared a new construct class called HitCounter. As usual, constructor arguments are scope, id and props, and we propagate them to the Construct base class. The props argument is of type HitCounterProps which includes a single property getDownStream of type IFunction and a Builder to create the props. This is where we are going to \u0026ldquo;plug in\u0026rdquo; the Lambda function we created in the previous chapter so it can be hit-counted. Next, we are going to write the handler code of our hit counter.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/40-hit-counter/200-handler.html","title":"Hit counter handler","tags":[],"description":"","content":"Hit counter Lambda handler Okay, now let\u0026rsquo;s write the Lambda handler code for our hit counter.\nCreate the file lambda/hitcount.py:\nimport json import os import boto3 ddb = boto3.resource(\u0026#39;dynamodb\u0026#39;) table = ddb.Table(os.environ[\u0026#39;HITS_TABLE_NAME\u0026#39;]) _lambda = boto3.client(\u0026#39;lambda\u0026#39;) def handler(event, context): print(\u0026#39;request: {}\u0026#39;.format(json.dumps(event))) table.update_item( Key={\u0026#39;path\u0026#39;: event[\u0026#39;path\u0026#39;]}, UpdateExpression=\u0026#39;ADD hits :incr\u0026#39;, ExpressionAttributeValues={\u0026#39;:incr\u0026#39;: 1} ) resp = _lambda.invoke( FunctionName=os.environ[\u0026#39;DOWNSTREAM_FUNCTION_NAME\u0026#39;], Payload=json.dumps(event), ) body = resp[\u0026#39;Payload\u0026#39;].read() print(\u0026#39;downstream response: {}\u0026#39;.format(body)) return json.loads(body) Discovering resources at runtime You\u0026rsquo;ll notice that this code relies on two environment variables:\nHITS_TABLE_NAME is the name of the DynamoDB table to use for storage. DOWNSTREAM_FUNCTION_NAME is the name of the downstream AWS Lambda function. Since the actual name of the table and the downstream function will only be decided when we deploy our app, we need to wire up these values from our construct code. We\u0026rsquo;ll do that in the next section.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/40-hit-counter/200-handler.html","title":"Hit counter handler","tags":[],"description":"","content":"Hit counter Lambda handler Okay, now let\u0026rsquo;s write the Lambda handler code for our hit counter.\nCreate the file lambda/hitcounter.js:\nconst { DynamoDB, Lambda } = require(\u0026#39;aws-sdk\u0026#39;); exports.handler = async function(event) { console.log(\u0026#34;request:\u0026#34;, JSON.stringify(event, undefined, 2)); // create AWS SDK clients const dynamo = new DynamoDB(); const lambda = new Lambda(); // update dynamo entry for \u0026#34;path\u0026#34; with hits++ await dynamo.updateItem({ TableName: process.env.HITS_TABLE_NAME, Key: { path: { S: event.path } }, UpdateExpression: \u0026#39;ADD hits :incr\u0026#39;, ExpressionAttributeValues: { \u0026#39;:incr\u0026#39;: { N: \u0026#39;1\u0026#39; } } }).promise(); // call downstream function and capture response const resp = await lambda.invoke({ FunctionName: process.env.DOWNSTREAM_FUNCTION_NAME, Payload: JSON.stringify(event) }).promise(); console.log(\u0026#39;downstream response:\u0026#39;, JSON.stringify(resp, undefined, 2)); // return response back to upstream caller return JSON.parse(resp.Payload); }; Discovering resources at runtime You\u0026rsquo;ll notice that this code relies on two environment variables:\nHITS_TABLE_NAME is the name of the DynamoDB table to use for storage. DOWNSTREAM_FUNCTION_NAME is the name of the downstream AWS Lambda function. Since the actual name of the table and the downstream function will only be decided when we deploy our app, we need to wire up these values from our construct code. We\u0026rsquo;ll do that in the next section.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/40-hit-counter/200-handler.html","title":"Hit counter handler","tags":[],"description":"","content":"Hit counter Lambda handler Okay, now let\u0026rsquo;s write the Lambda handler code for our hit counter.\nCreate the file lambda/hitcounter.js:\nconst { DynamoDB, Lambda } = require(\u0026#39;aws-sdk\u0026#39;); exports.handler = async function(event) { console.log(\u0026#34;request:\u0026#34;, JSON.stringify(event, undefined, 2)); // create AWS SDK clients const dynamo = new DynamoDB(); const lambda = new Lambda(); // update dynamo entry for \u0026#34;path\u0026#34; with hits++ await dynamo.updateItem({ TableName: process.env.HITS_TABLE_NAME, Key: { path: { S: event.path } }, UpdateExpression: \u0026#39;ADD hits :incr\u0026#39;, ExpressionAttributeValues: { \u0026#39;:incr\u0026#39;: { N: \u0026#39;1\u0026#39; } } }).promise(); // call downstream function and capture response const resp = await lambda.invoke({ FunctionName: process.env.DOWNSTREAM_FUNCTION_NAME, Payload: JSON.stringify(event) }).promise(); console.log(\u0026#39;downstream response:\u0026#39;, JSON.stringify(resp, undefined, 2)); // return response back to upstream caller return JSON.parse(resp.Payload); }; Discovering resources at runtime You\u0026rsquo;ll notice that this code relies on two environment variables:\nHITS_TABLE_NAME is the name of the DynamoDB table to use for storage. DOWNSTREAM_FUNCTION_NAME is the name of the downstream AWS Lambda function. Since the actual name of the table and the downstream function will only be decided when we deploy our app, we need to wire up these values from our construct code. We\u0026rsquo;ll do that in the next section.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/40-hit-counter/100-api.html","title":"HitCounter APIの定義","tags":[],"description":"","content":"HitCounterコンストラクト用のファイルの作成 libフォルダ配下に次のようなhitcounter.tsファイルを作成します。\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import * as lambda from \u0026#39;aws-cdk-lib/aws-lambda\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; export interface HitCounterProps { /** the function for which we want to count url hits **/ downstream: lambda.IFunction; } export class HitCounter extends Construct { constructor(scope: Construct, id: string, props: HitCounterProps) { super(scope, id); // TODO } } ファイルを保存すると、エラーが発生しますが心配いりません。 この後すぐに props プロパティを追加します。\nコードの解説 HitCounterという名前のコンストラクトクラスを新しく定義しています。 今までどおり、scope, id, props のコンストラクター引数を設定し、基底クラスである cdk.Construct に伝搬させます。 propsは、lambda.IFunction型のdownstream というプロパティを含む、HitCounterProps型の引数です。 前の章で作成したLambda関数をここに接続して、HitCountが機能するようにします。 次に、HitCounterのハンドラーコードを記述します。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/40-hit-counter/200-handler.html","title":"HitCounterハンドラー","tags":[],"description":"","content":"HitCounter Lambda ハンドラー HitCounterのLambdaハンドラーコードを記述しましょう。\nlambda/hitcounter.jsを作成し、次のコードを追記してください。\nconst { DynamoDB, Lambda } = require(\u0026#39;aws-sdk\u0026#39;); exports.handler = async function(event) { console.log(\u0026#34;request:\u0026#34;, JSON.stringify(event, undefined, 2)); // create AWS SDK clients const dynamo = new DynamoDB(); const lambda = new Lambda(); // update dynamo entry for \u0026#34;path\u0026#34; with hits++ await dynamo.updateItem({ TableName: process.env.HITS_TABLE_NAME, Key: { path: { S: event.path } }, UpdateExpression: \u0026#39;ADD hits :incr\u0026#39;, ExpressionAttributeValues: { \u0026#39;:incr\u0026#39;: { N: \u0026#39;1\u0026#39; } } }).promise(); // call downstream function and capture response const resp = await lambda.invoke({ FunctionName: process.env.DOWNSTREAM_FUNCTION_NAME, Payload: JSON.stringify(event) }).promise(); console.log(\u0026#39;downstream response:\u0026#39;, JSON.stringify(resp, undefined, 2)); // return response back to upstream caller return JSON.parse(resp.Payload); }; 実行時のリソース検出 このコードは、次の2つの環境変数を参照していることがわかります。\nHITS_TABLE_NAME データストアとして使用するDynamoDBのテーブル名 DOWNSTREAM_FUNCTION_NAME ダウンストリームLambda関数 テーブルとダウンストリーム関数の名前はアプリをデプロイするときに決まるため、これらの値をコンストラクトコードから関連付ける必要があります。 次のセクションでそれを行います。\nLambda関数がさらに別のLambda関数を呼び出すようになっています。 呼び出される側のLambda関数をダウンストリームLambda関数、あるいは単にダウンストリーム関数とここでは呼んでいます。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/50-table-viewer/100-discovery.html","title":"Learning about the Table Viewer construct","tags":[],"description":"","content":"Reading documentation Browse to the cdk-dynamo-table-viewer page on npmjs.org and read the module documentation.\nAs mentioned in the README page of this library, it is not intended for production use. Namely because it will expose contents from your DynamoDB table to anyone without authentication.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/50-table-viewer/100-discovery.html","title":"Learning about the Table Viewer construct","tags":[],"description":"","content":"Reading documentation Browse to the cdk-dynamo-table-view page on pypi.org and read the module documentation.\nThere is some documentation about how to use the table viewer in the README but it is all focused on TypeScript rather than Python. So, we will walk through the process of using a third-party construct in Python.\nAs mentioned in the README page of this library, it is not intended for production use. Namely because it will expose contents from your DynamoDB table to anyone without authentication.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/50-table-viewer/100-discovery.html","title":"Learning about the Table Viewer construct","tags":[],"description":"","content":"Reading documentation Browse to the DynamoTableViewer page on github and read the module documentation.\nAs mentioned in the README page of this library, it is not intended for production use. Namely because it will expose contents from your DynamoDB table to anyone without authentication.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/50-table-viewer/100-discovery.html","title":"Learning about the Table Viewer construct","tags":[],"description":"","content":"Reading documentation Browse to the cdk-dynamo-table-viewer page on Github if you want to read the module documentation.\nAs mentioned in the README page of this library, it is not intended for production use. Namely because it will expose contents from your DynamoDB table to anyone without authentication.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/70-advanced-topics/100-construct-testing.html","title":"Testing Constructs","tags":[],"description":"","content":"Testing Constructs (Optional) The CDK Developer Guide has a good guide on testing constructs. For this section of the workshop we are going to use the Fine-Grained Assertions and Validation type tests.\nCDK assert Library We will be using the CDK assertions (aws-cdk-lib/assertions) library throughout this section. The library contains several helper functions for writing unit and integration tests.\nFor this workshop we will mostly be using the hasResourceProperties function. This helper is used when you only care that a resource of a particular type exists (regardless of its logical identfier), and that some properties are set to specific values.\nExample:\ntemplate.hasResourceProperties(\u0026#39;AWS::CertificateManager::Certificate\u0026#39;, { DomainName: \u0026#39;test.example.com\u0026#39;, ShouldNotExist: Match.absent(), // Note: some properties omitted here }); Match.absent() can be used to assert that a particular key in an object is not set (or set to undefined).\nTo see the rest of the documentation, please read the docs here.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/70-advanced-topics/100-construct-testing.html","title":"Testing Constructs","tags":[],"description":"","content":"Testing Constructs (Optional) The CDK Developer Guide has a good guide on testing constructs. For this section of the workshop we are going to use the Fine-Grained Assertions and Validation type tests.\nPrerequisites Install the required testing packages. $ pip install -r requirements-dev.txt CDK assert Library We will be using the CDK assertions (aws_cdk.assertions) library throughout this section. The library contains several helper functions for writing unit and integration tests.\nFor this workshop we will mostly be using the has_resource_properties function. This helper is used when you only care that a resource of a particular type exists (regardless of its logical identfier), and that some properties are set to specific values.\nExample:\ntemplate.has_resource_properties(\u0026#34;AWS::CertificateManager::Certificate\u0026#34;, { \u0026#34;DomainName\u0026#34;: \u0026#34;test.example.com\u0026#34;, \u0026#34;ShouldNotExist\u0026#34;: Match.absent(), }) Match.absent() can be used to assert that a particular key in an object is not set (or set to undefined).\nTo see the rest of the documentation, please read the docs here.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/70-advanced-topics/100-construct-testing.html","title":"Testing Constructs","tags":[],"description":"","content":"Testing Constructs (Optional) The CDK Developer Guide has a good guide on testing constructs. For this section of the workshop we are going to use the Fine-Grained Assertions and Validation type tests.\nPrerequisites Install the required testing packages. Edit the pom.xml to add the following deps\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34; xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;\u0026gt; \u0026lt;dependencies\u0026gt; ... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.assertj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;assertj-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.18.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; CDK assert Library We will be using the CDK assertions (software.amazon.awscdk.assertions) library throughout this section. The library contains several helper functions for writing unit and integration tests.\nFor this workshop we will mostly be using the hasResourceProperties function. This helper is used when you only care that a resource of a particular type exists (regardless of its logical identfier), and that some properties are set to specific values.\nExample:\nMap\u0026lt;String, Object\u0026gt; expected = Map.of( \u0026#34;DomainName\u0026#34;, \u0026#34;test.example.com\u0026#34;, ) template.hasResourceProperties(\u0026#34;AWS::CertificateManager::Certificate\u0026#34;, expected); To see the rest of the documentation, please read the docs here.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/30-hello-cdk/100-cleanup.html","title":"サンプルコードの削除","tags":[],"description":"","content":"スタックからサンプルコードを削除する cdk init sample-app によって作成されたプロジェクトには、SQSキューとSNSトピックが含まれます。 このプロジェクトではそれらを使用する予定はないので、 CdkWorkshopStack コンストラクタから削除しましょう。\nlib/cdk-workshop-stack.ts を開き、削除します。 最終的には次のようになります。\nimport { Stack, StackProps } from \u0026#39;aws-cdk-lib\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; export class CdkWorkshopStack extends Stack { constructor(scope: Construct, id: string, props?: StackProps) { super(scope, id, props); // nothing here! } } cdk diff これでスタックの中身を修正したことになります。 cdk diffを実行することで、スタックの修正によってどのような変更が発生するのかをツールキットで確認できます。 これは cdk deploy を実行したときに何が起こるかを確認する安全な方法であり、いつでも使える良いプラクティスです。\ncdk diff 出力は次のようになります。\nStack CdkWorkshopStack IAM Statement Changes ┌───┬─────────────────────────────────┬────────┬─────────────────┬───────────────────────────┬──────────────────────────────────────────────────┐ │ │ Resource │ Effect │ Action │ Principal │ Condition │ ├───┼─────────────────────────────────┼────────┼─────────────────┼───────────────────────────┼──────────────────────────────────────────────────┤ │ - │ ${CdkWorkshopQueue50D9D426.Arn} │ Allow │ sqs:SendMessage │ Service:sns.amazonaws.com │ \u0026#34;ArnEquals\u0026#34;: { │ │ │ │ │ │ │ \u0026#34;aws:SourceArn\u0026#34;: \u0026#34;${CdkWorkshopTopicD368A42F}\u0026#34; │ │ │ │ │ │ │ } │ └───┴─────────────────────────────────┴────────┴─────────────────┴───────────────────────────┴──────────────────────────────────────────────────┘ (NOTE: There may be security-related changes not in this list. See https://github.com/aws/aws-cdk/issues/1299) Resources [-] AWS::SQS::Queue CdkWorkshopQueue50D9D426 destroy [-] AWS::SQS::QueuePolicy CdkWorkshopQueuePolicyAF2494A5 destroy [-] AWS::SNS::Subscription CdkWorkshopQueueCdkWorkshopStackCdkWorkshopTopicD7BE96438B5AD106 destroy [-] AWS::SNS::Topic CdkWorkshopTopicD368A42F destroy 想定の通り、既存のリソースがすっかり削除されることになります。\ncdk deploy cdk deployを実行したら、次のセクションに進みます。\ncdk deploy リソースが削除されていくのが確認できます。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/70-advanced-topics/200-pipelines/1000-setting-up.html","title":"Getting Started with Pipelines","tags":[],"description":"","content":" Note: This segment of the workshop assumes you have completed the previous sections of the workshop. If you have not, and just want to follow this segment, or you are returning to try this workshop, you can use the code here that represents the last state of the project after adding the tests.\nCreate Pipeline Stack The first step is to create the stack that will contain our pipeline. Since this is separate from our actual \u0026ldquo;production\u0026rdquo; application, we want this to be entirely self-contained.\nCreate a new file under lib called lib/pipeline-stack.ts. Add the following to that file.\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; export class WorkshopPipelineStack extends cdk.Stack { constructor(scope: Construct, id: string, props?: cdk.StackProps) { super(scope, id, props); // Pipeline code goes here } } Look familiar? At this point, the pipeline is like any other CDK stack.\nUpdate CDK Deploy Entrypoint Next, since the purpose of our pipeline is to deploy our application stack, we no longer want the main CDK application to deploy our original app. Instead, we can change the entry point to deploy our pipeline, which will in turn deploy the application.\nTo do this, edit the code in bin/cdk-workshop.ts as follows:\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import { WorkshopPipelineStack } from \u0026#39;../lib/pipeline-stack\u0026#39;; const app = new cdk.App(); new WorkshopPipelineStack(app, \u0026#39;CdkWorkshopPipelineStack\u0026#39;); And now we\u0026rsquo;re ready!\nLets build a pipeline! "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/70-advanced-topics/200-pipelines/1000-setting-up.html","title":"Getting Started with Pipelines","tags":[],"description":"","content":" Note: This segment of the workshop assumes you have completed the previous sections of the workshop. If you have not, and just want to follow this segment, or you are returning to try this workshop, you can use the code here that represents the last state of the project after adding the tests.\nCreate Pipeline Stack The first step is to create the stack that will contain our pipeline. Since this is separate from our actual \u0026ldquo;production\u0026rdquo; application, we want this to be entirely self-contained.\nCreate a new file under cdk_workshop called pipeline_stack.py. Add the following to that file.\nfrom constructs import Construct from aws_cdk import ( Stack ) class WorkshopPipelineStack(Stack): def __init__(self, scope: Construct, id: str, **kwargs) -\u0026gt; None: super().__init__(scope, id, **kwargs) # Pipeline code will go here Look familiar? At this point, the pipeline is like any other CDK stack.\nUpdate CDK Deploy Entrypoint Next, since the purpose of our pipeline is to deploy our application stack, we no longer want the main CDK application to deploy our original app. Instead, we can change the entry point to deploy our pipeline, which will in turn deploy the application.\nTo do this, edit the code in app.py as follows:\n#!/usr/bin/env python3 import aws_cdk as cdk from cdk_workshop.pipeline_stack import WorkshopPipelineStack app = cdk.App() WorkshopPipelineStack(app, \u0026#34;WorkshopPipelineStack\u0026#34;) app.synth() This instructs the CDK to use those new features any time it synthesizes a stack (cdk synth).\nAnd now we\u0026rsquo;re ready!\nLets build a pipeline! "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/70-advanced-topics/100-pipelines/1000-setting-up.html","title":"Getting Started with Pipelines","tags":[],"description":"","content":" Note: This segment of the workshop assumes you have completed the previous sections of the workshop. If you have not, and just want to follow this segment, or you are returning to try this workshop, you can use the code here that represents the last state of the project after adding the tests.\nCreate Pipeline Stack The first step is to create the stack that will contain our pipeline. Since this is separate from our actual \u0026ldquo;production\u0026rdquo; application, we want this to be entirely self-contained.\nCreate a new file under src/CdkWorkshop called CdkWorkshop/PipelineStack.cs. Add the following to that file.\nusing Amazon.CDK; using Constructs; namespace CdkWorkshop { public class WorkshopPipelineStack : Stack { public WorkshopPipelineStack(Construct parent, string id, IStackProps props = null) : base(parent, id, props) { // Pipeline code goes here } } } Look familiar? At this point, the pipeline is like any other CDK stack.\nUpdate CDK Deploy Entrypoint Next, since the purpose of our pipeline is to deploy our application stack, we no longer want the main CDK application to deploy our original app. Instead, we can change the entry point to deploy our pipeline, which will in turn deploy the application.\nTo do this, edit the code in CdkWorkshop/Program.cs as follows:\nusing Amazon.CDK; namespace CdkWorkshop { class Program { static void Main(string[] args) { var app = new App(); new WorkshopPipelineStack(app, \u0026#34;WorkshopPipelineStack\u0026#34;); app.Synth(); } } } And now we\u0026rsquo;re ready!\nLets build a pipeline! "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/70-advanced-topics/100-pipelines/1000-setting-up.html","title":"Getting Started with Pipelines","tags":[],"description":"","content":" Note: This segment of the workshop assumes you have completed the previous sections of the workshop. If you have not, and just want to follow this segment, or you are returning to try this workshop, you can use the code here that represents the last state of the project after adding the tests.\nCreate Pipeline Stack The first step is to create the stack that will contain our pipeline. Since this is separate from our actual \u0026ldquo;production\u0026rdquo; application, we want this to be entirely self-contained.\nCreate a new file under src/main/java/com/myorg called WorkshopPipelineStack.java. Add the following to that file.\npackage com.myorg; import software.constructs.Construct; import software.amazon.awscdk.Stack; import software.amazon.awscdk.StackProps; public class WorkshopPipelineStack extends Stack { public WorkshopPipelineStack(final Construct parent, final String id) { this(parent, id, null); } public WorkshopPipelineStack(final Construct parent, final String id, final StackProps props) { super(parent, id, props); // Pipeline code goes here } } Look familiar? At this point, the pipeline is like any other CDK stack.\nUpdate CDK Deploy Entrypoint Next, since the purpose of our pipeline is to deploy our application stack, we no longer want the main CDK application to deploy our original app. Instead, we can change the entry point to deploy our pipeline, which will in turn deploy the application.\nTo do this, edit the code in src/main/java/com/myorg/CdkWorkshopApp.java as follows:\npackage com.myorg; import software.amazon.awscdk.App; public final class CdkWorkshopApp { public static void main(final String[] args) { App app = new App(); new WorkshopPipelineStack(app, \u0026#34;PipelineStack\u0026#34;); app.synth(); } } And now we\u0026rsquo;re ready!\nLets build a pipeline! "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/70-advanced-topics/200-pipelines/2000-create-repo.html","title":"Create Repository","tags":[],"description":"","content":"Create Repo in Pipeline Stack The first step in any good CD pipeline is source control. Here we will create a CodeCommit repository to contain our project code.\nEdit the file lib/pipeline-stack.ts as follows.\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import * as codecommit from \u0026#39;aws-cdk-lib/aws-codecommit\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; export class WorkshopPipelineStack extends cdk.Stack { constructor(scope: Construct, id: string, props?: cdk.StackProps) { super(scope, id, props); // Creates a CodeCommit repository called \u0026#39;WorkshopRepo\u0026#39; new codecommit.Repository(this, \u0026#39;WorkshopRepo\u0026#39;, { repositoryName: \u0026#34;WorkshopRepo\u0026#34; }); // Pipeline code goes here } } Deploy npx cdk deploy Get Repo Info and Commit Before we can do anything with our repo, we must add our code to it!\nGit Credentials Before we can do that, we will need Git credentials for the repo. To do this, go to the IAM Console, then navigate to Users and then your user of choice. Inside the manage user interface, navigate to the Security credentials tab and scroll until you see \u0026ldquo;HTTPS Git credentials for AWS CodeCommit\u0026rdquo;. Click generate credentials and follow the instructions on downloading those credentials. We will need them in a moment.\nAdd Git remote The last console step we will need here is to navigate to the CodeCommit Console and look for your repo. You will see a column called \u0026ldquo;Clone URL\u0026rdquo;; click \u0026ldquo;HTTPS\u0026rdquo; to copy the https link so we can add it to your local repo.\nNote: If you do not see your repo here, ensure you are in the interface for the correct region\nWhile you are here, feel free to explore your repo. You will see that it is still empty, but you do have access to the repo configuration information.\nIn your terminal, first make sure that all the changes you have made during the workshop are committed by issuing git status. If you have unstaged or uncommitted changes, you can execute git commit -am \u0026quot;SOME_COMMIT_MESSAGE_HERE\u0026quot;. This will stage and commit all your files so you are ready to go!\nNote: If you copied the code from the repo rather than following through the workshop from the beginning, first issue git init \u0026amp;\u0026amp; git add -A \u0026amp;\u0026amp; git commit -m \u0026quot;init\u0026quot;\nBy default, the CDK .gitignore file includes a reference to ignore all *.js files as those are typically generated by npm-ts. However, since we have lambda files written in js, those must not be ignored. Edit the .gitignore file, adding !lambda/*.js at the end of the file as shown below. This will instruct git to include all *.js files in the directory lambda/\n*.js !jest.config.js *.d.ts node_modules # CDK asset staging directory .cdk.staging cdk.out !lambda/*.js You will also need to commit the changes to your local git before we push the code to CodeCommit:\ngit add -A \u0026amp;\u0026amp; git commit -m \u0026#34;Updated .gitignore\u0026#34; Next, we add the remote repo to our Git config. You can do this with the command (XXXXX represents the Clone URL you copied from the console):\ngit remote add origin XXXXX Now all we need to do is to push our code to the repo (--set-upstream tells Git to override the current empty master branch on your repo):\ngit push --set-upstream origin master Here, CodeCommit will request the credentials you generated in the Git Credentials section. You will only have to provide them once.\nSee Result Now you can return to the CodeCommit console and see that your code is all there!\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/70-advanced-topics/200-pipelines/2000-create-repo.html","title":"Create Repository","tags":[],"description":"","content":"Create Repo in Pipeline Stack The first step in any good CD pipeline is source control. Here we will create a CodeCommit repository to contain our project code.\nEdit the file cdk_workshop/pipeline_stack.py as follows.\nfrom constructs import Construct from aws_cdk import ( Stack, aws_codecommit as codecommit, ) class WorkshopPipelineStack(Stack): def __init__(self, scope: Construct, id: str, **kwargs) -\u0026gt; None: super().__init__(scope, id, **kwargs) # Creates a CodeCommit repository called \u0026#39;WorkshopRepo\u0026#39; repo = codecommit.Repository( self, \u0026#39;WorkshopRepo\u0026#39;, repository_name= \u0026#34;WorkshopRepo\u0026#34; ) # Pipeline code goes here Deploy cdk deploy Get Repo Info and Commit Before we can do anything with our repo, we must add our code to it!\nGit Credentials Before we can do that, we will need Git credentials for the repo. To do this, go to the IAM Console, then navigate to Users and then your user of choice. Inside the manage user interface, navigate to the Security credentials tab and scroll until you see \u0026ldquo;HTTPS Git credentials for AWS CodeCommit\u0026rdquo;. Click generate credentials and follow the instructions on downloading those credentials. We will need them in a moment.\nAdd Git remote The last console step we will need here is to navigate to the CodeCommit Console and look for your repo. You will see a column called \u0026ldquo;Clone URL\u0026rdquo;; click \u0026ldquo;HTTPS\u0026rdquo; to copy the https link so we can add it to your local repo.\nNote: If you do not see your repo here, ensure you are in the interface for the correct region\nWhile you are here, feel free to explore your repo. You will see that it is still empty, but you do have access to the repo configuration information.\nIn your terminal, first make sure that all the changes you have made during the workshop are committed by issuing git status. If you have unstaged or uncommitted changes, you can execute git commit -am \u0026quot;SOME_COMMIT_MESSAGE_HERE\u0026quot;. This will stage and commit all your files so you are ready to go!\nNote: If you copied the code from the repo rather than following through the workshop from the beginning, first issue git init \u0026amp;\u0026amp; git add -A \u0026amp;\u0026amp; git commit -m \u0026quot;init\u0026quot;\nNext, we add the remote repo to our Git config. You can do this with the command (XXXXX represents the Clone URL you copied from the console):\ngit remote add origin XXXXX Now all we need to do is to push our code to the repo (--set-upstream tells Git to override the current empty master branch on your repo):\ngit push --set-upstream origin master Here, CodeCommit will request the credentials you generated in the Git Credentials section. You will only have to provide them once.\nNote: If the git push command hangs indefinitely, you may need to follow these instructions to set up your git CLI.\nSee Result Now you can return to the CodeCommit console and see that your code is all there!\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/70-advanced-topics/100-pipelines/2000-create-repo.html","title":"Create Repository","tags":[],"description":"","content":"Create Repo in Pipeline Stack The first step in any good CD pipeline is source control. Here we will create a CodeCommit repository to contain our project code.\nEdit the file CdkWorkshop/PipelineStack.cs as follows.\nusing Amazon.CDK; using Amazon.CDK.AWS.CodeCommit; using Constructs namespace CdkWorkshop { public class WorkshopPipelineStack : Stack { public WorkshopPipelineStack(Construct parent, string id, IStackProps props = null) : base(parent, id, props) { // Creates a CodeCommit repository called \u0026#39;WorkshopRepo\u0026#39; var repo = new Repository(this, \u0026#34;WorkshopRepo\u0026#34;, new RepositoryProps { RepositoryName = \u0026#34;WorkshopRepo\u0026#34; }); // Pipeline code goes here } } } Deploy Now we can deploy the app to see our new repo.\ndotnet build npx cdk deploy Get Repo Info and Commit Before we can do anything with our repo, we must add our code to it!\nGit Credentials Before we can do that, we will need Git credentials for the repo. To do this, go to the IAM Console, then navigate to Users and then your user of choice. Inside the manage user interface, navigate to the Security credentials tab and scroll until you see \u0026ldquo;HTTPS Git credentials for AWS CodeCommit\u0026rdquo;. Click generate credentials and follow the instructions on downloading those credentials. We will need them in a moment.\nAdd Git remote The last console step we will need here is to navigate to the CodeCommit Console and look for your repo. You will see a column called \u0026ldquo;Clone URL\u0026rdquo;; click \u0026ldquo;HTTPS\u0026rdquo; to copy the https link so we can add it to your local repo.\nNote: If you do not see your repo here, ensure you are in the interface for the correct region\nWhile you are here, feel free to explore your repo. You will see that it is still empty, but you do have access to the repo configuration information.\nIn your terminal, first make sure that all the changes you have made during the workshop are committed by issuing git status. If you have unstaged or uncommitted changes, you can execute git commit -am \u0026quot;SOME_COMMIT_MESSAGE_HERE\u0026quot;. This will stage and commit all your files so you are ready to go!\nNote: If you copied the code from the repo rather than following through the workshop from the beginning, first issue git init \u0026amp;\u0026amp; git add -A \u0026amp;\u0026amp; git commit -m \u0026quot;init\u0026quot;\nNote: By default, the CDK .gitignore file includes a reference to ignore all *.js files as those are typically generated by npm-ts. However, since we have lambda files written in js, those must not be ignored. Ensure that the .gitignore file includes a line !lambda/*.js. This will instruct git to include all *.js files in the directory lambda/\nNext, we add the remote repo to our Git config. You can do this with the command (XXXXX represents the Clone URL you copied from the console):\ngit remote add origin XXXXX Now all we need to do is to push our code to the repo (--set-upstream tells Git to override the current empty master branch on your repo):\ngit push --set-upstream origin master Here, CodeCommit will request the credentials you generated in the Git Credentials section. You will only have to provide them once.\nSee Result Now you can return to the CodeCommit console and see that your code is all there!\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/70-advanced-topics/100-pipelines/2000-create-repo.html","title":"Create Repository","tags":[],"description":"","content":"Create Repo in Pipeline Stack The first step in any good CD pipeline is source control. Here we will create a CodeCommit repository to contain our project code.\nEdit the file WorkshopPipelineStack.java as follows.\npackage com.myorg; import software.constructs.Construct; import software.amazon.awscdk.Stack; import software.amazon.awscdk.StackProps; import software.amazon.awscdk.services.codecommit.Repository; public class WorkshopPipelineStack extends Stack { public WorkshopPipelineStack(final Construct parent, final String id) { this(parent, id, null); } public WorkshopPipelineStack(final Construct parent, final String id, final StackProps props) { super(parent, id, props); // This creates a new CodeCommit repository called \u0026#39;WorkshopRepo\u0026#39; final Repository repo = Repository.Builder.create(this, \u0026#34;WorkshopRepo\u0026#34;) .repositoryName(\u0026#34;WorkshopRepo\u0026#34;) .build(); // Pipeline code goes here } } Deploy Now we can deploy the app to see our new repo.\nRun:\nmvn package npx cdk deploy Get Repo Info and Commit Before we can do anything with our repo, we must add our code to it!\nGit Credentials Before we can do that, we will need Git credentials for the repo. To do this, go to the IAM Console, then navigate to Users and then your user of choice. Inside the manage user interface, navigate to the Security credentials tab and scroll until you see \u0026ldquo;HTTPS Git credentials for AWS CodeCommit\u0026rdquo;. Click generate credentials and follow the instructions on downloading those credentials. We will need them in a moment.\nAdd Git remote The last console step we will need here is to navigate to the CodeCommit Console and look for your repo. You will see a column called \u0026ldquo;Clone URL\u0026rdquo;; click \u0026ldquo;HTTPS\u0026rdquo; to copy the https link so we can add it to your local repo.\nNote: If you do not see your repo here, ensure you are in the interface for the correct region\nWhile you are here, feel free to explore your repo. You will see that it is still empty, but you do have access to the repo configuration information.\nIn your terminal, first make sure that all the changes you have made during the workshop are committed by issuing git status. If you have unstaged or uncommitted changes, you can execute git commit -am \u0026quot;SOME_COMMIT_MESSAGE_HERE\u0026quot;. This will stage and commit all your files so you are ready to go!\nNote: If you copied the code from the repo rather than following through the workshop from the beginning, first issue git init \u0026amp;\u0026amp; git add -A \u0026amp;\u0026amp; git commit -m \u0026quot;init\u0026quot;\nNote: By default, the CDK .gitignore file includes a reference to ignore all *.js files as those are typically generated by npm-ts. However, since we have lambda files written in js, those must not be ignored. Ensure that the .gitignore file includes a line !lambda/*.js. This will instruct git to include all *.js files in the directory lambda/\nNext, we add the remote repo to our Git config. You can do this with the command (XXXXX represents the Clone URL you copied from the console):\ngit remote add origin XXXXX Now all we need to do is to push our code to the repo (--set-upstream tells Git to override the current empty master branch on your repo):\ngit push --set-upstream origin master Here, CodeCommit will request the credentials you generated in the Git Credentials section. You will only have to provide them once.\nSee Result Now you can return to the CodeCommit console and see that your code is all there!\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/70-advanced-topics/200-pipelines/3000-new-pipeline.html","title":"Create New Pipeline","tags":[],"description":"","content":"Define an Empty Pipeline Now we are ready to define the basics of the pipeline.\nReturn to the file lib/pipeline-stack.ts and edit as follows:\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import * as codecommit from \u0026#39;aws-cdk-lib/aws-codecommit\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; import {CodeBuildStep, CodePipeline, CodePipelineSource} from \u0026#34;aws-cdk-lib/pipelines\u0026#34;; export class WorkshopPipelineStack extends cdk.Stack { constructor(scope: Construct, id: string, props?: cdk.StackProps) { super(scope, id, props); // This creates a new CodeCommit repository called \u0026#39;WorkshopRepo\u0026#39; const repo = new codecommit.Repository(this, \u0026#39;WorkshopRepo\u0026#39;, { repositoryName: \u0026#34;WorkshopRepo\u0026#34; }); // The basic pipeline declaration. This sets the initial structure // of our pipeline const pipeline = new CodePipeline(this, \u0026#39;Pipeline\u0026#39;, { pipelineName: \u0026#39;WorkshopPipeline\u0026#39;, synth: new CodeBuildStep(\u0026#39;SynthStep\u0026#39;, { input: CodePipelineSource.codeCommit(repo, \u0026#39;master\u0026#39;), installCommands: [ \u0026#39;npm install -g aws-cdk\u0026#39; ], commands: [ \u0026#39;npm ci\u0026#39;, \u0026#39;npm run build\u0026#39;, \u0026#39;npx cdk synth\u0026#39; ] } ) }); } } Component Breakdown The above code does several things:\nnew CodePipeline(...): This initializes the pipeline with the required values. This will serve as the base component moving forward. Every pipeline requires at bare minimum: synth(...): The synthAction of the pipeline describes the commands necessary to install dependencies, build, and synth the CDK application from source. This should always end in a synth command, for NPM-based projects this is always npx cdk synth. The input of the synth step specifies the repository where the CDK source code is stored. Deploy Pipeline and See Result All that\u0026rsquo;s left to get our pipeline up and running is to commit our changes and run one last cdk deploy.\ngit commit -am \u0026#34;MESSAGE\u0026#34; \u0026amp;\u0026amp; git push npx cdk deploy CDK Pipelines auto-update for each commit in a source repo, so this is the last time we will need to execute this command!\nOnce deployment is finished, you can go to the CodePipeline console and you will see a new pipeline! If you navigate to it, it should look like this:\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/70-advanced-topics/200-pipelines/3000-new-pipeline.html","title":"Create New Pipeline","tags":[],"description":"","content":"Define an Empty Pipeline Now we are ready to define the basics of the pipeline.\nReturn to the file pipeline_stack.py and edit as follows:\nfrom constructs import Construct from aws_cdk import ( Stack, aws_codecommit as codecommit, pipelines as pipelines, ) class WorkshopPipelineStack(Stack): def __init__(self, scope: Construct, id: str, **kwargs) -\u0026gt; None: super().__init__(scope, id, **kwargs) # Creates a CodeCommit repository called \u0026#39;WorkshopRepo\u0026#39; repo = codecommit.Repository( self, \u0026#34;WorkshopRepo\u0026#34;, repository_name=\u0026#34;WorkshopRepo\u0026#34; ) pipeline = pipelines.CodePipeline( self, \u0026#34;Pipeline\u0026#34;, synth=pipelines.ShellStep( \u0026#34;Synth\u0026#34;, input=pipelines.CodePipelineSource.code_commit(repo, \u0026#34;master\u0026#34;), commands=[ \u0026#34;npm install -g aws-cdk\u0026#34;, # Installs the cdk cli on Codebuild \u0026#34;pip install -r requirements.txt\u0026#34;, # Instructs Codebuild to install required packages \u0026#34;cdk synth\u0026#34;, ] ), ) Component Breakdown The above code does several things:\npipelines.CodePipeline(...): This initializes the pipeline with the required values. This will serve as the base component moving forward. Every pipeline requires at bare minimum: pipelines.ShellStep(...): The synth of the pipeline describes the commands necessary to install dependencies, build, and synth the CDK application from source. This should always end in a synth command, for NPM-based projects this is always npx cdk synth. The input of the synth step specifies the repository where the CDK source code is stored. Deploy Pipeline and See Result All that\u0026rsquo;s left to get our pipeline up and running is to commit our changes and run one last cdk deploy.\ngit commit -am \u0026#34;MESSAGE\u0026#34; \u0026amp;\u0026amp; git push cdk deploy CdkPipelines auto-update for each commit in a source repo, so this is the last time we will need to execute this command!\nOnce deployment is finished, you can go to the CodePipeline console and you will see a new pipeline! If you navigate to it, it should look like this:\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/70-advanced-topics/100-pipelines/3000-new-pipeline.html","title":"Create New Pipeline","tags":[],"description":"","content":"Define an Empty Pipeline Now we are ready to define the basics of the pipeline.\nReturn to the file CdkWorkshop/PipelineStack.cs and edit as follows:\nusing Amazon.CDK; using Amazon.CDK.AWS.CodeCommit; using Amazon.CDK.AWS.CodePipeline; using Amazon.CDK.AWS.CodePipeline.Actions; using Amazon.CDK.Pipelines; using Constructs; namespace CdkWorkshop { public class WorkshopPipelineStack : Stack { public WorkshopPipelineStack(Construct parent, string id, IStackProps props = null) : base(parent, id, props) { // Creates a CodeCommit repository called \u0026#39;WorkshopRepo\u0026#39; var repo = new Repository(this, \u0026#34;WorkshopRepo\u0026#34;, new RepositoryProps { RepositoryName = \u0026#34;WorkshopRepo\u0026#34; }); // The basic pipeline declaration. This sets the initial structure // of our pipeline var pipeline = new CodePipeline(this, \u0026#34;Pipeline\u0026#34;, new CodePipelineProps { PipelineName = \u0026#34;WorkshopPipeline\u0026#34;, // Builds our source code outlined above into a could assembly artifact Synth = new ShellStep(\u0026#34;Synth\u0026#34;, new ShellStepProps{ Input = CodePipelineSource.CodeCommit(repo, \u0026#34;master\u0026#34;), // Where to get source code to build Commands = new string[] { \u0026#34;npm install -g aws-cdk\u0026#34;, \u0026#34;sudo apt-get install -y dotnet-sdk-3.1\u0026#34;, // Language-specific install cmd \u0026#34;dotnet build\u0026#34; // Language-specific build cmd } }), }); } } } Component Breakdown The above code does several things:\nnew CodePipeline(...): This initializes the pipeline with the required values. This will serve as the base component moving forward. Every pipeline requires at bare minimum: Synth(...): The synthAction of the pipeline describes the commands necessary to install dependencies, build, and synth the CDK application from source. This should always end in a synth command, for NPM-based projects this is always npx cdk synth. The input of the synth step specifies the repository where the CDK source code is stored. Deploy Pipeline and See Result All thats left to get our pipeline up and running is to commit our changes and run one last cdk deploy.\ngit commit -am \u0026#34;MESSAGE\u0026#34; \u0026amp;\u0026amp; git push cdk deploy CdkPipelines auto-update for each commit in a source repo, so this is is the last time we will need to execute this command!\nOnce deployment is finished, you can go to the CodePipeline console and you will see a new pipeline! If you navigate to it, it should look like this:\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/70-advanced-topics/100-pipelines/3000-new-pipeline.html","title":"Create New Pipeline","tags":[],"description":"","content":"Define an Empty Pipeline Now we are ready to define the basics of the pipeline.\nReturn to the file WorkshopPipelineStack.java and edit as follows:\npackage com.myorg; import java.util.List; import java.util.Map; import software.constructs.Construct; import software.amazon.awscdk.Stack; import software.amazon.awscdk.StackProps; import software.amazon.awscdk.pipelines.CodeBuildStep; import software.amazon.awscdk.pipelines.CodePipeline; import software.amazon.awscdk.pipelines.CodePipelineSource; import software.amazon.awscdk.services.codecommit.Repository; import software.amazon.awscdk.services.codepipeline.actions.CodeCommitSourceAction; public class WorkshopPipelineStack extends Stack { public WorkshopPipelineStack(final Construct parent, final String id) { this(parent, id, null); } public WorkshopPipelineStack(final Construct parent, final String id, final StackProps props) { super(parent, id, props); // This creates a new CodeCommit repository called \u0026#39;WorkshopRepo\u0026#39; final Repository repo = Repository.Builder.create(this, \u0026#34;WorkshopRepo\u0026#34;) .repositoryName(\u0026#34;WorkshopRepo\u0026#34;) .build(); // The basic pipeline declaration. This sets the initial structure // of our pipeline final CodePipeline pipeline = CodePipeline.Builder.create(this, \u0026#34;Pipeline\u0026#34;) .pipelineName(\u0026#34;WorkshopPipeline\u0026#34;) .synth(CodeBuildStep.Builder.create(\u0026#34;SynthStep\u0026#34;) .input(CodePipelineSource.codeCommit(repo, \u0026#34;master\u0026#34;)) .installCommands(List.of( \u0026#34;npm install -g aws-cdk\u0026#34; // Commands to run before build )) .commands(List.of( \u0026#34;mvn package\u0026#34;, // Language-specific build commands \u0026#34;npx cdk synth\u0026#34; // Synth command (always same) )).build()) .build(); } } Component Breakdown The above code does several things:\nCodePipeline.Builder.create(...): This initializes the pipeline with the required values. This will serve as the base component moving forward. Every pipeline requires at bare minimum: synth(...): The synthAction of the pipeline will take the source artifact generated in by the input and build the application based on the commands. This is always followed by npx cdk synth. The input of the synth step will check the designated repository for source code and generate an artifact. Deploy Pipeline and See Result All that\u0026rsquo;s left to get our pipeline up and running is to commit our changes and run one last cdk deploy.\ngit commit -am \u0026#34;MESSAGE\u0026#34; \u0026amp;\u0026amp; git push mvn package npx cdk deploy CdkPipelines auto-update for each commit in a source repo, so this is the last time we will need to execute this command!\nOnce deployment is finished, you can go to the CodePipeline console and you will see a new pipeline! If you navigate to it, it should look like this:\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/70-advanced-topics/200-pipelines/4000-build-stage.html","title":"Add Application to Pipeline","tags":[],"description":"","content":"Create Stage At this point, you have a fully operating CDK pipeline that will automatically update itself on every commit, BUT at the moment, that is all it does. We need to add a stage to the pipeline that will deploy our application.\nCreate a new file in lib called pipeline-stage.ts with the code below:\nimport { CdkWorkshopStack } from \u0026#39;./cdk-workshop-stack\u0026#39;; import { Stage, StageProps } from \u0026#39;aws-cdk-lib\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; export class WorkshopPipelineStage extends Stage { constructor(scope: Construct, id: string, props?: StageProps) { super(scope, id, props); new CdkWorkshopStack(this, \u0026#39;WebService\u0026#39;); } } All this does is declare a new Stage (component of a pipeline), and in that stage instantiate our application stack.\nNow, at this point your code editor may be telling you that you are doing something wrong. This is because the application stack as it stands now is not configured to be deployed by a pipeline. Open lib/cdk-workshop-stack.ts and make the following changes:\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import * as lambda from \u0026#39;aws-cdk-lib/aws-lambda\u0026#39;; import * as apigw from \u0026#39;aws-cdk-lib/aws-apigateway\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; import { HitCounter } from \u0026#39;./hitcounter\u0026#39;; import { TableViewer } from \u0026#39;cdk-dynamo-table-viewer\u0026#39;; export class CdkWorkshopStack extends cdk.Stack { constructor(scope: Construct, id: string, props?: cdk.StackProps) { super(scope, id, props); // The rest of your code... This stack\u0026rsquo;s scope parameter was defined as being a cdk.App, which means that in the construct tree, it must be a child of the app. Since the stack is being deployed by the pipeline, it is no longer a child of the app, so its type must be changed to Construct.\nAdd stage to pipeline Now we must add the stage to the pipeline by adding the following code to lib/pipeline-stack.ts:\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import * as codecommit from \u0026#39;aws-cdk-lib/aws-codecommit\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; import {WorkshopPipelineStage} from \u0026#39;./pipeline-stage\u0026#39;; import {CodeBuildStep, CodePipeline, CodePipelineSource} from \u0026#34;aws-cdk-lib/pipelines\u0026#34;; export class WorkshopPipelineStack extends cdk.Stack { constructor(scope: Construct, id: string, props?: cdk.StackProps) { super(scope, id, props); // This creates a new CodeCommit repository called \u0026#39;WorkshopRepo\u0026#39; const repo = new codecommit.Repository(this, \u0026#39;WorkshopRepo\u0026#39;, { repositoryName: \u0026#34;WorkshopRepo\u0026#34; }); // The basic pipeline declaration. This sets the initial structure // of our pipeline const pipeline = new CodePipeline(this, \u0026#39;Pipeline\u0026#39;, { pipelineName: \u0026#39;WorkshopPipeline\u0026#39;, synth: new CodeBuildStep(\u0026#39;SynthStep\u0026#39;, { input: CodePipelineSource.codeCommit(repo, \u0026#39;master\u0026#39;), installCommands: [ \u0026#39;npm install -g aws-cdk\u0026#39; ], commands: [ \u0026#39;npm ci\u0026#39;, \u0026#39;npm run build\u0026#39;, \u0026#39;npx cdk synth\u0026#39; ] } ) }); const deploy = new WorkshopPipelineStage(this, \u0026#39;Deploy\u0026#39;); const deployStage = pipeline.addStage(deploy); } } This imports and creates an instance of the WorkshopPipelineStage. Later, you might instantiate this stage multiple times (e.g. you want a Production deployment and a separate development/test deployment).\nThen we add that stage to our pipeline (pipeline.addStage(deploy);). A Stage in a CDK Pipeline represents a set of one or more CDK Stacks that should be deployed together, to a particular environment.\nCommit/Deploy Now that we have added the code to deploy our application, all that\u0026rsquo;s left is to commit and push those changes to the repo.\ngit commit -am \u0026#34;Add deploy stage to pipeline\u0026#34; \u0026amp;\u0026amp; git push Once that is done, we can go back to the CodePipeline console and take a look as the pipeline runs (this may take a while).\nSuccess!\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/70-advanced-topics/200-pipelines/4000-build-stage.html","title":"Add Application to Pipeline","tags":[],"description":"","content":"Create Stage At this point, you have a fully operating CDK pipeline that will automatically update itself on every commit, BUT at the moment, that is all it does. We need to add a stage to the pipeline that will deploy our application.\nCreate a new file in cdk_workshop called pipeline_stage.py with the code below:\nfrom constructs import Construct from aws_cdk import ( Stage ) from .cdk_workshop_stack import CdkWorkshopStack class WorkshopPipelineStage(Stage): def __init__(self, scope: Construct, id: str, **kwargs): super().__init__(scope, id, **kwargs) service = CdkWorkshopStack(self, \u0026#39;WebService\u0026#39;) All this does is declare a new core.Stage (component of a pipeline), and in that stage instantiate our application stack.\nAdd stage to pipeline Now we must add the stage to the pipeline by adding the following code to cdk_workshop/pipeline_stack.py:\nfrom constructs import Construct from aws_cdk import ( Stack, aws_codecommit as codecommit, pipelines as pipelines, ) from cdk_workshop.pipeline_stage import WorkshopPipelineStage class WorkshopPipelineStack(Stack): def __init__(self, scope: Construct, id: str, **kwargs) -\u0026gt; None: super().__init__(scope, id, **kwargs) # Creates a CodeCommit repository called \u0026#39;WorkshopRepo\u0026#39; repo = codecommit.Repository( self, \u0026#34;WorkshopRepo\u0026#34;, repository_name=\u0026#34;WorkshopRepo\u0026#34; ) pipeline = pipelines.CodePipeline( self, \u0026#34;Pipeline\u0026#34;, synth=pipelines.ShellStep( \u0026#34;Synth\u0026#34;, input=pipelines.CodePipelineSource.code_commit(repo, \u0026#34;master\u0026#34;), commands=[ \u0026#34;npm install -g aws-cdk\u0026#34;, # Installs the cdk cli on Codebuild \u0026#34;pip install -r requirements.txt\u0026#34;, # Instructs Codebuild to install required packages \u0026#34;npx cdk synth\u0026#34;, ] ), ) deploy = WorkshopPipelineStage(self, \u0026#34;Deploy\u0026#34;) deploy_stage = pipeline.add_stage(deploy) This imports and creates an instance of the WorkshopPipelineStage. Later, you might instantiate this stage multiple times (e.g. you want a Production deployment and a separate development/test deployment).\nThen we add that stage to our pipeline (pipeline.add_stage(deploy);). A Stage in a CDK pipeline represents a set of one or more CDK Stacks that should be deployed together, to a particular environment.\nCommit/Deploy Now that we have added the code to deploy our application, all that\u0026rsquo;s left is to commit and push those changes to the repo.\ngit commit -am \u0026#34;Add deploy stage to pipeline\u0026#34; \u0026amp;\u0026amp; git push Once that is done, we can go back to the CodePipeline console and take a look as the pipeline runs (this may take a while).\nSuccess!\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/70-advanced-topics/100-pipelines/4000-build-stage.html","title":"Add Application to Pipeline","tags":[],"description":"","content":"Create Stage At this point, you have a fully operating CDK pipeline that will automatically update itself on every commit, BUT at the moment, that is all it does. We need to add a stage to the pipeline that will deploy our application.\nCreate a new file in CdkWorkshop called PipelineStage.cs with the code below:\nusing Amazon.CDK; using Amazon.CDK.Pipelines; using Constructs; namespace CdkWorkshop { public class WorkshopPipelineStage : Stage { public WorkshopPipelineStage(Construct scope, string id, StageProps props = null) : base(scope, id, props) { var service = new CdkWorkshopStack(this, \u0026#34;WebService\u0026#34;); } } } All this does is declare a new Stage (component of a pipeline), and in that stage instantiate our application stack.\nAdd stage to pipeline Now we must add the stage to the pipeline by adding the following code to CdkWorkshop/PipelineStack.cs:\nusing Amazon.CDK; using Amazon.CDK.AWS.CodeCommit; using Amazon.CDK.AWS.CodePipeline; using Amazon.CDK.AWS.CodePipeline.Actions; using Amazon.CDK.Pipelines; using Constructs; using System.Collections.Generic; namespace CdkWorkshop { public class WorkshopPipelineStack : Stack { public WorkshopPipelineStack(Construct parent, string id, IStackProps props = null) : base(parent, id, props) { // Creates a CodeCommit repository called \u0026#39;WorkshopRepo\u0026#39; var repo = new Repository(this, \u0026#34;WorkshopRepo\u0026#34;, new RepositoryProps { RepositoryName = \u0026#34;WorkshopRepo\u0026#34; }); // The basic pipeline declaration. This sets the initial structure // of our pipeline var pipeline = new CodePipeline(this, \u0026#34;Pipeline\u0026#34;, new CodePipelineProps { PipelineName = \u0026#34;WorkshopPipeline\u0026#34;, // Builds our source code outlined above into a cloud assembly artifact Synth = new ShellStep(\u0026#34;Synth\u0026#34;, new ShellStepProps{ Input = CodePipelineSource.CodeCommit(repo, \u0026#34;master\u0026#34;), // Where to get source code to build Commands = new string[] { \u0026#34;npm install -g aws-cdk\u0026#34;, \u0026#34;sudo apt-get install -y dotnet-sdk-3.1\u0026#34;, // Language-specific install cmd \u0026#34;dotnet build\u0026#34;, // Language-specific build cmd \u0026#34;npx cdk synth\u0026#34; } }), }); var deploy = new WorkshopPipelineStage(this, \u0026#34;Deploy\u0026#34;); var deployStage = pipeline.AddStage(deploy); } } } This imports and creates an instance of the WorkshopPipelineStage. Later, you might instantiate this stage multiple times (e.g. you want a Production deployment and a separate development/test deployment).\nThen we add that stage to our pipeline (pipepeline.AddStage(deploy);). A Stage in a CDK pipeline represents a set of one or more CDK Stacks that should be deployed together, to a particular environment.\nCommit/Deploy Now that we have added the code to deploy our application, all that\u0026rsquo;s left is to commit and push those changes to the repo.\ngit commit -am \u0026#34;Add deploy stage to pipeline\u0026#34; \u0026amp;\u0026amp; git push Once that is done, we can go back to the CodePipeline console and take a look as the pipeline runs (this may take a while).\nSuccess!\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/70-advanced-topics/100-pipelines/4000-build-stage.html","title":"Add Application to Pipeline","tags":[],"description":"","content":"Create Stage At this point, you have a fully operating CodePipeline that will automatically update itself on every commit, BUT at the moment, that is all it does. We need to add a stage to the pipeline that will deploy our application.\nCreate a new file in CdkWorkshop called WorkshopPipelineStage.java with the code below:\npackage com.myorg; import software.amazon.awscdk.Stage; import software.constructs.Construct; import software.amazon.awscdk.StageProps; public class WorkshopPipelineStage extends Stage { public WorkshopPipelineStage(final Construct scope, final String id) { this(scope, id, null); } public WorkshopPipelineStage(final Construct scope, final String id, final StageProps props) { super(scope, id, props); new CdkWorkshopStack(this, \u0026#34;WebService\u0026#34;); } } All this does is declare a new Stage (component of a pipeline), and in that stage instantiate our application stack.\nAdd stage to pipeline Now we must add the stage to the pipeline by adding the following code to WorkshopPipelineStack.java:\npackage com.myorg; import java.util.List; import java.util.Map; import software.constructs.Construct; import software.amazon.awscdk.Stack; import software.amazon.awscdk.StackProps; import software.amazon.awscdk.pipelines.CodeBuildStep; import software.amazon.awscdk.pipelines.CodePipeline; import software.amazon.awscdk.pipelines.CodePipelineSource; import software.amazon.awscdk.services.codecommit.Repository; public class WorkshopPipelineStack extends Stack { public WorkshopPipelineStack(final Construct parent, final String id) { this(parent, id, null); } public WorkshopPipelineStack(final Construct parent, final String id, final StackProps props) { super(parent, id, props); // This creates a new CodeCommit repository called \u0026#39;WorkshopRepo\u0026#39; final Repository repo = Repository.Builder.create(this, \u0026#34;WorkshopRepo\u0026#34;) .repositoryName(\u0026#34;WorkshopRepo\u0026#34;) .build(); // The basic pipeline declaration. This sets the initial structure // of our pipeline final CodePipeline pipeline = CodePipeline.Builder.create(this, \u0026#34;Pipeline\u0026#34;) .pipelineName(\u0026#34;WorkshopPipeline\u0026#34;) .synth(CodeBuildStep.Builder.create(\u0026#34;SynthStep\u0026#34;) .input(CodePipelineSource.codeCommit(repo, \u0026#34;master\u0026#34;)) .installCommands(List.of( \u0026#34;npm install -g aws-cdk\u0026#34; // Commands to run before build )) .commands(List.of( \u0026#34;mvn package\u0026#34;, // Language-specific build commands \u0026#34;npx cdk synth\u0026#34; // Synth command (always same) )).build()) .build(); final WorkshopPipelineStage deploy = new WorkshopPipelineStage(this, \u0026#34;Deploy\u0026#34;); pipeline.addStage(deploy); } } This imports and creates an instance of the WorkshopPipelineStage. Later, you might instantiate this stage multiple times (e.g. you want a Production deployment and a separate development/test deployment).\nThen we add that stage to our pipeline (pipeline.addStage(deploy);). An ApplicationStage in a CodePipeline represents any CDK deployment action.\nCommit/Deploy Now that we have added the code to deploy our application, all that\u0026rsquo;s left is to commit and push those changes to the repo.\ngit commit -am \u0026#34;Add deploy stage to pipeline\u0026#34; \u0026amp;\u0026amp; git push Once that is done, we can go back to the CodePipeline console and take a look as the pipeline runs (this may take a while).\nSuccess!\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/70-advanced-topics/200-pipelines/5000-test-actions.html","title":"Polish Pipeline","tags":[],"description":"","content":"Get Endpoints Stepping back, we can see a problem now that our app is being deployed by our pipeline. There is no easy way to find the endpoints of our application (the TableViewer and APIGateway endpoints), so we can\u0026rsquo;t call it! Let\u0026rsquo;s add a little bit of code to expose these more obviously.\nFirst edit lib/cdk-workshop-stack.ts to get these values and expose them as properties of our stack:\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import * as lambda from \u0026#39;aws-cdk-lib/aws-lambda\u0026#39;; import * as apigw from \u0026#39;aws-cdk-lib/aws-apigateway\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; import { HitCounter } from \u0026#39;./hitcounter\u0026#39;; import { TableViewer } from \u0026#39;cdk-dynamo-table-viewer\u0026#39;; export class CdkWorkshopStack extends cdk.Stack { public readonly hcViewerUrl: cdk.CfnOutput; public readonly hcEndpoint: cdk.CfnOutput; constructor(scope: Construct, id: string, props?: cdk.StackProps) { super(scope, id, props); const hello = new lambda.Function(this, \u0026#39;HelloHandler\u0026#39;, { runtime: lambda.Runtime.NODEJS_14_X, code: lambda.Code.fromAsset(\u0026#39;lambda\u0026#39;), handler: \u0026#39;hello.handler\u0026#39;, }); const helloWithCounter = new HitCounter(this, \u0026#39;HelloHitCounter\u0026#39;, { downstream: hello }); // defines an API Gateway REST API resource backed by our \u0026#34;hello\u0026#34; function. const gateway = new apigw.LambdaRestApi(this, \u0026#39;Endpoint\u0026#39;, { handler: helloWithCounter.handler }); const tv = new TableViewer(this, \u0026#39;ViewHitCounter\u0026#39;, { title: \u0026#39;Hello Hits\u0026#39;, table: helloWithCounter.table, sortBy: \u0026#39;-hits\u0026#39; }); this.hcEndpoint = new cdk.CfnOutput(this, \u0026#39;GatewayUrl\u0026#39;, { value: gateway.url }); this.hcViewerUrl = new cdk.CfnOutput(this, \u0026#39;TableViewerUrl\u0026#39;, { value: tv.endpoint }); } } By adding outputs hcViewerUrl and hcEnpoint, we expose the necessary endpoints to our HitCounter application. We are using the core construct CfnOutput to declare these as Cloudformation stack outputs (we will get to this in a minute).\nLet\u0026rsquo;s commit these changes to our repo (git commit -am \u0026quot;MESSAGE\u0026quot; \u0026amp;\u0026amp; git push), and navigate to the Cloudformation console. You can see there are three stacks.\nCDKToolkit: The first is the integrated CDK stack (you should always see this on bootstrapped accounts). You can ignore this. WorkshopPipelineStack: This is the stack that declares our pipeline. It isn\u0026rsquo;t the one we need right now. Deploy-WebService: Here is our application! Select this, and under details, select the Outputs tab. Here you should see four endpoints (two pairs of duplicate values). Two of them, EndpointXXXXXX and ViewerHitCounterViewerEndpointXXXXXXX, are defaults generated by Cloudformation, and the other two are the outputs we declared ourselves. If you click the TableViewerUrl value, you should see our pretty hitcounter table that we created in the initial workshop.\nAdd Validation Test Now we have our application deployed, but no CD pipeline is complete without tests!\nLet\u0026rsquo;s start with a simple test to ping our endpoints to see if they are alive. Return to lib/pipeline-stack.ts and add the following:\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import * as codecommit from \u0026#39;aws-cdk-lib/aws-codecommit\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; import {WorkshopPipelineStage} from \u0026#39;./pipeline-stage\u0026#39;; import {CodeBuildStep, CodePipeline, CodePipelineSource} from \u0026#34;aws-cdk-lib/pipelines\u0026#34;; export class WorkshopPipelineStack extends cdk.Stack { constructor(scope: Construct, id: string, props?: cdk.StackProps) { super(scope, id, props); // PIPELINE CODE HERE... const deploy = new WorkshopPipelineStage(this, \u0026#39;Deploy\u0026#39;); const deployStage = pipeline.addStage(deploy); deployStage.addPost( new CodeBuildStep(\u0026#39;TestViewerEndpoint\u0026#39;, { projectName: \u0026#39;TestViewerEndpoint\u0026#39;, envFromCfnOutputs: { ENDPOINT_URL: //TBD }, commands: [ \u0026#39;curl -Ssf $ENDPOINT_URL\u0026#39; ] }), new CodeBuildStep(\u0026#39;TestAPIGatewayEndpoint\u0026#39;, { projectName: \u0026#39;TestAPIGatewayEndpoint\u0026#39;, envFromCfnOutputs: { ENDPOINT_URL: //TBD }, commands: [ \u0026#39;curl -Ssf $ENDPOINT_URL\u0026#39;, \u0026#39;curl -Ssf $ENDPOINT_URL/hello\u0026#39;, \u0026#39;curl -Ssf $ENDPOINT_URL/test\u0026#39; ] }) ) } } We add post-deployment steps via deployStage.addPost(...) from CDK Pipelines. We add two actions to our deployment stage: to test our TableViewer endpoint and our APIGateway endpoint, respectively.\nNote: We submit several curl requests to the APIGateway endpoint so that when we look at our tableviewer, there are several values already populated.\nYou may notice that we have not yet set the URLs of these endpoints. This is because they are not yet exposed to this stack!\nWith a slight modification to lib/pipeline-stage.ts we can expose them:\nimport { CdkWorkshopStack } from \u0026#39;./cdk-workshop-stack\u0026#39;; import { Stage, CfnOutput, StageProps } from \u0026#39;aws-cdk-lib\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; export class WorkshopPipelineStage extends Stage { public readonly hcViewerUrl: CfnOutput; public readonly hcEndpoint: CfnOutput; constructor(scope: Construct, id: string, props?: StageProps) { super(scope, id, props); const service = new CdkWorkshopStack(this, \u0026#39;WebService\u0026#39;); this.hcEndpoint = service.hcEndpoint; this.hcViewerUrl = service.hcViewerUrl; } } Now we can add those values to our actions in lib/pipeline-stack.ts by getting the stackOutput of our pipeline stack: // CODE HERE... deployStage.addPost( new CodeBuildStep(\u0026#39;TestViewerEndpoint\u0026#39;, { projectName: \u0026#39;TestViewerEndpoint\u0026#39;, envFromCfnOutputs: { ENDPOINT_URL: deploy.hcViewerUrl }, commands: [ \u0026#39;curl -Ssf $ENDPOINT_URL\u0026#39; ] }), new CodeBuildStep(\u0026#39;TestAPIGatewayEndpoint\u0026#39;, { projectName: \u0026#39;TestAPIGatewayEndpoint\u0026#39;, envFromCfnOutputs: { ENDPOINT_URL: deploy.hcEndpoint }, commands: [ \u0026#39;curl -Ssf $ENDPOINT_URL\u0026#39;, \u0026#39;curl -Ssf $ENDPOINT_URL/hello\u0026#39;, \u0026#39;curl -Ssf $ENDPOINT_URL/test\u0026#39; ] }) )\nCommit and View! Commit those changes, wait for the pipeline to re-deploy the app, and navigate back to the CodePipeline Console and you can now see that there are two test actions contained within the Deploy stage!\nCongratulations! You have successfully created a CD pipeline for your application complete with tests and all! Feel free to explore the console to see the details of the stack created, or check out the API Reference section on CDK Pipelines and build one for your application.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/70-advanced-topics/200-pipelines/5000-test-actions.html","title":"Polish Pipeline","tags":[],"description":"","content":"Get Endpoints Stepping back, we can see a problem now that our app is being deployed by our pipeline. There is no easy way to find the endpoints of our application (the TableViewer and LambdaRestApi endpoints), so we can\u0026rsquo;t call it! Let\u0026rsquo;s add a little bit of code to expose these more obviously.\nFirst edit cdk_workshop/cdk_workshop_stack.py to get these values and expose them as properties of our stack:\nfrom constructs import Construct from aws_cdk import ( Stack, CfnOutput, aws_lambda as _lambda, aws_apigateway as apigw, ) from cdk_dynamo_table_view import TableViewer from .hitcounter import HitCounter class CdkWorkshopStack(Stack): @property def hc_endpoint(self): return self._hc_endpoint @property def hc_viewer_url(self): return self._hc_viewer_url def __init__(self, scope: Construct, id: str, **kwargs) -\u0026gt; None: super().__init__(scope, id, **kwargs) # Defines an AWS Lambda resource my_lambda = _lambda.Function( self, \u0026#39;HelloHandler\u0026#39;, runtime=_lambda.Runtime.PYTHON_3_7, code=_lambda.Code.from_asset(\u0026#39;lambda\u0026#39;), handler=\u0026#39;hello.handler\u0026#39;, ) hello_with_counter = HitCounter( self, \u0026#39;HelloHitCounter\u0026#39;, downstream=my_lambda ) gateway = apigw.LambdaRestApi( self, \u0026#39;Endpoint\u0026#39;, handler=hello_with_counter._handler ) tv = TableViewer( self, \u0026#39;ViewHitCounter\u0026#39;, title=\u0026#39;Hello Hits\u0026#39;, table=hello_with_counter.table ) self._hc_endpoint = CfnOutput( self, \u0026#39;GatewayUrl\u0026#39;, value=gateway.url ) self._hc_viewer_url = CfnOutput( self, \u0026#39;TableViewerUrl\u0026#39;, value=tv.endpoint ) By adding outputs hc_viewer_url and hc_endpoint, we expose the necessary endpoints to our HitCounter application. We are using the core construct CfnOutput to declare these as Cloudformation stack outputs (we will get to this in a minute).\nLet\u0026rsquo;s commit these changes to our repo (git commit -am \u0026quot;MESSAGE\u0026quot; \u0026amp;\u0026amp; git push), and navigate to the Cloudformation console. You can see there are three stacks.\nCDKToolkit: The first is the integrated CDK stack (you should always see this on bootstrapped accounts). You can ignore this. WorkshopPipelineStack: This is the stack that declares our pipeline. It isn\u0026rsquo;t the one we need right now. Deploy-WebService: Here is our application! Select this, and under details, select the Outputs tab. Here you should see four endpoints (two pairs of duplicate values). Two of them, EndpointXXXXXX and ViewerHitCounterViewerEndpointXXXXXXX, are defaults generated by Cloudformation, and the other two are the outputs we declared ourselves. If you click the TableViewerUrl value, you should see our pretty hitcounter table that we created in the initial workshop.\nAdd Validation Test Now we have our application deployed, but no CD pipeline is complete without tests!\nLet\u0026rsquo;s start with a simple test to ping our endpoints to see if they are alive. Return to cdk_workshop/pipeline_stack.py and add the following:\nfrom constructs import Construct from aws_cdk import ( Stack, aws_codecommit as codecommit, pipelines as pipelines ) from pipeline_stage import WorkshopPipelineStage class WorkshopPipelineStack(Stack): def __init__(self, scope: Construct, id: str, **kwargs) -\u0026gt; None: super().__init__(scope, id, **kwargs) # PIPELINE CODE HERE... deploy = WorkshopPipelineStage(self, \u0026#34;Deploy\u0026#34;) deploy_stage = pipeline.add_stage(deploy) deploy_stage.add_post( pipelines.ShellStep( \u0026#34;TestViewerEndpoint\u0026#34;, env_from_cfn_outputs={ \u0026#34;ENDPOINT_URL\u0026#34;: # TBD }, commands=[\u0026#34;curl -Ssf $ENDPOINT_URL\u0026#34;], ) ) deploy_stage.add_post( pipelines.ShellStep( \u0026#34;TestAPIGatewayEndpoint\u0026#34;, env_from_cfn_outputs={ \u0026#34;ENDPOINT_URL\u0026#34;: # TBD }, commands=[ \u0026#34;curl -Ssf $ENDPOINT_URL\u0026#34;, \u0026#34;curl -Ssf $ENDPOINT_URL/hello\u0026#34;, \u0026#34;curl -Ssf $ENDPOINT_URL/test\u0026#34;, ], ) ) We add post-deployment steps via deployStage.AddPost(...) from CDK Pipelines. We add two actions to our deployment stage: to test our TableViewer endpoint and our APIGateway endpoint, respectively.\nNote: We submit several curl requests to the APIGateway endpoint so that when we look at our tableviewer, there are several values already populated.\nYou may notice that we have not yet set the URLs of these endpoints. This is because they are not yet exposed to this stack!\nWith a slight modification to cdk_workshop/pipeline_stage.py we can expose them:\nfrom constructs import Construct from aws_cdk import Stage from cdk_workshop.cdk_workshop_stack import CdkWorkshopStack class WorkshopPipelineStage(Stage): @property def hc_endpoint(self): return self._hc_endpoint @property def hc_viewer_url(self): return self._hc_viewer_url def __init__(self, scope: Construct, id: str, **kwargs): super().__init__(scope, id, **kwargs) service = CdkWorkshopStack(self, \u0026#34;WebService\u0026#34;) self._hc_endpoint = service.hc_endpoint self._hc_viewer_url = service.hc_viewer_url Now we can add those values to our actions in cdk_workshop/pipeline_stack.py by getting the cfn_output of our deploy stage: # CODE HERE... deploy = WorkshopPipelineStage(self, \u0026#34;Deploy\u0026#34;) deploy_stage = pipeline.add_stage(deploy) deploy_stage.add_post( pipelines.ShellStep( \u0026#34;TestViewerEndpoint\u0026#34;, env_from_cfn_outputs={ \u0026#34;ENDPOINT_URL\u0026#34;: deploy.hc_viewer_url }, commands=[\u0026#34;curl -Ssf $ENDPOINT_URL\u0026#34;], ) ) deploy_stage.add_post( pipelines.ShellStep( \u0026#34;TestAPIGatewayEndpoint\u0026#34;, env_from_cfn_outputs={ \u0026#34;ENDPOINT_URL\u0026#34;: deploy.hc_endpoint }, commands=[ \u0026#34;curl -Ssf $ENDPOINT_URL\u0026#34;, \u0026#34;curl -Ssf $ENDPOINT_URL/hello\u0026#34;, \u0026#34;curl -Ssf $ENDPOINT_URL/test\u0026#34;, ], ) )\nCommit and View! Commit those changes, wait for the pipeline to re-deploy the app, and navigate back to the CodePipeline Console and you can now see that there are two test actions contained within the Deploy stage!\nCongratulations! You have successfully created a CD pipeline for your application complete with tests and all! Feel free to explore the console to see the details of the stack created, or check out the API Reference section on CDK Pipelines and build one for your application.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/70-advanced-topics/100-pipelines/5000-test-actions.html","title":"Polish Pipeline","tags":[],"description":"","content":"Get Endpoints Stepping back, we can see a problem now that our app is being deployed by our pipeline. There is no easy way to find the endpoints of our application (the TableViewer and APIGateway endpoints), so we can\u0026rsquo;t call it! Let\u0026rsquo;s add a little bit of code to expose these more obviously.\nFirst edit CdkWorkshop/CdkWorkshopStack.cs to get these values and expose them as properties of our stack:\nusing Amazon.CDK; using Amazon.CDK.AWS.APIGateway; using Amazon.CDK.AWS.Lambda; using Cdklabs.DynamoTableViewer; using Constructs; namespace CdkWorkshop { public class CdkWorkshopStack : Stack { public readonly CfnOutput HCViewerUrl; public readonly CfnOutput HCEndpoint; // Defines a new lambda resource public CdkWorkshopStack(Construct parent, string id, IStackProps props = null) : base(parent, id, props) { var hello = new Function(this, \u0026#34;HelloHandler\u0026#34;, new FunctionProps { Runtime = Runtime.NODEJS_14_X, Code = Code.FromAsset(\u0026#34;lambda\u0026#34;), Handler = \u0026#34;hello.handler\u0026#34; }); var helloWithCounter = new HitCounter(this, \u0026#34;HelloHitCounter\u0026#34;, new HitCounterProps { Downstream = hello }); var gateway = new LambdaRestApi(this, \u0026#34;Endpoint\u0026#34;, new LambdaRestApiProps { Handler = helloWithCounter.Handler }); var tv = new TableViewer(this, \u0026#34;ViewerHitCount\u0026#34;, new TableViewerProps { Title = \u0026#34;Hello Hits\u0026#34;, Table = helloWithCounter.MyTable }); this.HCViewerUrl = new CfnOutput(this, \u0026#34;TableViewerUrl\u0026#34;, new CfnOutputProps { Value = tv.Endpoint }); this.HCEndpoint = new CfnOutput(this, \u0026#34;GatewayUrl\u0026#34;, new CfnOutputProps { Value = gateway.Url }); } } } By adding outputs HCViewerUrl and HCEndpoint, we expose the necessary endpoints to our HitCounter application. We are using the core construct CfnOutput to declare these as CloudFormation stack outputs (we will get to this in a minute).\nLet\u0026rsquo;s commit these changes to our repo (git commit -am \u0026quot;MESSAGE\u0026quot; \u0026amp;\u0026amp; git push), and navigate to the CloudFormation console. You can see there are three stacks.\nCDKToolkit: The first is the integrated CDK stack (you should always see this on bootstrapped accounts). You can ignore this. WorkshopPipelineStack: This is the stack that declares our pipeline. It isn\u0026rsquo;t the one we need right now. Deploy-WebService: Here is our application! Select this, and under details, select the Outputs tab. Here you should see four endpoints (two pairs of duplicate values). Two of them, EndpointXXXXXX and ViewerHitCounterViewerEndpointXXXXXXX, are defaults generated by CloudFormation, and the other two are the outputs we declared ourselves. If you click the TableViewerUrl value, you should see our pretty hitcounter table that we created in the initial workshop.\nAdd Validation Test Now we have our application deployed, but no CD pipeline is complete without tests!\nLet\u0026rsquo;s start with a simple test to ping our endpoints to see if they are alive. Return to CdkWorkshop/PipelineStack.cs and add the following:\nusing Amazon.CDK; using Amazon.CDK.AWS.CodeCommit; using Amazon.CDK.AWS.CodePipeline; using Amazon.CDK.AWS.CodePipeline.Actions; using Amazon.CDK.Pipelines; using Constructs; using System.Collections.Generic; namespace CdkWorkshop { public class WorkshopPipelineStack : Stack { public WorkshopPipelineStack(Construct parent, string id, IStackProps props = null) : base(parent, id, props) { // PIPELINE CODE HERE... var deploy = new WorkshopPipelineStage(this, \u0026#34;Deploy\u0026#34;); var deployStage = pipeline.AddApplicationStage(deploy); deployStage.AddPost(new ShellStep(\u0026#34;TestViewerEndpoint\u0026#34;, new ShellStepProps{ EnvFromCfnOutputs = new Dictionary\u0026lt;string, CfnOutput\u0026gt; { { \u0026#34;ENDPOINT_URL\u0026#34;, /* TBD */ } }, Commands = new string[] { \u0026#34;curl -Ssf $ENDPOINT_URL\u0026#34; } })); deployStage.AddPost(new ShellStep(\u0026#34;TestAPIGatewayEndpoint\u0026#34;, new ShellStepProps{ EnvFromCfnOutputs = new Dictionary\u0026lt;string, CfnOutput\u0026gt; { { \u0026#34;ENDPOINT_URL\u0026#34;, /* TBD */ } }, Commands = new string[] { \u0026#34;curl -Ssf $ENDPOINT_URL/\u0026#34;, \u0026#34;curl -Ssf $ENDPOINT_URL/hello\u0026#34;, \u0026#34;curl -Ssf $ENDPOINT_URL/test\u0026#34; } })); } } } We add post-deployment steps via deployStage.AddPost(...) from CDK Pipelines. We add two actions to our deployment stage: to test our TableViewer endpoint and our APIGateway endpoint, respectively.\nNote: We submit several curl requests to the APIGateway endpoint so that when we look at our tableviewer, there are several values already populated.\nYou may notice that we have not yet set the URLs of these endpoints. This is because they are not yet exposed to this stack!\nWith a slight modification to CdkWorkshop/PipelineStage.cs we can expose them:\nusing Amazon.CDK; using Amazon.CDK.Pipelines; using Constructs; namespace CdkWorkshop { public class WorkshopPipelineStage : Stage { public readonly CfnOutput HCViewerUrl; public readonly CfnOutput HCEndpoint; public WorkshopPipelineStage(Construct scope, string id, StageProps props = null) : base(scope, id, props) { var service = new CdkWorkshopStack(this, \u0026#34;WebService\u0026#34;); this.HCEndpoint = service.HCEndpoint; this.HCViewerUrl = service.HCViewerUrl; } } } Now we can add those values to our actions in CdkWorkshop/PipelineStack.cs by getting the CfnOutput of our deploy stage: // CODE HERE... deployStage.AddPost(new ShellStep(\u0026#34;TestViewerEndpoint\u0026#34;, new ShellStepProps{ EnvFromCfnOutputs = new Dictionary\u0026lt;string, CfnOutput\u0026gt; { { \u0026#34;ENDPOINT_URL\u0026#34;, deploy.HCViewerUrl } }, Commands = new string[] { \u0026#34;curl -Ssf $ENDPOINT_URL\u0026#34; } })); deployStage.AddPost(new ShellStep(\u0026#34;TestAPIGatewayEndpoint\u0026#34;, new ShellStepProps{ EnvFromCfnOutputs = new Dictionary\u0026lt;string, CfnOutput\u0026gt; { { \u0026#34;ENDPOINT_URL\u0026#34;, deploy.HCEndpoint } }, Commands = new string[] { \u0026#34;curl -Ssf $ENDPOINT_URL/\u0026#34;, \u0026#34;curl -Ssf $ENDPOINT_URL/hello\u0026#34;, \u0026#34;curl -Ssf $ENDPOINT_URL/test\u0026#34; } }));\nCommit and View! Commit those changes, wait for the pipeline to re-deploy the app, and navigate back to the CodePipeline Console and you can now see that there are two test actions contained within the Deploy stage!\nCongratulations! You have successfully created a CD pipeline for your application complete with tests and all! Feel free to explore the console to see the details of the stack created, or check out the API Reference section on CDK Pipelines and build one for your application.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/70-advanced-topics/100-pipelines/5000-test-actions.html","title":"Polish Pipeline","tags":[],"description":"","content":"Get Endpoints Stepping back, we can see a problem now that our app is being deployed by our pipeline. There is no easy way to find the endpoints of our application (the TableViewer and APIGateway endpoints), so we can\u0026rsquo;t call it! Let\u0026rsquo;s add a little bit of code to expose these more obviously.\nFirst edit CdkWorkshopStack.java to get these values and expose them as properties of our stack:\npackage com.myorg; import io.github.cdklabs.dynamotableviewer.TableViewer; import software.constructs.Construct; import software.amazon.awscdk.Stack; import software.amazon.awscdk.StackProps; import software.amazon.awscdk.CfnOutput; import software.amazon.awscdk.services.apigateway.LambdaRestApi; import software.amazon.awscdk.services.lambda.Code; import software.amazon.awscdk.services.lambda.Function; import software.amazon.awscdk.services.lambda.Runtime; public class CdkWorkshopStack extends Stack { public final CfnOutput hcViewerUrl; public final CfnOutput hcEndpoint; public CdkWorkshopStack(final Construct parent, final String id) { this(parent, id, null); } public CdkWorkshopStack(final Construct parent, final String id, final StackProps props) { super(parent, id, props); // Defines a new lambda resource final Function hello = Function.Builder.create(this, \u0026#34;HelloHandler\u0026#34;) .runtime(Runtime.NODEJS_14_X) // execution environment .code(Code.fromAsset(\u0026#34;lambda\u0026#34;)) // code loaded from the \u0026#34;lambda\u0026#34; directory .handler(\u0026#34;hello.handler\u0026#34;) // file is \u0026#34;hello\u0026#34;, function is \u0026#34;handler\u0026#34; .build(); // Defines our hitcounter resource final HitCounter helloWithCounter = new HitCounter(this, \u0026#34;HelloHitCounter\u0026#34;, HitCounterProps.builder() .downstream(hello) .build()); // Defines an API Gateway REST API resource backed by our \u0026#34;hello\u0026#34; function final LambdaRestApi gateway = LambdaRestApi.Builder.create(this, \u0026#34;Endpoint\u0026#34;) .handler(helloWithCounter.getHandler()) .build(); // Defines a viewer for the HitCounts table final TableViewer tv = TableViewer.Builder.create(this, \u0026#34;ViewerHitCount\u0026#34;) .title(\u0026#34;Hello Hits\u0026#34;) .table(helloWithCounter.getTable()) .build(); hcViewerUrl = CfnOutput.Builder.create(this, \u0026#34;TableViewerUrl\u0026#34;) .value(tv.getEndpoint()) .build(); hcEndpoint = CfnOutput.Builder.create(this, \u0026#34;GatewayUrl\u0026#34;) .value(gateway.getUrl()) .build(); } } By adding outputs hcViewerUrl and hcEnpoint, we expose the necessary endpoints to our HitCounter application. We are using the core construct CfnOutput to declare these as Cloudformation stack outputs (we will get to this in a minute).\nLet\u0026rsquo;s commit these changes to our repo (git commit -am \u0026quot;MESSAGE\u0026quot; \u0026amp;\u0026amp; git push), and navigate to the Cloudformation console. You can see there are three stacks.\nCDKToolkit: The first is the integrated CDK stack (you should always see this on bootstrapped accounts). You can ignore this. WorkshopPipelineStack: This is the stack that declares our pipeline. It isn\u0026rsquo;t the one we need right now. Deploy-WebService: Here is our application! Select this, and under details, select the Outputs tab. Here you should see four endpoints (two pairs of duplicate values). Two of them, EndpointXXXXXX and ViewerHitCounterViewerEndpointXXXXXXX, are defaults generated by Cloudformation, and the other two are the outputs we declared ourselves. If you click the TableViewerUrl value, you should see our pretty hitcounter table that we created in the initial workshop.\nAdd Validation Test Now we have our application deployed, but no CD pipeline is complete without tests!\nLet\u0026rsquo;s start with a simple test to ping our endpoints to see if they are alive. Return to WorkshopPipelineStack.java and add the following:\npackage com.myorg; import java.util.List; import java.util.Map; import software.constructs.Construct; import software.amazon.awscdk.Stack; import software.amazon.awscdk.StackProps; import software.amazon.awscdk.pipelines.CodeBuildStep; import software.amazon.awscdk.pipelines.CodePipeline; import software.amazon.awscdk.pipelines.CodePipelineSource; import software.amazon.awscdk.pipelines.StageDeployment; import software.amazon.awscdk.services.codecommit.Repository; import software.amazon.awscdk.services.codepipeline.actions.CodeCommitSourceAction; public class WorkshopPipelineStack extends Stack { public WorkshopPipelineStack(final Construct parent, final String id) { this(parent, id, null); } public WorkshopPipelineStack(final Construct parent, final String id, final StackProps props) { super(parent, id, props); // PIPELINE CODE HERE final WorkshopPipelineStage deploy = new WorkshopPipelineStage(this, \u0026#34;Deploy\u0026#34;); StageDeployment stageDeployment = pipeline.addStage(deploy); stageDeployment.addPost( CodeBuildStep.Builder.create(\u0026#34;TestViewerEndpoint\u0026#34;) .projectName(\u0026#34;TestViewerEndpoint\u0026#34;) .commands(List.of(\u0026#34;curl -Ssf $ENDPOINT_URL\u0026#34;)) .envFromCfnOutputs(Map.of(\u0026#34;ENDPOINT_URL\u0026#34;, /* TBD */)) .build(), CodeBuildStep.Builder.create(\u0026#34;TestAPIGatewayEndpoint\u0026#34;) .projectName(\u0026#34;TestAPIGatewayEndpoint\u0026#34;) .envFromCfnOutputs(Map.of(\u0026#34;ENDPOINT_URL\u0026#34;, /* TBD */)) .commands(List.of( \u0026#34;curl -Ssf $ENDPOINT_URL\u0026#34;, \u0026#34;curl -Ssf $ENDPOINT_URL/hello\u0026#34;, \u0026#34;curl -Ssf $ENDPOINT_URL/test\u0026#34; )) .build() ); } } We add deployment post step via stageDeployment.addPost(...) from CDK Pipelines. We add two actions to our deployment stage that test our TableViewer endpoint and our APIGateway endpoint respectively.\nNote: We submit several curl requests to the APIGateway endpoint so that when we look at our tableviewer, there are several values already populated.\nYou may notice that we have not yet set the URLs of these endpoints. This is because they are not yet exposed to this stack!\nWith a slight modification to WorkshopPipelineStage.java we can expose them:\npackage com.myorg; import software.amazon.awscdk.Stage; import software.constructs.Construct; import software.amazon.awscdk.StageProps; import software.amazon.awscdk.CfnOutput; public class WorkshopPipelineStage extends Stage { public final CfnOutput hcViewerUrl; public final CfnOutput hcEndpoint; public WorkshopPipelineStage(final Construct scope, final String id) { this(scope, id, null); } public WorkshopPipelineStage(final Construct scope, final String id, final StageProps props) { super(scope, id, props); final CdkWorkshopStack service = new CdkWorkshopStack(this, \u0026#34;WebService\u0026#34;); hcViewerUrl = service.hcViewerUrl; hcEndpoint = service.hcEndpoint; } } Now we can add those values to our actions in WorkshopPipelineStack.java by getting the StackOutput of our pipeline stack: // OTHER CODE HERE... final WorkshopPipelineStage deploy = new WorkshopPipelineStage(this, \u0026#34;Deploy\u0026#34;); StageDeployment stageDeployment = pipeline.addStage(deploy); stageDeployment.addPost( CodeBuildStep.Builder.create(\u0026#34;TestViewerEndpoint\u0026#34;) .projectName(\u0026#34;TestViewerEndpoint\u0026#34;) .commands(List.of(\u0026#34;curl -Ssf $ENDPOINT_URL\u0026#34;)) .envFromCfnOutputs(Map.of(\u0026#34;ENDPOINT_URL\u0026#34;, deploy.hcViewerUrl)) .build(), CodeBuildStep.Builder.create(\u0026#34;TestAPIGatewayEndpoint\u0026#34;) .projectName(\u0026#34;TestAPIGatewayEndpoint\u0026#34;) .envFromCfnOutputs(Map.of(\u0026#34;ENDPOINT_URL\u0026#34;, deploy.hcEndpoint)) .commands(List.of( \u0026#34;curl -Ssf $ENDPOINT_URL\u0026#34;, \u0026#34;curl -Ssf $ENDPOINT_URL/hello\u0026#34;, \u0026#34;curl -Ssf $ENDPOINT_URL/test\u0026#34; )) .build()\nCommit and View! Commit those changes, wait for the pipeline to re-deploy the app, and navigate back to the CodePipeline Console and you can now see that there are two test actions contained within the Deploy stage!\nCongratulations! You have successfully created a CD pipeline for your application complete with tests and all! Feel free to explore the console to see the details of the stack created, or check out the API Reference section on CDK Pipelines and build one for your application.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/70-advanced-topics/200-pipelines/6000-cleanup.html","title":"Cleanup","tags":[],"description":"","content":"To clean up the stacks from this workshop, navigate to the Cloudformation Console, select your stacks, and hit \u0026ldquo;Delete\u0026rdquo;. This may take some time.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/70-advanced-topics/200-pipelines/6000-cleanup.html","title":"Cleanup","tags":[],"description":"","content":"To clean up the stacks from this workshop, navigate to the Cloudformation Console, select your stacks, and hit \u0026ldquo;Delete\u0026rdquo;. This may take some time.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/70-advanced-topics/100-pipelines/6000-cleanup.html","title":"Cleanup","tags":[],"description":"","content":"To clean up the stacks from this workshop, navigate to the Cloudformation Console, select your stacks, and hit \u0026ldquo;Delete\u0026rdquo;. This may take some time.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/70-advanced-topics/100-pipelines/6000-cleanup.html","title":"Cleanup","tags":[],"description":"","content":"To clean up the stacks from this workshop, navigate to the Cloudformation Console, select your stacks, and hit \u0026ldquo;Delete\u0026rdquo;. This may take some time.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/20-create-project/200-virtualenv.html","title":"Activating the virtualenv","tags":[],"description":"","content":"Activating the Virtualenv The init script we ran in the last step created a bunch of code to help get us started but it also created a virtual environment within our directory. If you haven\u0026rsquo;t used virtualenv before, you can find out more here but the bottom line is that they allow you have a self-contained, isolated environment to run Python and install arbitrary packages without polluting your system Python.\nTo take advantage of the virtual environment that was created, you have to activate it within your shell. The generated README file provides all of this information but we are calling it out here because it is important. To activate your virtualenv on a Linux or MacOs platform:\nsource .venv/bin/activate On a Windows platform, you would use this:\n.venv\\Scripts\\activate.bat Now that the virtual environment is activated, you can safely install the required python modules.\npip install -r requirements.txt "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/70-advanced-topics/100-construct-testing/1000-assertion-test.html","title":"Assertion Tests","tags":[],"description":"","content":"Fine-Grained Assertion Tests Create a test for the DynamoDB table This section assumes that you have created the hit counter construct Our HitCounter construct creates a simple DynamoDB table. Lets create a test that validates that the table is getting created.\nIf cdk init created a test directory for you, then you should have a cdk-workshop.test.ts file. Delete this file.\nIf you do not already have a test directory (usually created automatically when you run cdk init), then create a test directory at the same level as bin and lib and then create a file called hitcounter.test.ts with the following code.\nimport { Template, Capture } from \u0026#39;aws-cdk-lib/assertions\u0026#39;; import * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import * as lambda from \u0026#39;aws-cdk-lib/aws-lambda\u0026#39;; import { HitCounter } from \u0026#39;../lib/hitcounter\u0026#39;; test(\u0026#39;DynamoDB Table Created\u0026#39;, () =\u0026gt; { const stack = new cdk.Stack(); // WHEN new HitCounter(stack, \u0026#39;MyTestConstruct\u0026#39;, { downstream: new lambda.Function(stack, \u0026#39;TestFunction\u0026#39;, { runtime: lambda.Runtime.NODEJS_14_X, handler: \u0026#39;hello.handler\u0026#39;, code: lambda.Code.fromAsset(\u0026#39;lambda\u0026#39;) }) }); // THEN const template = Template.fromStack(stack); template.resourceCountIs(\u0026#34;AWS::DynamoDB::Table\u0026#34;, 1); }); This test is simply testing to ensure that the synthesized stack includes a DynamoDB table.\nRun the test.\n$ npm run test You should see output like this:\n$ npm run test \u0026gt; cdk-workshop@0.1.0 test /home/aws-cdk-intro-workshop \u0026gt; jest PASS test/hitcounter.test.ts ✓ DynamoDB Table Created (182ms) Test Suites: 1 passed, 1 total Tests: 1 passed, 1 total Snapshots: 0 total Time: 3.273s Ran all test suites. Create a test for the Lambda function Now lets add another test, this time for the Lambda function that the HitCounter construct creates. This time in addition to testing that the Lambda function is created, we also want to test that it is created with the two environment variables DOWNSTREAM_FUNCTION_NAME \u0026amp; HITS_TABLE_NAME.\nAdd another test below the DynamoDB test. If you remember, when we created the lambda function the environment variable values were references to other constructs.\nthis.handler = new lambda.Function(this, \u0026#39;HitCounterHandler\u0026#39;, { runtime: lambda.Runtime.NODEJS_14_X, handler: \u0026#39;hitcounter.handler\u0026#39;, code: lambda.Code.fromAsset(\u0026#39;lambda\u0026#39;), environment: { DOWNSTREAM_FUNCTION_NAME: props.downstream.functionName, HITS_TABLE_NAME: table.tableName } }); At this point we don\u0026rsquo;t really know what the value of the functionName or tableName will be since the CDK will calculate a hash to append to the end of the name of the constructs, so we will just use a dummy value for now. Once we run the test it will fail and show us the expected value.\nCreate a new test in hitcounter.test.ts with the below code:\ntest(\u0026#39;Lambda Has Environment Variables\u0026#39;, () =\u0026gt; { const stack = new cdk.Stack(); // WHEN new HitCounter(stack, \u0026#39;MyTestConstruct\u0026#39;, { downstream: new lambda.Function(stack, \u0026#39;TestFunction\u0026#39;, { runtime: lambda.Runtime.NODEJS_14_X, handler: \u0026#39;hello.handler\u0026#39;, code: lambda.Code.fromAsset(\u0026#39;lambda\u0026#39;) }) }); // THEN const template = Template.fromStack(stack); const envCapture = new Capture(); template.hasResourceProperties(\u0026#34;AWS::Lambda::Function\u0026#34;, { Environment: envCapture, }); expect(envCapture.asObject()).toEqual( { Variables: { DOWNSTREAM_FUNCTION_NAME: { Ref: \u0026#34;TestFunctionXXXXX\u0026#34;, }, HITS_TABLE_NAME: { Ref: \u0026#34;MyTestConstructHitsXXXXX\u0026#34;, }, }, } ); }); Save the file and run the test again.\n$ npm run test This time the test should fail and you should be able to grab the correct value for the variables from the expected output.\n$ npm run test \u0026gt; cdk-workshop@0.1.0 test /home/aws-cdk-intro-workshop \u0026gt; jest FAIL test/hitcounter.test.ts ✓ DynamoDB Table Created (184ms) ✕ Lambda Has Environment Variables (53ms) ● Lambda Has Environment Variables expect(received).toEqual(expected) // deep equality - Expected - 2 + Received + 2 Object { \u0026#34;Variables\u0026#34;: Object { \u0026#34;DOWNSTREAM_FUNCTION_NAME\u0026#34;: Object { - \u0026#34;Ref\u0026#34;: \u0026#34;TestFunctionXXXXX\u0026#34;, + \u0026#34;Ref\u0026#34;: \u0026#34;TestFunction22AD90FC\u0026#34;, }, \u0026#34;HITS_TABLE_NAME\u0026#34;: Object { - \u0026#34;Ref\u0026#34;: \u0026#34;MyTestConstructHitsXXXXX\u0026#34;, + \u0026#34;Ref\u0026#34;: \u0026#34;MyTestConstructHits24A357F0\u0026#34;, }, }, } 37 | Environment: envCapture, 38 | }); \u0026gt; 39 | expect(envCapture.asObject()).toEqual( | ^ 40 | { 41 | Variables: { 42 | DOWNSTREAM_FUNCTION_NAME: { at Object.\u0026lt;anonymous\u0026gt; (test/hitcounter.test.ts:39:33) Test Suites: 1 failed, 1 total Tests: 1 failed, 1 passed, 2 total Snapshots: 0 total Time: 3.971 s, estimated 4 s Ran all test suites. Grab the real values for the environment variables and update your test\ntest(\u0026#39;Lambda Has Environment Variables\u0026#39;, () =\u0026gt; { const stack = new cdk.Stack(); // WHEN new HitCounter(stack, \u0026#39;MyTestConstruct\u0026#39;, { downstream: new lambda.Function(stack, \u0026#39;TestFunction\u0026#39;, { runtime: lambda.Runtime.NODEJS_14_X, handler: \u0026#39;hello.handler\u0026#39;, code: lambda.Code.fromAsset(\u0026#39;lambda\u0026#39;) }) }); // THEN const template = Template.fromStack(stack); const envCapture = new Capture(); template.hasResourceProperties(\u0026#34;AWS::Lambda::Function\u0026#34;, { Environment: envCapture, }); expect(envCapture.asObject()).toEqual( { Variables: { DOWNSTREAM_FUNCTION_NAME: { Ref: \u0026#34;VALUE_GOES_HERE\u0026#34;, }, HITS_TABLE_NAME: { Ref: \u0026#34;VALUE_GOES_HERE\u0026#34;, }, }, } ); }); Now run the test again. This time is should pass.\n$ npm run test You should see output like this:\n$ npm run test \u0026gt; cdk-workshop@0.1.0 test /home/aws-cdk-intro-workshop \u0026gt; jest PASS test/hitcounter.test.ts ✓ DynamoDB Table Created (182ms) ✓ Lambda Has Environment Variables (50ms) Test Suites: 1 passed, 1 total Tests: 2 passed, 2 total Snapshots: 0 total Time: 3.294s Ran all test suites. You can also apply TDD (Test Driven Development) to developing CDK Constructs. For a very simple example, lets add a new requirement that our DynamoDB table be encrypted.\nFirst we\u0026rsquo;ll update the test to reflect this new requirement.\nimport { Template, Capture } from \u0026#39;aws-cdk-lib/assertions\u0026#39;; import cdk = require(\u0026#39;aws-cdk-lib\u0026#39;); import * as lambda from \u0026#39;aws-cdk-lib/aws-lambda\u0026#39;; import { HitCounter } from \u0026#39;../lib/hitcounter\u0026#39;; test(\u0026#39;DynamoDB Table Created With Encryption\u0026#39;, () =\u0026gt; { const stack = new cdk.Stack(); // WHEN new HitCounter(stack, \u0026#39;MyTestConstruct\u0026#39;, { downstream: new lambda.Function(stack, \u0026#39;TestFunction\u0026#39;, { runtime: lambda.Runtime.NODEJS_14_X, handler: \u0026#39;hello.handler\u0026#39;, code: lambda.Code.fromAsset(\u0026#39;lambda\u0026#39;) }) }); // THEN const template = Template.fromStack(stack); template.hasResourceProperties(\u0026#39;AWS::DynamoDB::Table\u0026#39;, { SSESpecification: { SSEEnabled: true } }); }); Now run the test, which should fail.\n$ npm run test \u0026gt; cdk-workshop@0.1.0 test /home/aws-cdk-intro-workshop \u0026gt; jest FAIL test/hitcounter.test.ts ✓ DynamoDB Table Created (170ms) ✓ Lambda Has Environment Variables (50ms) ✕ DynamoDB Table Created With Encryption (49ms) ● DynamoDB Table Created With Encryption Template has 1 resources with type AWS::DynamoDB::Table, but none match as expected. The closest result is: { \u0026#34;Type\u0026#34;: \u0026#34;AWS::DynamoDB::Table\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;KeySchema\u0026#34;: [ { \u0026#34;AttributeName\u0026#34;: \u0026#34;path\u0026#34;, \u0026#34;KeyType\u0026#34;: \u0026#34;HASH\u0026#34; } ], \u0026#34;AttributeDefinitions\u0026#34;: [ { \u0026#34;AttributeName\u0026#34;: \u0026#34;path\u0026#34;, \u0026#34;AttributeType\u0026#34;: \u0026#34;S\u0026#34; } ], \u0026#34;ProvisionedThroughput\u0026#34;: { \u0026#34;ReadCapacityUnits\u0026#34;: 5, \u0026#34;WriteCapacityUnits\u0026#34;: 5 } }, \u0026#34;UpdateReplacePolicy\u0026#34;: \u0026#34;Retain\u0026#34;, \u0026#34;DeletionPolicy\u0026#34;: \u0026#34;Retain\u0026#34; } with the following mismatches: Missing key at /Properties/SSESpecification (using objectLike matcher) 63 | 64 | const template = Template.fromStack(stack); \u0026gt; 65 | template.hasResourceProperties(\u0026#34;AWS::DynamoDB::Table\u0026#34;, { | ^ 66 | SSESpecification: { 67 | SSEEnabled: true 68 | } at Template.hasResourceProperties (node_modules/aws-cdk-lib/assertions/lib/template.ts:50:13) at Object.\u0026lt;anonymous\u0026gt; (test/hitcounter.test.ts:65:12) Test Suites: 1 failed, 1 total Tests: 1 failed, 3 passed, 4 total Snapshots: 0 total Time: 3.947 s, estimated 4 s Ran all test suites. Now lets fix the broken test. Update the hitcounter code to enable encryption by default.\nexport class HitCounter extends Construct { /** allows accessing the counter function */ public readonly handler: lambda.Function; /** the hit counter table */ public readonly table: dynamodb.Table; constructor(scope: Construct, id: string, props: HitCounterProps) { super(scope, id); const table = new dynamodb.Table(this, \u0026#39;Hits\u0026#39;, { partitionKey: { name: \u0026#39;path\u0026#39;, type: dynamodb.AttributeType.STRING }, encryption: dynamodb.TableEncryption.AWS_MANAGED }); ... } } Now run the test again, which should now pass.\nnpm run test \u0026gt; cdk-workshop@0.1.0 test /home/aws-cdk-intro-workshop \u0026gt; jest PASS test/hitcounter.test.ts ✓ DynamoDB Table Created (171ms) ✓ Lambda Has Environment Variables (52ms) ✓ DynamoDB Table Created With Encryption (47ms) Test Suites: 1 passed, 1 total Tests: 3 passed, 3 total Snapshots: 0 total Time: 3.913s Ran all test suites. "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/70-advanced-topics/100-construct-testing/1000-assertion-test.html","title":"Assertion Tests","tags":[],"description":"","content":"Fine-Grained Assertion Tests Create a test for the DynamoDB table This section assumes that you have created the hit counter construct Our HitCounter construct creates a simple DynamoDB table. Lets create a test that validates that the table is getting created.\nIf you have create the project with cdk init then you should already have a tests directory. In that case you will need to remove the existing test_cdk_workshop_stack.py file.\nIf you do not already have a tests directory (usually created automatically when you run cdk init), then create a tests directory at the root of the project and then create the following files:\nmkdir -p tests/unit touch tests/__init__.py touch tests/unit/__init__.py touch tests/unit/test_cdk_workshop.py In the file called test_cdk_workshop.py create your first test using the following code.\nfrom aws_cdk import ( Stack, aws_lambda as _lambda, assertions ) from cdk_workshop.hitcounter import HitCounter import pytest def test_dynamodb_table_created(): stack = Stack() HitCounter(stack, \u0026#34;HitCounter\u0026#34;, downstream=_lambda.Function(stack, \u0026#34;TestFunction\u0026#34;, runtime=_lambda.Runtime.PYTHON_3_7, handler=\u0026#39;hello.handler\u0026#39;, code=_lambda.Code.from_asset(\u0026#39;lambda\u0026#39;)), ) template = assertions.Template.from_stack(stack) template.resource_count_is(\u0026#34;AWS::DynamoDB::Table\u0026#34;, 1) This test is simply testing to ensure that the synthesized stack includes a DynamoDB table.\nRun the test.\n$ pytest You should see output like this:\n$ pytest ================================================================================================= test session starts ================================================================================================= platform linux -- Python 3.9.6, pytest-6.2.5, py-1.10.0, pluggy-1.0.0 rootdir: ... collected 1 item tests/unit/test_cdk_workshop.py . [100%] ================================================================================================== 1 passed in 1.49s ================================================================================================== Create a test for the Lambda function Now lets add another test, this time for the Lambda function that the HitCounter construct creates. This time in addition to testing that the Lambda function is created, we also want to test that it is created with the two environment variables DOWNSTREAM_FUNCTION_NAME \u0026amp; HITS_TABLE_NAME.\nAdd another test below the DynamoDB test. If you remember, when we created the lambda function the environment variable values were references to other constructs.\nself._handler = _lambda.Function( self, \u0026#39;HitCounterHandler\u0026#39;, runtime=_lambda.Runtime.PYTHON_3_7, handler=\u0026#39;hitcount.handler\u0026#39;, code=_lambda.Code.from_asset(\u0026#39;lambda\u0026#39;), environment={ \u0026#39;DOWNSTREAM_FUNCTION_NAME\u0026#39;: downstream.function_name, \u0026#39;HITS_TABLE_NAME\u0026#39;: self._table.table_name } ) At this point we don\u0026rsquo;t really know what the value of the function_name or table_name will be since the CDK will calculate a hash to append to the end of the name of the constructs, so we will just use a dummy value for now. Once we run the test it will fail and show us the expected value.\nCreate a new test in test_cdk_workshop.py with the below code:\ndef test_lambda_has_env_vars(): stack = Stack() HitCounter(stack, \u0026#34;HitCounter\u0026#34;, downstream=_lambda.Function(stack, \u0026#34;TestFunction\u0026#34;, runtime=_lambda.Runtime.PYTHON_3_7, handler=\u0026#39;hello.handler\u0026#39;, code=_lambda.Code.from_asset(\u0026#39;lambda\u0026#39;))) template = assertions.Template.from_stack(stack) envCapture = assertions.Capture() template.has_resource_properties(\u0026#34;AWS::Lambda::Function\u0026#34;, { \u0026#34;Handler\u0026#34;: \u0026#34;hitcount.handler\u0026#34;, \u0026#34;Environment\u0026#34;: envCapture, }) assert envCapture.as_object() == { \u0026#34;Variables\u0026#34;: { \u0026#34;DOWNSTREAM_FUNCTION_NAME\u0026#34;: {\u0026#34;Ref\u0026#34;: \u0026#34;TestFunctionXXXXX\u0026#34;}, \u0026#34;HITS_TABLE_NAME\u0026#34;: {\u0026#34;Ref\u0026#34;: \u0026#34;HitCounterHitsXXXXXX\u0026#34;}, }, } Save the file and run the test again.\npytest This time the test should fail and you should be able to grab the correct value for the variables from the expected output.\n$ pytest ================================================================================================= test session starts ================================================================================================= platform linux -- Python 3.9.6, pytest-6.2.5, py-1.10.0, pluggy-1.0.0 rootdir: ... collected 2 items tests/unit/test_cdk_workshop.py .F [100%] ====================================================================================================== FAILURES ======================================================================================================= ______________________________________________________________________________________________ test_lambda_has_env_vars _______________________________________________________________________________________________ ... E AssertionError: assert {\u0026#39;Variables\u0026#39;:...ts079767E5\u0026#39;}}} == {\u0026#39;Variables\u0026#39;:...tsXXXXXXXX\u0026#39;}}} E Differing items: E {\u0026#39;Variables\u0026#39;: {\u0026#39;DOWNSTREAM_FUNCTION_NAME\u0026#39;: {\u0026#39;Ref\u0026#39;: \u0026#39;TestFunction22AD90FC\u0026#39;}, \u0026#39;HITS_TABLE_NAME\u0026#39;: {\u0026#39;Ref\u0026#39;: \u0026#39;HitCounterHits079767E5\u0026#39;}}} != {\u0026#39;Variables\u0026#39;: {\u0026#39;DOWNSTREAM_FUNCTION_NAME\u0026#39;: {\u0026#39;Ref\u0026#39;: \u0026#39;TestFunctionXXXXXXXX\u0026#39;}, \u0026#39;HITS_TABLE_NAME\u0026#39;: {\u0026#39;Ref\u0026#39;: \u0026#39;HitCounterHitsXXXXXXXX\u0026#39;}}} E Use -v to get the full diff tests/unit/test_cdk_workshop.py:35: AssertionError =============================================================================================== short test summary info =============================================================================================== FAILED tests/unit/test_cdk_workshop.py::test_lambda_has_env_vars - AssertionError: assert {\u0026#39;Variables\u0026#39;:...ts079767E5\u0026#39;}}} == {\u0026#39;Variables\u0026#39;:...tsXXXXXXXX\u0026#39;}}} ============================================================================================= 1 failed, 1 passed in 1.60s ============================================================================================= Grab the real values for the environment variables and update your test\ndef test_lambda_has_env_vars(): stack = Stack() HitCounter(stack, \u0026#34;HitCounter\u0026#34;, downstream=_lambda.Function(stack, \u0026#34;TestFunction\u0026#34;, runtime=_lambda.Runtime.PYTHON_3_7, handler=\u0026#39;hello.handler\u0026#39;, code=_lambda.Code.from_asset(\u0026#39;lambda\u0026#39;))) template = assertions.Template.from_stack(stack) envCapture = assertions.Capture() template.has_resource_properties(\u0026#34;AWS::Lambda::Function\u0026#34;, { \u0026#34;Handler\u0026#34;: \u0026#34;hitcount.handler\u0026#34;, \u0026#34;Environment\u0026#34;: envCapture, }) assert envCapture.as_object() == { \u0026#34;Variables\u0026#34;: { \u0026#34;DOWNSTREAM_FUNCTION_NAME\u0026#34;: {\u0026#34;Ref\u0026#34;: \u0026#34;REPLACE_VALUE_HERE\u0026#34;}, \u0026#34;HITS_TABLE_NAME\u0026#34;: {\u0026#34;Ref\u0026#34;: \u0026#34;REPLACE_VALUE_HERE\u0026#34;}, }, } Now run the test again. This time is should pass.\n$ pytest You should see output like this:\n$ pytest ================================================================================================= test session starts ================================================================================================= platform linux -- Python 3.9.6, pytest-6.2.5, py-1.10.0, pluggy-1.0.0 rootdir: ... collected 2 items tests/unit/test_cdk_workshop.py .. [100%] ================================================================================================== 2 passed in 1.58s ================================================================================================== You can also apply TDD (Test Driven Development) to developing CDK Constructs. For a very simple example, lets add a new requirement that our DynamoDB table be encrypted.\nFirst we\u0026rsquo;ll update the test to reflect this new requirement.\ndef test_dynamodb_with_encryption(): stack = Stack() HitCounter(stack, \u0026#34;HitCounter\u0026#34;, downstream=_lambda.Function(stack, \u0026#34;TestFunction\u0026#34;, runtime=_lambda.Runtime.PYTHON_3_7, handler=\u0026#39;hello.handler\u0026#39;, code=_lambda.Code.from_asset(\u0026#39;lambda\u0026#39;))) template = assertions.Template.from_stack(stack) template.has_resource_properties(\u0026#34;AWS::DynamoDB::Table\u0026#34;, { \u0026#34;SSESpecification\u0026#34;: { \u0026#34;SSEEnabled\u0026#34;: True, }, }) Now run the test, which should fail.\n$ pytest ================================================================================================= test session starts ================================================================================================= platform linux -- Python 3.9.6, pytest-6.2.5, py-1.10.0, pluggy-1.0.0 rootdir: ... collected 3 items tests/unit/test_cdk_workshop.py ..F [100%] ====================================================================================================== FAILURES ======================================================================================================= ____________________________________________________________________________________________ test_dynamodb_with_encryption ____________________________________________________________________________________________ jsii.errors.JavaScriptError: Error: Template has 1 resources with type AWS::DynamoDB::Table, but none match as expected. The closest result is: { \u0026#34;Type\u0026#34;: \u0026#34;AWS::DynamoDB::Table\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;KeySchema\u0026#34;: [ { \u0026#34;AttributeName\u0026#34;: \u0026#34;path\u0026#34;, \u0026#34;KeyType\u0026#34;: \u0026#34;HASH\u0026#34; } ], \u0026#34;AttributeDefinitions\u0026#34;: [ { \u0026#34;AttributeName\u0026#34;: \u0026#34;path\u0026#34;, \u0026#34;AttributeType\u0026#34;: \u0026#34;S\u0026#34; } ], \u0026#34;ProvisionedThroughput\u0026#34;: { \u0026#34;ReadCapacityUnits\u0026#34;: 5, \u0026#34;WriteCapacityUnits\u0026#34;: 5 } }, \u0026#34;UpdateReplacePolicy\u0026#34;: \u0026#34;Retain\u0026#34;, \u0026#34;DeletionPolicy\u0026#34;: \u0026#34;Retain\u0026#34; } with the following mismatches: Missing key at /Properties/SSESpecification (using objectLike matcher) at Template.hasResourceProperties (/tmp/jsii-kernel-4Be5Dy/node_modules/@aws-cdk/assertions/lib/template.js:85:19) at /tmp/tmpdj0kczj7/lib/program.js:8248:134 at Kernel._wrapSandboxCode (/tmp/tmpdj0kczj7/lib/program.js:8860:24) at /tmp/tmpdj0kczj7/lib/program.js:8248:107 at Kernel._ensureSync (/tmp/tmpdj0kczj7/lib/program.js:8841:28) at Kernel.invoke (/tmp/tmpdj0kczj7/lib/program.js:8248:34) at KernelHost.processRequest (/tmp/tmpdj0kczj7/lib/program.js:9757:36) at KernelHost.run (/tmp/tmpdj0kczj7/lib/program.js:9720:22) at Immediate._onImmediate (/tmp/tmpdj0kczj7/lib/program.js:9721:46) at processImmediate (internal/timers.js:464:21) The above exception was the direct cause of the following exception: ...more error info... =============================================================================================== short test summary info =============================================================================================== FAILED tests/unit/test_cdk_workshop.py::test_dynamodb_with_encryption - jsii.errors.JSIIError: Template has 1 resources with type AWS::DynamoDB::Table, but none match as expected. ============================================================================================= 1 failed, 2 passed in 1.65s ============================================================================================= Now lets fix the broken test. Update the hitcounter code to enable encryption by default.\nEdit hitcounter.py self._table = ddb.Table( self, \u0026#39;Hits\u0026#39;, partition_key={\u0026#39;name\u0026#39;: \u0026#39;path\u0026#39;, \u0026#39;type\u0026#39;: ddb.AttributeType.STRING}, encryption=ddb.TableEncryption.AWS_MANAGED, )\nNow run the test again, which should now pass.\n$ pytest ================================================================================================= test session starts ================================================================================================= platform linux -- Python 3.9.6, pytest-6.2.5, py-1.10.0, pluggy-1.0.0 rootdir: ... collected 3 items tests/unit/test_cdk_workshop.py ... [100%] ================================================================================================== 3 passed in 1.59s ================================================================================================== "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/70-advanced-topics/100-construct-testing/1000-assertion-test.html","title":"Assertion Tests","tags":[],"description":"","content":"Fine-Grained Assertion Tests Create a test for the DynamoDB table This section assumes that you have created the hit counter construct Our HitCounter construct creates a simple DynamoDB table. Lets create a test that validates that the table is getting created.\nSince we removed the src/test directory (usually created automatically when you run cdk init), we need to create a new test directory under src:\nmkdir -p src/test/java/com/myorg And then create a file called HitCounterTest.java with the following code.\npackage com.myorg; import software.amazon.awscdk.Stack; import software.amazon.awscdk.assertions.Template; import software.amazon.awscdk.assertions.Capture; import java.io.IOException; import software.amazon.awscdk.services.lambda.Code; import software.amazon.awscdk.services.lambda.Function; import software.amazon.awscdk.services.lambda.Runtime; import java.util.Map; import static org.assertj.core.api.Assertions.assertThat; import static org.junit.jupiter.api.Assertions.assertThrows; import org.junit.jupiter.api.Test; public class HitCounterTest { @Test public void testDynamoDBTable() throws IOException { Stack stack = new Stack(); Function hello = Function.Builder.create(stack, \u0026#34;HelloHandler\u0026#34;) .runtime(Runtime.NODEJS_14_X) .code(Code.fromAsset(\u0026#34;lambda\u0026#34;)) .handler(\u0026#34;hello.handler\u0026#34;) .build(); HitCounter helloWithCounter = new HitCounter(stack, \u0026#34;HelloHitCounter\u0026#34;, HitCounterProps.builder() .downstream(hello) .build()); // synthesize the stack to a CloudFormation template Template template = Template.fromStack(stack); template.resourceCountIs(\u0026#34;AWS::DynamoDB::Table\u0026#34;, 1); } } This test is simply testing to ensure that the synthesized stack includes a DynamoDB table.\nRun the test.\n$ mvn test You should see output like this:\n$ mvn test ...building info... ------------------------------------------------------- T E S T S ------------------------------------------------------- Running com.myorg.HitCounterTest Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.644 sec Results : Tests run: 1, Failures: 0, Errors: 0, Skipped: 0 [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 9.316 s [INFO] Finished at: 2021-10-29T20:02:43Z [INFO] ------------------------------------------------------------------------ Create a test for the Lambda function Now lets add another test, this time for the Lambda function that the HitCounter construct creates. This time in addition to testing that the Lambda function is created, we also want to test that it is created with the two environment variables DOWNSTREAM_FUNCTION_NAME \u0026amp; HITS_TABLE_NAME.\nAdd another test below the DynamoDB test. If you remember, when we created the lambda function the environment variable values were references to other constructs.\nfinal Map\u0026lt;String, String\u0026gt; environment = new HashMap\u0026lt;\u0026gt;(); environment.put(\u0026#34;DOWNSTREAM_FUNCTION_NAME\u0026#34;, props.getDownstream().getFunctionName()); environment.put(\u0026#34;HITS_TABLE_NAME\u0026#34;, this.table.getTableName()); this.handler = Function.Builder.create(this, \u0026#34;HitCounterHandler\u0026#34;) .runtime(Runtime.NODEJS_14_X) .handler(\u0026#34;hitcounter.handler\u0026#34;) .code(Code.fromAsset(\u0026#34;lambda\u0026#34;)) .environment(environment) .build(); At this point we don\u0026rsquo;t really know what the value of the functionName or tableName will be since the CDK will calculate a hash to append to the end of the name of the constructs, so we will just use a dummy value for now. Once we run the test it will fail and show us the expected value.\nCreate a new test in HitCounterTest.Java with the below code:\n@Test public void testLambdaEnvVars() throws IOException { Stack stack = new Stack(); Function hello = Function.Builder.create(stack, \u0026#34;HelloHandler\u0026#34;) .runtime(Runtime.NODEJS_14_X) .code(Code.fromAsset(\u0026#34;lambda\u0026#34;)) .handler(\u0026#34;hello.handler\u0026#34;) .build(); HitCounter helloWithCounter = new HitCounter(stack, \u0026#34;HelloHitCounter\u0026#34;, HitCounterProps.builder() .downstream(hello) .build()); // synthesize the stack to a CloudFormation template Template template = Template.fromStack(stack); Capture envCapture = new Capture(); Map\u0026lt;String, Object\u0026gt; expected = Map.of( \u0026#34;Handler\u0026#34;, \u0026#34;hitcounter.handler\u0026#34;, \u0026#34;Environment\u0026#34;, envCapture); template.hasResourceProperties(\u0026#34;AWS::Lambda::Function\u0026#34;, expected); Map\u0026lt;String, Object\u0026gt; expectedEnv = Map.of( \u0026#34;Variables\u0026#34;, Map.of( \u0026#34;DOWNSTREAM_FUNCTION_NAME\u0026#34;, Map.of(\u0026#34;Ref\u0026#34;, \u0026#34;HelloHandlerXXXXXXXXX\u0026#34;), \u0026#34;HITS_TABLE_NAME\u0026#34;, Map.of(\u0026#34;Ref\u0026#34;, \u0026#34;HelloHitCounterHitsXXXXXXXXX\u0026#34;) ) ); assertThat(envCapture.asObject()).isEqualTo(expectedEnv); } Save the file and run the test again.\n$ mvn test This time the test should fail and you should be able to grab the correct value for the variables from the expected output.\n$ mvn test ------------------------------------------------------- T E S T S ------------------------------------------------------- Running com.myorg.HitCounterTest Tests run: 2, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 1.792 sec \u0026lt;\u0026lt;\u0026lt; FAILURE! com.myorg.HitCounterTest.testLambdaEnvVars() Time elapsed: 0.106 sec \u0026lt;\u0026lt;\u0026lt; FAILURE! org.opentest4j.AssertionFailedError: Expecting: \u0026lt;{\u0026#34;Variables\u0026#34;={\u0026#34;DOWNSTREAM_FUNCTION_NAME\u0026#34;={\u0026#34;Ref\u0026#34;=\u0026#34;HelloHandler2E4FBA4D\u0026#34;}, \u0026#34;HITS_TABLE_NAME\u0026#34;={\u0026#34;Ref\u0026#34;=\u0026#34;HelloHitCounterHits7AAEBF80\u0026#34;}}}\u0026gt; to be equal to: \u0026lt;{\u0026#34;Variables\u0026#34;={\u0026#34;DOWNSTREAM_FUNCTION_NAME\u0026#34;={\u0026#34;Ref\u0026#34;=\u0026#34;HelloHandlerXXXXXXXXX\u0026#34;}, \u0026#34;HITS_TABLE_NAME\u0026#34;={\u0026#34;Ref\u0026#34;=\u0026#34;HelloHitCounterHitsXXXXXXXXX\u0026#34;}}}\u0026gt; but was not. at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:78) at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499) at com.myorg.HitCounterTest.testLambdaEnvVars(HitCounterTest.java:70) Results : Failed tests: com.myorg.HitCounterTest.testLambdaEnvVars(): (..) Tests run: 2, Failures: 1, Errors: 0, Skipped: 0 [INFO] ------------------------------------------------------------------------ [INFO] BUILD FAILURE [INFO] ------------------------------------------------------------------------ [INFO] Total time: 13.296 s [INFO] Finished at: 2021-11-01T12:37:23Z [INFO] ------------------------------------------------------------------------ Grab the real values for the environment variables and update your test\n@Test public void testLambdaEnvVars() throws IOException { Stack stack = new Stack(); Function hello = Function.Builder.create(stack, \u0026#34;HelloHandler\u0026#34;) .runtime(Runtime.NODEJS_14_X) .code(Code.fromAsset(\u0026#34;lambda\u0026#34;)) .handler(\u0026#34;hello.handler\u0026#34;) .build(); HitCounter helloWithCounter = new HitCounter(stack, \u0026#34;HelloHitCounter\u0026#34;, HitCounterProps.builder() .downstream(hello) .build()); // synthesize the stack to a CloudFormation template Template template = Template.fromStack(stack); Capture envCapture = new Capture(); Map\u0026lt;String, Object\u0026gt; expected = Map.of( \u0026#34;Handler\u0026#34;, \u0026#34;hitcounter.handler\u0026#34;, \u0026#34;Environment\u0026#34;, envCapture); template.hasResourceProperties(\u0026#34;AWS::Lambda::Function\u0026#34;, expected); Map\u0026lt;String, Object\u0026gt; expectedEnv = Map.of( \u0026#34;Variables\u0026#34;, Map.of( \u0026#34;DOWNSTREAM_FUNCTION_NAME\u0026#34;, Map.of(\u0026#34;Ref\u0026#34;, \u0026#34;REPLACE_VALUE_HERE\u0026#34;), \u0026#34;HITS_TABLE_NAME\u0026#34;, Map.of(\u0026#34;Ref\u0026#34;, \u0026#34;REPLACE_VALUE_HERE\u0026#34;) ) ); assertThat(envCapture.asObject()).isEqualTo(expectedEnv); } Now run the test again. This time is should pass.\n$ mvn test You should see output like this:\n$ mvn test ------------------------------------------------------- T E S T S ------------------------------------------------------- Running com.myorg.HitCounterTest Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.785 sec Results : Tests run: 2, Failures: 0, Errors: 0, Skipped: 0 [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 9.571 s [INFO] Finished at: 2021-11-01T12:42:03Z [INFO] ------------------------------------------------------------------------ You can also apply TDD (Test Driven Development) to developing CDK Constructs. For a very simple example, lets add a new requirement that our DynamoDB table be encrypted.\nFirst we\u0026rsquo;ll update the test to reflect this new requirement.\n@Test public void testDynamoDBEncryption() throws IOException { Stack stack = new Stack(); Function hello = Function.Builder.create(stack, \u0026#34;HelloHandler\u0026#34;) .runtime(Runtime.NODEJS_14_X) .code(Code.fromAsset(\u0026#34;lambda\u0026#34;)) .handler(\u0026#34;hello.handler\u0026#34;) .build(); HitCounter helloWithCounter = new HitCounter(stack, \u0026#34;HelloHitCounter\u0026#34;, HitCounterProps.builder() .downstream(hello) .build()); // synthesize the stack to a CloudFormation template Template template = Template.fromStack(stack); Capture envCapture = new Capture(); Map\u0026lt;String, Object\u0026gt; expected = Map.of( \u0026#34;SSESpecification\u0026#34;, Map.of(\u0026#34;SSEEnabled\u0026#34;, true)); template.hasResourceProperties(\u0026#34;AWS::DynamoDB::Table\u0026#34;, expected); } Now run the test, which should fail.\n$ mvn test ------------------------------------------------------- T E S T S ------------------------------------------------------- Running com.myorg.HitCounterTest Tests run: 3, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 1.805 sec \u0026lt;\u0026lt;\u0026lt; FAILURE! com.myorg.HitCounterTest.testDynamoDBEncryption() Time elapsed: 0.043 sec \u0026lt;\u0026lt;\u0026lt; FAILURE! software.amazon.jsii.JsiiException: Template has 1 resources with type AWS::DynamoDB::Table, but none match as expected. The closest result is: { \u0026#34;Type\u0026#34;: \u0026#34;AWS::DynamoDB::Table\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;KeySchema\u0026#34;: [ { \u0026#34;AttributeName\u0026#34;: \u0026#34;path\u0026#34;, \u0026#34;KeyType\u0026#34;: \u0026#34;HASH\u0026#34; } ], \u0026#34;AttributeDefinitions\u0026#34;: [ { \u0026#34;AttributeName\u0026#34;: \u0026#34;path\u0026#34;, \u0026#34;AttributeType\u0026#34;: \u0026#34;S\u0026#34; } ], \u0026#34;ProvisionedThroughput\u0026#34;: { \u0026#34;ReadCapacityUnits\u0026#34;: 5, \u0026#34;WriteCapacityUnits\u0026#34;: 5 } }, \u0026#34;UpdateReplacePolicy\u0026#34;: \u0026#34;Retain\u0026#34;, \u0026#34;DeletionPolicy\u0026#34;: \u0026#34;Retain\u0026#34; } with the following mismatches: Missing key at /Properties/SSESpecification (using objectLike matcher) Error: Template has 1 resources with type AWS::DynamoDB::Table, but none match as expected. The closest result is: { \u0026#34;Type\u0026#34;: \u0026#34;AWS::DynamoDB::Table\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;KeySchema\u0026#34;: [ { \u0026#34;AttributeName\u0026#34;: \u0026#34;path\u0026#34;, \u0026#34;KeyType\u0026#34;: \u0026#34;HASH\u0026#34; } ], \u0026#34;AttributeDefinitions\u0026#34;: [ { \u0026#34;AttributeName\u0026#34;: \u0026#34;path\u0026#34;, \u0026#34;AttributeType\u0026#34;: \u0026#34;S\u0026#34; } ], \u0026#34;ProvisionedThroughput\u0026#34;: { \u0026#34;ReadCapacityUnits\u0026#34;: 5, \u0026#34;WriteCapacityUnits\u0026#34;: 5 } }, \u0026#34;UpdateReplacePolicy\u0026#34;: \u0026#34;Retain\u0026#34;, \u0026#34;DeletionPolicy\u0026#34;: \u0026#34;Retain\u0026#34; } with the following mismatches: Missing key at /Properties/SSESpecification (using objectLike matcher) Results : Failed tests: com.myorg.HitCounterTest.testDynamoDBEncryption(): Template has 1 resources with type AWS::DynamoDB::Table, but none match as expected.(..) Tests run: 3, Failures: 1, Errors: 0, Skipped: 0 [INFO] ------------------------------------------------------------------------ [INFO] BUILD FAILURE [INFO] ------------------------------------------------------------------------ [INFO] Total time: 10.141 s [INFO] Finished at: 2021-11-01T12:44:41Z [INFO] ------------------------------------------------------------------------ Now lets fix the broken test. Update the hitcounter code to enable encryption by default.\npackage com.myorg; import java.util.HashMap; import java.util.Map; import software.constructs.Construct; import software.amazon.awscdk.services.dynamodb.Attribute; import software.amazon.awscdk.services.dynamodb.AttributeType; import software.amazon.awscdk.services.dynamodb.Table; import software.amazon.awscdk.services.dynamodb.TableEncryption; import software.amazon.awscdk.services.lambda.Code; import software.amazon.awscdk.services.lambda.Function; import software.amazon.awscdk.services.lambda.Runtime; public class HitCounter extends Construct { private final Function handler; private final Table table; public HitCounter(final Construct scope, final String id, final HitCounterProps props) { super(scope, id); this.table = Table.Builder.create(this, \u0026#34;Hits\u0026#34;) .partitionKey(Attribute.builder() .name(\u0026#34;path\u0026#34;) .type(AttributeType.STRING) .build()) .encryption(TableEncryption.AWS_MANAGED) .build(); final Map\u0026lt;String, String\u0026gt; environment = new HashMap\u0026lt;\u0026gt;(); environment.put(\u0026#34;DOWNSTREAM_FUNCTION_NAME\u0026#34;, props.getDownstream().getFunctionName()); environment.put(\u0026#34;HITS_TABLE_NAME\u0026#34;, this.table.getTableName()); this.handler = Function.Builder.create(this, \u0026#34;HitCounterHandler\u0026#34;) .runtime(Runtime.NODEJS_14_X) .handler(\u0026#34;hitcounter.handler\u0026#34;) .code(Code.fromAsset(\u0026#34;lambda\u0026#34;)) .environment(environment) .build(); } /** * @return the counter definition */ public Function getHandler() { return this.handler; } /** * @return the counter table */ public Table getTable() { return this.table; } } Now run the test again, which should now pass.\n$ mvn test ------------------------------------------------------- T E S T S ------------------------------------------------------- Running com.myorg.HitCounterTest Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.807 sec Results : Tests run: 3, Failures: 0, Errors: 0, Skipped: 0 [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 10.072 s [INFO] Finished at: 2021-11-01T12:46:58Z [INFO] ------------------------------------------------------------------------ "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/15-prerequisites/200-account.html","title":"AWS Account and User","tags":[],"description":"","content":"AWS Account for Experimentation To deploy our app, you\u0026rsquo;ll need access to an AWS account. If you already have an account and your system is configured with credentials of an administrator user, you can move to the next step.\nIf you are using an existing account, either personal or a company account, make sure you understand the implications and policy of provisioning resources into this account.\nIf you don\u0026rsquo;t have an AWS account, you can create a free account here.\nAdministrator User Sign in to your AWS account\nGo to the AWS IAM console and create a new user.\nType a name for your user (e.g. cdk-workshop) and choose \u0026ldquo;Programmatic access\u0026rdquo;.\nClick Next: Permissions to continue to the next step.\nClick Attach existing policies directly and choose AdministratorAccess.\nClick Next: Review\nClick Next: Tags\nClick Create User\nIn the next screen, you\u0026rsquo;ll see your Access key ID and you will have the option to click Show to show the Secret access key. Keep this browser window open.\nConfigure your credentials Open a terminal window and use aws configure to set up your environment. Type the access key ID and secret key and choose a default region (you can use us-east-1, eu-west-1, us-west-2 for example). Preferably use a region that doesn\u0026rsquo;t have any resources already deployed into it.\naws configure And fill in the information from the console:\nAWS Access Key ID [None]: \u0026lt;type key ID here\u0026gt; AWS Secret Access Key [None]: \u0026lt;type access key\u0026gt; Default region name [None]: \u0026lt;choose region (e.g. \u0026#34;us-east-1\u0026#34;, \u0026#34;eu-west-1\u0026#34;)\u0026gt; Default output format [None]: \u0026lt;leave blank\u0026gt; "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/70-advanced-topics/200-pipelines.html","title":"CDK Pipelines","tags":[],"description":"","content":"CDK Pipelines In this chapter we will create a Continuous Deployment (CD) pipeline for the app developed in previous chapters.\nCD is an important component to most web project, but can be challenging to set up with all the moving parts required. The CDK Pipelines construct makes that process easy and streamlined from within your existing CDK infrastructure design.\nThese pipelines consist of \u0026ldquo;stages\u0026rdquo; that represent the phases of your deployment process from how the source code is managed, to how the fully built artifacts are deployed.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/70-advanced-topics/200-pipelines.html","title":"CDK Pipelines","tags":[],"description":"","content":"CDK Pipelines In this chapter we will create a Continuous Deployment (CD) pipeline for the app developed in previous chapters.\nCD is an important component to most web projects, but can be challenging to set up with all the moving parts required. The CDK Pipelines construct makes that proccess easy and streamlined from within your existing CDK infrastructure design.\nThese pipelines consist of \u0026ldquo;stages\u0026rdquo; that represent the phases of your deployment process from how the source code is managed, to how the fully built artifacts are deployed.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/30-hello-cdk/200-lambda.html","title":"Hello Lambda","tags":[],"description":"","content":"Lambda handler code まずは、Lambda handlerのコードから書いていきます。\ncdk-workshopディレクトリにlambdaディレクトリを作成します。 TS CDK プロジェクトを cdk init で作成すると、デフォルトではすべての .js ファイルを無視します。 これらのファイルをgitで追跡するには、 .gitignore ファイルに !lambda/*.js を追記してください。 これにより、このチュートリアルのパイプラインのセクションで、Lambdaアセットを発見することができます。 lambda/hello.jsというファイルを追加し、以下の内容を記述します。 exports.handler = async function(event) { console.log(\u0026#34;request:\u0026#34;, JSON.stringify(event, undefined, 2)); return { statusCode: 200, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/plain\u0026#34; }, body: `Hello, CDK! You\u0026#39;ve hit ${event.path}\\n` }; }; これは、**「Hello, CDK! You’ve hit [url path]」**というテキストを返す単純なLambda関数です。 HTTPステータスコードとHTTPヘッダーが付加されたHTTPレスポンスとしてユーザーに応答するために、API Gatewayを使用します。\nこのLambda関数はJavaScriptで実装されています。 その他の言語での実装についてはAWS Lambdaのドキュメントを参照してください。\nコピー＆ペーストは使わずにコードを書いてみましょう このワークショップでは、コピー\u0026amp;ペーストをするのではなく、実際にCDKのコードを入力することを強く推奨します（通常、入力する量は多くありません）。 これにより、CDKの使い方についてより理解していただけます。 IDEがオートコンプリート、インラインドキュメント、およびタイプセーフに対応しているのがご理解いただけるでしょう。\nAWS Lambda関数をスタックに追加する importステートメントをlib/cdk-workshop-stack.tsの冒頭に挿入し、lambda.Functionをスタックに追加します。\nimport { Stack, StackProps } from \u0026#39;aws-cdk-lib\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; import * as lambda from \u0026#39;aws-cdk-lib/aws-lambda\u0026#39; export class CdkWorkshopStack extends Stack { constructor(scope: Construct, id: string, props?: StackProps) { super(scope, id, props); // defines an AWS Lambda resource const hello = new lambda.Function(this, \u0026#39;HelloHandler\u0026#39;, { runtime: lambda.Runtime.NODEJS_16_X, // execution environment code: lambda.Code.fromAsset(\u0026#39;lambda\u0026#39;), // code loaded from \u0026#34;lambda\u0026#34; directory handler: \u0026#39;hello.handler\u0026#39;, // file is \u0026#34;hello\u0026#34;, function is \u0026#34;handler\u0026#34; }); } } 注目すべきいくつかの点：\nこの関数はNODEJS_16_X(Nodejs v16.x)ランタイムを使用します。 ハンドラーコードは、先程作った lambda ディレクトリからロードされます。 パスは、cdk コマンドが実行されたディレクトリから相対パスです。 ハンドラー関数の名前は hello.handler （「hello」はファイル名、「handler」は関数名です） コンストラクト(constructs) と コンストラクター(constructors) について ご覧のとおり、CdkWorkshopStackとlambda.Functionの両方のコンストラクタークラス（およびCDKの他の多くのクラス）は(scope, id, props)という同じような引数を受け取ります。 これは、これらのクラスがすべてコンストラクタであるためです。 コンストラクトはCDKアプリの基本的な構成要素です。 それらは「クラウドコンポーネント」を表現します。クラウドコンポーネントはスコープを介してより高いレベルの抽象化に構築できます。 スコープにはコンストラクトを含めることができ、そのコンストラクトには他のコンストラクトなどを含めることができます。\nコンストラクトは常に別のコンストラクトのスコープ内で作成され、作成されたスコープ内で一意でなければならない識別子（id）を持っている必要があります。 したがって、コンストラクト初期化子（コンストラクター）には常に次のシグネチャが必要です。\nscope： : 最初の引数には、この構成が作成されるスコープを必ず指定します。 ほとんどすべての場合、現在の コンストラクトスコープ内でコンストラクトを定義することになります。 つまり、通常最初の引数にはthisを渡すだけです。\nid ： 2番目の引数は、構造のローカルIDです。 これは、同じスコープ内のコンストラクト間で一意である必要があるIDです。 CDKはこのIDを使用して、 このスコープ内で定義された各リソースのCloudFormation 論理IDを計算します。 CDKのIDの詳細については、CDKユーザーマニュアルを参照してください。\nprops : 最後の（場合によっては不要である場合もある）引数は、初期化プロパティのセットです。 これらは各コンストラクトで固有です。 たとえば、lambda.Functionコンストラクトはruntime、code、handlerのようなプロパティを受け取ります。 IDEのオートコンプリートまたはオンラインドキュメントを使用して、さまざまなオプションを調べられます。\nDiff コードを保存し、デプロイする前に差分を見てみましょう。\ncdk diff 出力は次のようになります。\nStack CdkWorkshopStack IAM Statement Changes ┌───┬─────────────────────────────────┬────────┬────────────────┬──────────────────────────────┬───────────┐ │ │ Resource │ Effect │ Action │ Principal │ Condition │ ├───┼─────────────────────────────────┼────────┼────────────────┼──────────────────────────────┼───────────┤ │ + │ ${HelloHandler/ServiceRole.Arn} │ Allow │ sts:AssumeRole │ Service:lambda.amazonaws.com │ │ └───┴─────────────────────────────────┴────────┴────────────────┴──────────────────────────────┴───────────┘ IAM Policy Changes ┌───┬─────────────────────────────┬────────────────────────────────────────────────────────────────────────────────┐ │ │ Resource │ Managed Policy ARN │ ├───┼─────────────────────────────┼────────────────────────────────────────────────────────────────────────────────┤ │ + │ ${HelloHandler/ServiceRole} │ arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole │ └───┴─────────────────────────────┴────────────────────────────────────────────────────────────────────────────────┘ (NOTE: There may be security-related changes not in this list. See https://github.com/aws/aws-cdk/issues/1299) Resources [+] AWS::IAM::Role HelloHandler/ServiceRole HelloHandlerServiceRole11EF7C63 [+] AWS::Lambda::Function HelloHandler HelloHandler2E4FBA4D 上記のとおり、このコードから AWS::Lambda::Function リソース用のCloudFormationテンプレートを生成しました。 また、ツールキットがハンドラーコードの場所を伝達するためにいくつかのCloudFormationパラメーターを利用しています。\nDeploy 次にデプロイをします。\ncdk deploy cdk deploy を実行すると、CloudFormationスタックをデプロイするだけでなく、 初期構築したS3バケットに対して、ローカルの lambda ディレクトリを圧縮後、アップロードしていることがが分かるでしょう。\nTesting our function AWS Lambdaコンソールに移動して、Lambda関数をテストしましょう。\nAWS Lambdaコンソール を開きます （正しいリージョンにいることを確認してください）。\nLambda関数が表示されます。\n関数名をクリックして、コンソールを移動します。\nテストタブをクリックします。\nイベント名にtestを入力します。\nテンプレートリストからAmazon API Gateway AWS Proxyを選択します。\n保存をクリックします。\nテストをクリックし、実行が完了するまで待ちます。\n実行結果ペインで詳細を展開すると、出力が表示されます。\n👏 "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/30-hello-cdk/200-lambda.html","title":"Hello Lambda","tags":[],"description":"","content":"Lambda handler code We\u0026rsquo;ll start with the AWS Lambda handler code.\nCreate a directory lambda in the root of your project tree (next to the cdk_workshop directory). Add a file called lambda/hello.py with the following contents: import json def handler(event, context): print(\u0026#39;request: {}\u0026#39;.format(json.dumps(event))) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;headers\u0026#39;: { \u0026#39;Content-Type\u0026#39;: \u0026#39;text/plain\u0026#39; }, \u0026#39;body\u0026#39;: \u0026#39;Hello, CDK! You have hit {}\\n\u0026#39;.format(event[\u0026#39;path\u0026#39;]) } This is a simple Lambda function which returns the text \u0026ldquo;Hello, CDK! You\u0026rsquo;ve hit [url path]\u0026rdquo;. The function\u0026rsquo;s output also includes the HTTP status code and HTTP headers. These are used by API Gateway to formulate the HTTP response to the user.\nThis lambda is provided in Python. For more information on writing lambda functions in your language of choice, please refer to the AWS Lambda documentation here.\nInstall the AWS Lambda construct library The AWS CDK is shipped with an extensive library of constructs called the AWS Construct Library. The construct library is divided into modules, one for each AWS service. For example, if you want to define an AWS Lambda function, we will need to use the AWS Lambda construct library.\nTo discover and learn about AWS constructs, you can browse the AWS Construct Library reference.\nA few words about copying \u0026amp; pasting in this workshop In this workshop, we highly recommended to type CDK code instead of copying \u0026amp; pasting (there\u0026rsquo;s usually not much to type). This way, you\u0026rsquo;ll be able to fully experience what it\u0026rsquo;s like to use the CDK. It\u0026rsquo;s especially cool to see your IDE help you with auto-complete, inline documentation and type safety.\nAdd an AWS Lambda Function to your stack Add an import statement at the beginning of cdk_workshop/cdk_workshop_stack.py, and a lambda.Function to your stack.\nfrom constructs import Construct from aws_cdk import ( Stack, aws_lambda as _lambda, ) class CdkWorkshopStack(Stack): def __init__(self, scope: Construct, id: str, **kwargs) -\u0026gt; None: super().__init__(scope, id, **kwargs) # Defines an AWS Lambda resource my_lambda = _lambda.Function( self, \u0026#39;HelloHandler\u0026#39;, runtime=_lambda.Runtime.PYTHON_3_7, code=_lambda.Code.from_asset(\u0026#39;lambda\u0026#39;), handler=\u0026#39;hello.handler\u0026#39;, ) A few things to notice:\nWe are importing the aws_lambda module as _lambda because lambda is a built-in identifier in Python. Our function uses the Python 3.7 runtime The handler code is loaded from the lambda directory which we created earlier. Path is relative to where you execute cdk from, which is the project\u0026rsquo;s root directory The name of the handler function is hello.handler (\u0026ldquo;hello\u0026rdquo; is the name of the file and \u0026ldquo;handler\u0026rdquo; is the function name) A word about constructs and constructors As you can see, the class constructors of both CdkWorkshopStack and lambda.Function (and many other classes in the CDK) have the signature (scope, id, **kwargs). This is because all of these classes are constructs. Constructs are the basic building block of CDK apps. They represent abstract \u0026ldquo;cloud components\u0026rdquo; which can be composed together into higher level abstractions via scopes. Scopes can include constructs, which in turn can include other constructs, etc.\nConstructs are always created in the scope of another construct and must always have an identifier which must be unique within the scope it\u0026rsquo;s created. Therefore, construct initializers (constructors) will always have the following signature:\nscope: the first argument is always the scope in which this construct is created. In almost all cases, you\u0026rsquo;ll be defining constructs within the scope of current construct, which means you\u0026rsquo;ll usually just want to pass self for the first argument. Make a habit out of it. id: the second argument is the local identity of the construct. It\u0026rsquo;s an ID that has to be unique amongst construct within the same scope. The CDK uses this identity to calculate the CloudFormation Logical ID for each resource defined within this scope. To read more about IDs in the CDK, see the CDK user manual. kwargs: the last (sometimes optional) arguments is always a set of initialization arguments. Those are specific to each construct. For example, the lambda.Function construct accepts arguments like runtime, code and handler. You can explore the various options using your IDE\u0026rsquo;s auto-complete or in the online documentation. Diff Save your code, and let\u0026rsquo;s take a quick look at the diff before we deploy:\ncdk diff Output would look like this:\nThe cdk-workshop stack uses assets, which are currently not accounted for in the diff output! See https://github.com/awslabs/aws-cdk/issues/395 IAM Statement Changes ┌───┬────────────────────────┬────────┬────────────────────────┬────────────────────────┬───────────┐ │ │ Resource │ Effect │ Action │ Principal │ Condition │ ├───┼────────────────────────┼────────┼────────────────────────┼────────────────────────┼───────────┤ │ + │ ${HelloHandler/Service │ Allow │ sts:AssumeRole │ Service:lambda.amazona │ │ │ │ Role.Arn} │ │ │ ws.com │ │ └───┴────────────────────────┴────────┴────────────────────────┴────────────────────────┴───────────┘ IAM Policy Changes ┌───┬─────────────────────────────┬─────────────────────────────────────────────────────────────────┐ │ │ Resource │ Managed Policy ARN │ ├───┼─────────────────────────────┼─────────────────────────────────────────────────────────────────┤ │ + │ ${HelloHandler/ServiceRole} │ arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBas │ │ │ │ icExecutionRole │ └───┴─────────────────────────────┴─────────────────────────────────────────────────────────────────┘ (NOTE: There may be security-related changes not in this list. See http://bit.ly/cdk-2EhF7Np) Parameters [+] Parameter HelloHandler/Code/S3Bucket HelloHandlerCodeS3Bucket4359A483: {\u0026#34;Type\u0026#34;:\u0026#34;String\u0026#34;,\u0026#34;Description\u0026#34;:\u0026#34;S3 bucket for asset \\\u0026#34;hello-cdk-1/HelloHandler/Code\\\u0026#34;\u0026#34;} [+] Parameter HelloHandler/Code/S3VersionKey HelloHandlerCodeS3VersionKey07D12610: {\u0026#34;Type\u0026#34;:\u0026#34;String\u0026#34;,\u0026#34;Description\u0026#34;:\u0026#34;S3 key for asset version \\\u0026#34;hello-cdk-1/HelloHandler/Code\\\u0026#34;\u0026#34;} [+] Parameter HelloHandler/Code/ArtifactHash HelloHandlerCodeArtifactHash5DF4E4B6: {\u0026#34;Type\u0026#34;:\u0026#34;String\u0026#34;,\u0026#34;Description\u0026#34;:\u0026#34;Artifact hash for asset \\\u0026#34;hello-cdk-1/HelloHandler/Code\\\u0026#34;\u0026#34;} Resources [+] AWS::IAM::Role HelloHandler/ServiceRole HelloHandlerServiceRole11EF7C63 [+] AWS::Lambda::Function HelloHandler HelloHandler2E4FBA4D As you can see, this code synthesizes an AWS::Lambda::Function resource. It also synthesized a couple of CloudFormation parameters that are used by the toolkit to propagate the location of the handler code.\nDeploy Let\u0026rsquo;s deploy:\ncdk deploy You\u0026rsquo;ll notice that cdk deploy not only deployed your CloudFormation stack, but also archived and uploaded the lambda directory from your disk to the bootstrap bucket.\nTesting our function Let\u0026rsquo;s go to the AWS Lambda Console and test our function.\nOpen the AWS Lambda Console (make sure you are in the correct region).\nYou should see our function:\nClick on the function name to go to the console.\nClick on the Test button to open the Configure test event dialog:\nSelect Amazon API Gateway AWS Proxy from the Event template list.\nEnter test under Event name.\nHit Create.\nClick Test again and wait for the execution to complete.\nExpand Details in the Execution result pane and you should see our expected output:\n👏 "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/30-hello-cdk/200-lambda.html","title":"Hello Lambda","tags":[],"description":"","content":"Lambda handler code We\u0026rsquo;ll start with the AWS Lambda handler code.\nCreate a directory lambda in the root of your project tree (next to src). Add a file called `lambda/hello.js with the following contents: exports.handler = async function(event) { console.log(\u0026#34;request:\u0026#34;, JSON.stringify(event, undefined, 2)); return { statusCode: 200, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/plain\u0026#34; }, body: `Hello, CDK! You\u0026#39;ve hit ${event.path}\\n` }; }; This is a simple Lambda function which returns the text \u0026ldquo;Hello, CDK! You\u0026rsquo;ve hit [url path]\u0026rdquo;. The function\u0026rsquo;s output also includes the HTTP status code and HTTP headers. These are used by API Gateway to formulate the HTTP response to the user.\nThis lambda is provided in Javascript. For more information on writing lambda functions in your language of choice, please refer to the AWS Lambda documentation here.\nA few words about copying \u0026amp; pasting in this workshop In this workshop, we highly recommended to type CDK code instead of copying \u0026amp; pasting (there\u0026rsquo;s usually not much to type). This way, you\u0026rsquo;ll be able to fully experience what it\u0026rsquo;s like to use the CDK. It\u0026rsquo;s especially cool to see your IDE help you with auto-complete, inline documentation and type safety.\nAdd an AWS Lambda Function to your stack Add an using statement at the beginning of src/CdkWorkshop/CdkWorkshopStack.cs, and a Function to your stack.\nusing Amazon.CDK; using Amazon.CDK.AWS.Lambda; using Constructs; namespace CdkWorkshop { public class CdkWorkshopStack : Stack { public CdkWorkshopStack(Construct scope, string id, IStackProps props = null) : base(scope, id, props) { // Defines a new lambda resource var hello = new Function(this, \u0026#34;HelloHandler\u0026#34;, new FunctionProps { Runtime = Runtime.NODEJS_14_X, // execution environment Code = Code.FromAsset(\u0026#34;lambda\u0026#34;), // Code loaded from the \u0026#34;lambda\u0026#34; directory Handler = \u0026#34;hello.handler\u0026#34; // file is \u0026#34;hello\u0026#34;, function is \u0026#34;handler\u0026#34; }); } } } A few things to notice:\nOur function uses the NodeJS (NODEJS_14_X) runtime The handler code is loaded from the lambda directory which we created earlier. Path is relative to where you execute cdk from, which is the project\u0026rsquo;s root directory The name of the handler function is hello.handler (\u0026ldquo;hello\u0026rdquo; is the name of the file and \u0026ldquo;handler\u0026rdquo; is the exported function name) A word about constructs and constructors As you can see, the class constructors of Function (and many other classes in the CDK) have the signature (scope, id, props). This is because all of these classes are constructs. Constructs are the basic building block of CDK apps. They represent abstract \u0026ldquo;cloud components\u0026rdquo; which can be composed together into higher level abstractions via scopes. Scopes can include constructs, which in turn can include other constructs, etc.\nConstructs are always created in the scope of another construct and must always have an identifier which must be unique within the scope it\u0026rsquo;s created. Therefore, construct initializers (constructors) will always have the following signature:\nscope: the first argument is always the scope in which this construct is created. In almost all cases, you\u0026rsquo;ll be defining constructs within the scope of current construct, which means you\u0026rsquo;ll usually just want to pass this for the first argument. Make a habit out of it. id: the second argument is the local identity of the construct. It\u0026rsquo;s an ID that has to be unique amongst constructs within the same scope. The CDK uses this identity to calculate the CloudFormation Logical ID for each resource defined within this scope. To read more about IDs in the CDK, see the CDK user manual. props: the last (sometimes optional) argument is always a set of initialization properties. Those are specific to each construct. For example, the lambda.Function construct accepts properties like runtime, code and handler. You can explore the various options using your IDE\u0026rsquo;s auto-complete or in the online documentation. Diff Save your code, and let\u0026rsquo;s take a quick look at the diff before we deploy:\ncdk diff Output would look like this:\nThe CdkWorkshopStack stack uses assets, which are currently not accounted for in the diff output! See https://github.com/awslabs/aws-cdk/issues/395 IAM Statement Changes ┌───┬─────────────────────────────────┬────────┬────────────────┬──────────────────────────────┬───────────┐ │ │ Resource │ Effect │ Action │ Principal │ Condition │ ├───┼─────────────────────────────────┼────────┼────────────────┼──────────────────────────────┼───────────┤ │ + │ ${HelloHandler/ServiceRole.Arn} │ Allow │ sts:AssumeRole │ Service:lambda.amazonaws.com │ │ └───┴─────────────────────────────────┴────────┴────────────────┴──────────────────────────────┴───────────┘ IAM Policy Changes ┌───┬─────────────────────────────┬────────────────────────────────────────────────────────────────────────────────┐ │ │ Resource │ Managed Policy ARN │ ├───┼─────────────────────────────┼────────────────────────────────────────────────────────────────────────────────┤ │ + │ ${HelloHandler/ServiceRole} │ arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole │ └───┴─────────────────────────────┴────────────────────────────────────────────────────────────────────────────────┘ (NOTE: There may be security-related changes not in this list. See http://bit.ly/cdk-2EhF7Np) Parameters [+] Parameter HelloHandler/Code/S3Bucket HelloHandlerCodeS3Bucket4359A483: {\u0026#34;Type\u0026#34;:\u0026#34;String\u0026#34;,\u0026#34;Description\u0026#34;:\u0026#34;S3 bucket for asset \\\u0026#34;CdkWorkshopStack/HelloHandler/Code\\\u0026#34;\u0026#34;} [+] Parameter HelloHandler/Code/S3VersionKey HelloHandlerCodeS3VersionKey07D12610: {\u0026#34;Type\u0026#34;:\u0026#34;String\u0026#34;,\u0026#34;Description\u0026#34;:\u0026#34;S3 key for asset version \\\u0026#34;CdkWorkshopStack/HelloHandler/Code\\\u0026#34;\u0026#34;} [+] Parameter HelloHandler/Code/ArtifactHash HelloHandlerCodeArtifactHash5DF4E4B6: {\u0026#34;Type\u0026#34;:\u0026#34;String\u0026#34;,\u0026#34;Description\u0026#34;:\u0026#34;Artifact hash for asset \\\u0026#34;CdkWorkshopStack/HelloHandler/Code\\\u0026#34;\u0026#34;} Resources [+] AWS::IAM::Role HelloHandler/ServiceRole HelloHandlerServiceRole11EF7C63 [+] AWS::Lambda::Function HelloHandler HelloHandler2E4FBA4D As you can see, this code synthesizes an AWS::Lambda::Function resource. It also synthesized a couple of CloudFormation parameters that are used by the toolkit to propagate the location of the handler code.\nDeploy Let\u0026rsquo;s deploy:\ncdk deploy You\u0026rsquo;ll notice that cdk deploy not only deployed your CloudFormation stack, but also archived and uploaded the lambda directory from your disk to the bootstrap bucket.\nTesting our function Let\u0026rsquo;s go to the AWS Lambda Console and test our function.\nOpen the AWS Lambda Console (make sure you are in the correct region).\nYou should see our function:\nClick on the function name to go to the console.\nClick on the Test button to open the Configure test event dialog:\nSelect Amazon API Gateway AWS Proxy from the Event template list.\nEnter test under Event name.\nHit Create.\nClick Test again and wait for the execution to complete.\nExpand Details in the Execution result pane and you should see our expected output:\n👏 "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/30-hello-cdk/200-lambda.html","title":"Hello Lambda","tags":[],"description":"","content":"Lambda handler code We\u0026rsquo;ll start with the AWS Lambda handler code.\nCreate a directory lambda in the root of your project tree (next to src). Add a file called lambda/hello.js with the following contents: exports.handler = async function(event) { console.log(\u0026#34;request:\u0026#34;, JSON.stringify(event, undefined, 2)); return { statusCode: 200, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/plain\u0026#34; }, body: `Hello, CDK! You\u0026#39;ve hit ${event.path}\\n` }; }; This is a simple Lambda function which returns the text \u0026ldquo;Hello, CDK! You\u0026rsquo;ve hit [url path]\u0026rdquo;. The function\u0026rsquo;s output also includes the HTTP status code and HTTP headers. These are used by API Gateway to formulate the HTTP response to the user.\nThis lambda is provided in Javascript. For more information on writing lambda functions in your language of choice, please refer to the AWS Lambda documentation here.\nInstall the AWS Lambda construct library The AWS CDK is shipped with an extensive library of constructs called the AWS Construct Library. The construct library is divided into modules, one for each AWS service. For example, if you want to define an AWS Lambda function, we will need to use the AWS Lambda construct library.\nTo discover and learn about AWS constructs, you can browse the AWS Construct Library reference.\nA few words about copying \u0026amp; pasting in this workshop In this workshop, we highly recommended to type CDK code instead of copying \u0026amp; pasting (there\u0026rsquo;s usually not much to type). This way, you\u0026rsquo;ll be able to fully experience what it\u0026rsquo;s like to use the CDK. It\u0026rsquo;s especially cool to see your IDE help you with auto-complete, inline documentation and type safety.\nAdd an AWS Lambda Function to your stack Add the import statements at the beginning of ~/CdkWorkshopStack.java, and a Function to your stack.\npackage com.myorg; import software.constructs.Construct; import software.amazon.awscdk.Stack; import software.amazon.awscdk.StackProps; import software.amazon.awscdk.services.lambda.Code; import software.amazon.awscdk.services.lambda.Function; import software.amazon.awscdk.services.lambda.Runtime; public class CdkWorkshopStack extends Stack { public CdkWorkshopStack(final Construct parent, final String id) { this(parent, id, null); } public CdkWorkshopStack(final Construct parent, final String id, final StackProps props) { super(parent, id, props); // Defines a new lambda resource final Function hello = Function.Builder.create(this, \u0026#34;HelloHandler\u0026#34;) .runtime(Runtime.NODEJS_14_X) // execution environment .code(Code.fromAsset(\u0026#34;lambda\u0026#34;)) // code loaded from the \u0026#34;lambda\u0026#34; directory .handler(\u0026#34;hello.handler\u0026#34;) // file is \u0026#34;hello\u0026#34;, function is \u0026#34;handler\u0026#34; .build(); } } A few things to notice:\nOur function uses the NodeJS (NODEJS_14_X) runtime The handler code is loaded from the lambda directory which we created earlier. Path is relative to where you execute cdk from, which is the project\u0026rsquo;s root directory The name of the handler function is hello.handler (\u0026ldquo;hello\u0026rdquo; is the name of the file and \u0026ldquo;handler\u0026rdquo; is the exported function name) A word about constructs and constructors As you can see, the class constructors of both CdkWorkshopStack and Function (and many other classes in the CDK) have the signature (scope, id, props). This is because all of these classes are constructs. Constructs are the basic building block of CDK apps. They represent abstract \u0026ldquo;cloud components\u0026rdquo; which can be composed together into higher level abstractions via scopes. Scopes can include constructs, which in turn can include other constructs, etc.\nConstructs are always created in the scope of another construct and must always have an identifier which must be unique within the scope it\u0026rsquo;s created. Therefore, construct initializers (constructors) will always have the following signature:\nscope: the first argument is always the scope in which this construct is created. In almost all cases, you\u0026rsquo;ll be defining constructs within the scope of current construct, which means you\u0026rsquo;ll usually just want to pass this for the first argument. Make a habit out of it. id: the second argument is the local identity of the construct. It\u0026rsquo;s an ID that has to be unique amongst constructs within the same scope. The CDK uses this identity to calculate the CloudFormation Logical ID for each resource defined within this scope. To read more about IDs in the CDK, see the CDK user manual. props: the last (sometimes optional) argument is always a set of initialization properties. Those are specific to each construct. For example, the lambda.Function construct accepts properties like runtime, code and handler. You can explore the various options using your IDE\u0026rsquo;s auto-complete or in the online documentation. Diff Save your code, and let\u0026rsquo;s take a quick look at the diff before we deploy:\nmvn package cdk diff Output would look like this:\nThe CdkWorkshopStack stack uses assets, which are currently not accounted for in the diff output! See https://github.com/awslabs/aws-cdk/issues/395 IAM Statement Changes ┌───┬─────────────────────────────────┬────────┬────────────────┬──────────────────────────────┬───────────┐ │ │ Resource │ Effect │ Action │ Principal │ Condition │ ├───┼─────────────────────────────────┼────────┼────────────────┼──────────────────────────────┼───────────┤ │ + │ ${HelloHandler/ServiceRole.Arn} │ Allow │ sts:AssumeRole │ Service:lambda.amazonaws.com │ │ └───┴─────────────────────────────────┴────────┴────────────────┴──────────────────────────────┴───────────┘ IAM Policy Changes ┌───┬─────────────────────────────┬────────────────────────────────────────────────────────────────────────────────┐ │ │ Resource │ Managed Policy ARN │ ├───┼─────────────────────────────┼────────────────────────────────────────────────────────────────────────────────┤ │ + │ ${HelloHandler/ServiceRole} │ arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole │ └───┴─────────────────────────────┴────────────────────────────────────────────────────────────────────────────────┘ (NOTE: There may be security-related changes not in this list. See http://bit.ly/cdk-2EhF7Np) Parameters [+] Parameter HelloHandler/Code/S3Bucket HelloHandlerCodeS3Bucket4359A483: {\u0026#34;Type\u0026#34;:\u0026#34;String\u0026#34;,\u0026#34;Description\u0026#34;:\u0026#34;S3 bucket for asset \\\u0026#34;CdkWorkshopStack/HelloHandler/Code\\\u0026#34;\u0026#34;} [+] Parameter HelloHandler/Code/S3VersionKey HelloHandlerCodeS3VersionKey07D12610: {\u0026#34;Type\u0026#34;:\u0026#34;String\u0026#34;,\u0026#34;Description\u0026#34;:\u0026#34;S3 key for asset version \\\u0026#34;CdkWorkshopStack/HelloHandler/Code\\\u0026#34;\u0026#34;} [+] Parameter HelloHandler/Code/ArtifactHash HelloHandlerCodeArtifactHash5DF4E4B6: {\u0026#34;Type\u0026#34;:\u0026#34;String\u0026#34;,\u0026#34;Description\u0026#34;:\u0026#34;Artifact hash for asset \\\u0026#34;CdkWorkshopStack/HelloHandler/Code\\\u0026#34;\u0026#34;} Resources [+] AWS::IAM::Role HelloHandler/ServiceRole HelloHandlerServiceRole11EF7C63 [+] AWS::Lambda::Function HelloHandler HelloHandler2E4FBA4D As you can see, this code synthesizes an AWS::Lambda::Function resource. It also synthesized a couple of CloudFormation parameters that are used by the toolkit to propagate the location of the handler code.\nDeploy Let\u0026rsquo;s deploy:\ncdk deploy You\u0026rsquo;ll notice that cdk deploy not only deployed your CloudFormation stack, but also archived and uploaded the lambda directory from your disk to the bootstrap bucket.\nTesting our function Let\u0026rsquo;s go to the AWS Lambda Console and test our function.\nOpen the AWS Lambda Console (make sure you are in the correct region).\nYou should see our function:\nClick on the function name to go to the console.\nClick on the Test button to open the Configure test event dialog:\nSelect Amazon API Gateway AWS Proxy from the Event template list.\nEnter test under Event name.\nHit Create.\nClick Test again and wait for the execution to complete.\nExpand Details in the Execution result pane and you should see our expected output:\n👏 "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/50-table-viewer/200-install.html","title":"Installing the library","tags":[],"description":"","content":"npm install Before you can use the table viewer in your application, you\u0026rsquo;ll need to install the npm module:\nnpm install cdk-dynamo-table-viewer@0.2.0 Output should look like this:\n+ cdk-dynamo-table-viewer@0.2.0 added 1 package from 1 contributor and audited 886517 packages in 6.704s found 0 vulnerabilities Now we are ready to add a viewer to our app.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/50-table-viewer/200-install.html","title":"Installing the library","tags":[],"description":"","content":"pip install Before you can use the table viewer in your application, you\u0026rsquo;ll need to install the python module:\npip install cdk-dynamo-table-view==0.2.0 The last two lines of the output (there\u0026rsquo;s a lot of it) should look like this:\nInstalling collected packages: cdk-dynamo-table-view Successfully installed cdk-dynamo-table-view-0.2.0 Now we are ready to add a viewer to our app.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/50-table-viewer/200-install.html","title":"Installing the library","tags":[],"description":"","content":"Install Package Before you can use the table viewer in your application, you\u0026rsquo;ll need to install the Nuget package:\ndotnet add package Cdklabs.DynamoTableViewer --version 0.2.4 Output should look similar to this:\ninfo : Adding PackageReference for package \u0026#39;Eladb.DynamoTableViewer\u0026#39; into project \u0026#39;~/cdk-workshop/src/CdkWorkshop/CdkWorkshop.csproj\u0026#39;. info : Restoring packages for ~/cdk-workshop/src/CdkWorkshop/CdkWorkshop.csproj... info : GET https://api.nuget.org/v3-flatcontainer/cdklabs.dynamotableviewer/index.json info : OK https://api.nuget.org/v3-flatcontainer/cdklabs.dynamotableviewer/index.json 240ms info : GET https://api.nuget.org/v3-flatcontainer/cdklabs.dynamotableviewer/0.2.4/cdklabs.dynamotableviewer.0.2.4.nupkg info : OK https://api.nuget.org/v3-flatcontainer/cdklabs.dynamotableviewer/0.2.4/cdklabs.dynamotableviewer.0.2.4.nupkg 241ms info : Installing Cdklabs.DynamoTableViewer 0.2.4. info : Package \u0026#39;Cdklabs.DynamoTableViewer\u0026#39; is compatible with all the specified frameworks in project \u0026#39;~/cdk-workshop/src/CdkWorkshop/CdkWorkshop.csproj\u0026#39;. info : PackageReference for package \u0026#39;Cdklabs.DynamoTableViewer\u0026#39; version \u0026#39;0.2.4\u0026#39; added to file \u0026#39;~/cdk-workshop/src/CdkWorkshop/CdkWorkshop.csproj\u0026#39;. info : Committing restore... info : Writing assets file to disk. Path: ~/cdk-workshop/src/CdkWorkshop/obj/project.assets.json log : Restore completed in 1.31 sec for ~/cdk-workshop/src/CdkWorkshop/CdkWorkshop.csproj. NOTE: You must be in the same directory as the *.csproj file to install a Nuget package\nNow we are ready to add a viewer to our app.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/50-table-viewer/200-install.html","title":"Installing the library","tags":[],"description":"","content":"Add Artifact Before you can use the table viewer in your application, you\u0026rsquo;ll need to add the artifact to your pom.xml file:\n... \u0026lt;dependencies\u0026gt; \u0026lt;!-- AWS Cloud Development Kit --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;software.amazon.awscdk\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aws-cdk-lib\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${cdk.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Additional Construct Libraries --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.cdklabs\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cdk-dynamo-table-view\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.2.0\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt; software.amazon.jsii\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jsii-runtime\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; ... Now we are ready to add a viewer to our app.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/50-table-viewer/300-add.html","title":"Add the table viewer to your app","tags":[],"description":"","content":"Add a table viewer to your stack Add the following hightlighted lines to lib/cdk-workshop-stack.ts to add a TableViewer construct to your stack:\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import * as lambda from \u0026#39;aws-cdk-lib/aws-lambda\u0026#39;; import * as apigw from \u0026#39;aws-cdk-lib/aws-apigateway\u0026#39;; import { HitCounter } from \u0026#39;./hitcounter\u0026#39;; import { TableViewer } from \u0026#39;cdk-dynamo-table-viewer\u0026#39;; export class CdkWorkshopStack extends cdk.Stack { constructor(scope: cdk.App, id: string, props?: cdk.StackProps) { super(scope, id, props); const hello = new lambda.Function(this, \u0026#39;HelloHandler\u0026#39;, { runtime: lambda.Runtime.NODEJS_14_X, code: lambda.Code.fromAsset(\u0026#39;lambda\u0026#39;), handler: \u0026#39;hello.handler\u0026#39; }); const helloWithCounter = new HitCounter(this, \u0026#39;HelloHitCounter\u0026#39;, { downstream: hello }); // defines an API Gateway REST API resource backed by our \u0026#34;hello\u0026#34; function. new apigw.LambdaRestApi(this, \u0026#39;Endpoint\u0026#39;, { handler: helloWithCounter.handler }); new TableViewer(this, \u0026#39;ViewHitCounter\u0026#39;, { title: \u0026#39;Hello Hits\u0026#39;, table: //?????? }); } } What about the table? As you\u0026rsquo;ll notice, TableViewer requires that you specify a table property.\nWhat we want is to somehow access the DynamoDB table behind our hit counter. However, the current API of our hit counter doesn\u0026rsquo;t expose the table as a public member.\nIn the next section, we\u0026rsquo;ll expose our table as a property of HitCounter so we can access it from our stack.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/50-table-viewer/300-add.html","title":"Add the table viewer to your app","tags":[],"description":"","content":"Add a table viewer to your stack Add the following highlighted lines to cdk_workshop_stack.py to add a TableViewer construct to your stack:\nfrom constructs import Construct from aws_cdk import ( Stack, aws_lambda as _lambda, aws_apigateway as apigw, ) from cdk_dynamo_table_view import TableViewer from .hitcounter import HitCounter class CdkWorkshopStack(Stack): def __init__(self, scope: Construct, id: str, **kwargs) -\u0026gt; None: super().__init__(scope, id, **kwargs) # Defines an AWS Lambda resource hello = _lambda.Function( self, \u0026#39;HelloHandler\u0026#39;, runtime=_lambda.Runtime.PYTHON_3_7, code=_lambda.Code.from_asset(\u0026#39;lambda\u0026#39;), handler=\u0026#39;hello.handler\u0026#39;, ) hello_with_counter = HitCounter( self, \u0026#39;HelloHitCounter\u0026#39;, downstream=hello, ) apigw.LambdaRestApi( self, \u0026#39;Endpoint\u0026#39;, handler=hello_with_counter._handler, ) TableViewer( self, \u0026#39;ViewHitCounter\u0026#39;, title=\u0026#39;Hello Hits\u0026#39;, table=?????? ) What about the table? As you\u0026rsquo;ll notice, TableViewer requires that you specify a table property.\nWhat we want is to somehow access the DynamoDB table behind our hit counter. However, the current API of our hit counter doesn\u0026rsquo;t expose the table as a public member.\nIn the next section, we\u0026rsquo;ll expose our table as a property of HitCounter so we can access it from our stack.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/50-table-viewer/300-add.html","title":"Add the table viewer to your app","tags":[],"description":"","content":"Add a table viewer to your stack Add the following highlighted lines to src/CdkWorkshop/CdkWorkshopStack.cs to add a TableViewer construct to your stack:\nusing Amazon.CDK; using Amazon.CDK.AWS.APIGateway; using Amazon.CDK.AWS.Lambda; using Cdklabs.DynamoTableViewer; using Construct; namespace CdkWorkshop { public class CdkWorkshopStack : Stack { public CdkWorkshopStack(Construct scope, string id, IStackProps props = null) : base(scope, id, props) { // Defines a new lambda resource var hello = new Function(this, \u0026#34;HelloHandler\u0026#34;, new FunctionProps { Runtime = Runtime.NODEJS_14_X, // execution environment Code = Code.FromAsset(\u0026#34;lambda\u0026#34;), // Code loaded from the \u0026#34;lambda\u0026#34; directory Handler = \u0026#34;hello.handler\u0026#34; // file is \u0026#34;hello\u0026#34;, function is \u0026#34;handler\u0026#34; }); // Defines out HitCounter resource var helloWithCounter = new HitCounter(this, \u0026#34;HelloHitCounter\u0026#34;, new HitCounterProps { Downstream = hello }); // Defines an API Gateway REST API resource backed by our \u0026#34;hello\u0026#34; function. new LambdaRestApi(this, \u0026#34;Endpoint\u0026#34;, new LambdaRestApiProps { Handler = helloWithCounter.Handler }); // Defines a new TableViewer resource new TableViewer(this, \u0026#34;ViewerHitCount\u0026#34;, new TableViewerProps { Title = \u0026#34;Hello Hits\u0026#34;, Table = //??? }); } } } What about the table? As you\u0026rsquo;ll notice, TableViewer requires that you specify a Table property.\nWhat we want is to somehow access the DynamoDB table behind our hit counter. However, the current API of our hit counter doesn\u0026rsquo;t expose the table as a public member.\nIn the next section, we\u0026rsquo;ll expose our table as a property of HitCounter so we can access it from our stack.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/50-table-viewer/300-add.html","title":"Add the table viewer to your app","tags":[],"description":"","content":"Add a table viewer to your stack Add the following hightlighted lines to ~/CdkWorkshopStack.java to add a TableViewer construct to your stack:\npackage com.myorg; import io.github.cdklabs.dynamotableviewer.TableViewer; import software.constructs.Construct; import software.amazon.awscdk.Stack; import software.amazon.awscdk.StackProps; import software.amazon.awscdk.services.apigateway.LambdaRestApi; import software.amazon.awscdk.services.lambda.Code; import software.amazon.awscdk.services.lambda.Function; import software.amazon.awscdk.services.lambda.Runtime; public class CdkWorkshopStack extends Stack { public CdkWorkshopStack(final Construct parent, final String id) { this(parent, id, null); } public CdkWorkshopStack(final Construct parent, final String id, final StackProps props) { super(parent, id, props); // Defines a new lambda resource final Function hello = Function.Builder.create(this, \u0026#34;HelloHandler\u0026#34;) .runtime(Runtime.NODEJS_14_X) // execution environment .code(Code.fromAsset(\u0026#34;lambda\u0026#34;)) // code loaded from the \u0026#34;lambda\u0026#34; directory .handler(\u0026#34;hello.handler\u0026#34;) // file is \u0026#34;hello\u0026#34;, function is \u0026#34;handler\u0026#34; .build(); // Defines our hitcounter resource final HitCounter helloWithCounter = new HitCounter(this, \u0026#34;HelloHitCounter\u0026#34;, HitCounterProps.builder() .downstream(hello) .build()); // Defines an API Gateway REST API resource backed by our \u0026#34;hello\u0026#34; function LambdaRestApi.Builder.create(this, \u0026#34;Endpoint\u0026#34;) .handler(helloWithCounter.getHandler()) .build(); // Defines a viewer for the HitCounts table TableViewer.Builder.create(this, \u0026#34;ViewerHitCount\u0026#34;) .title(\u0026#34;Hello Hits\u0026#34;) .table(helloWithCounter.getTable()) .build(); } } We are now done making code changes. Congratulations! You can now save and exit out of your code editor if you want.\nIn the next section, we\u0026rsquo;ll deploy our stack one more time, and take a look at the result.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/30-hello-cdk/300-cdk-watch.html","title":"CDK Watch","tags":[],"description":"","content":"より高速なデプロイ このセクションはワークショップを完了するために必要ではありませんが、 cdk deploy --hotswap と cdk watch がどのようにデプロイを高速化するのか見てみましょう。\nlambdaが動作するようになりましたね！ しかし、もしlambdaのコードを微調整して正しく動作させたい場合はどうしたらよいでしょうか？ 例えば、lambda関数を「Hello, CDK」ではなく「Good Morning, CDK!」と応答させることに決めたとしましょう。\n今のところ、スタックを更新するために使えるツールは cdk deploy しかないように思えます。 しかし、cdk deployには時間がかかります。 CloudFormationスタックをデプロイして、lambdaディレクトリをbootstrapバケットにアップロードしなければならないからです。 lambdaのコードを変更するだけならCloudFormationスタックを更新する必要はないので、cdk deployの部分は無駄な労力となります。\n本当に必要なのは、lambdaコードの更新だけなのです。 それだけを行うための他のメカニズムがあれば最高なのですが\u0026hellip;。\ncdk deploy にかかる時間を測ってみる まず、cdk deployを実行するのにかかる時間を計ってみましょう。 これは、CloudFormationのフルデプロイにどれくらい時間がかかるかの基準値になります。 そのために、lambda/hello.js 内のコードを変更します。\nexports.handler = async function(event) { console.log(\u0026#34;request:\u0026#34;, JSON.stringify(event, undefined, 2)); return { statusCode: 200, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/plain\u0026#34; }, body: `Good Morning, CDK! You\u0026#39;ve hit ${event.path}\\n` }; }; 変更が cdk deploy を実行してみましょう。\ncdk deploy 出力は次のようになります。\n✨ Synthesis time: 6s CdkWorkshopStack: deploying... CdkWorkshopStack: creating CloudFormation changeset... ✅ CdkWorkshopStack ✨ Deployment time: 66.82s Stack ARN: arn:aws:cloudformation:REGION:ACCOUNT-ID:stack/CdkWorkshopStack/STACK-ID ✨ Total time: 72.82s 正確な時間にはばらつきがありますが、通常のデプロイにかかる時間については、かなりの目安になるはずです！\nHotswap deployments このコマンドは、デプロイを高速化するために、CloudFormationのスタックに意図的にドリフトを発生させるものです。 このため、開発目的にのみ使用してください。 本番デプロイには絶対にhotswapを使わないでください!\nCDK deploy --hotswap を使えばデプロイ時間を短縮することができます。これはCloudFormation のデプロイの代わりにホットスワップデプロイが実行可能かどうかを評価してくれます。 ホットスワップデプロイが可能であれば、CDK CLIはAWSサービスAPIを使用して直接変更を行います。そうでない場合は、CloudFormationのフルデプロイメントを実行します。\nここでは、cdk deploy --hotswap を使用して、AWS Lambda のアセットコードにホットスワップ可能な変更をデプロイします。\ncdk deploy --hotswap にかかる時間を測ってみる lambda/hello.jsのlambdaコードをもう一度変えてみましょう。\nexports.handler = async function(event) { console.log(\u0026#34;request:\u0026#34;, JSON.stringify(event, undefined, 2)); return { statusCode: 200, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/plain\u0026#34; }, body: `Good Afternoon, CDK! You\u0026#39;ve hit ${event.path}\\n` }; }; そして cdk deploy --hotswap を実行してみます。\ncdk deploy --hotswap 出力は次のようになります。\n✨ Synthesis time: 6.44s ⚠️ The --hotswap flag deliberately introduces CloudFormation drift to speed up deployments ⚠️ It should only be used for development - never use it for your production Stacks! CdkWorkshopStack: deploying... ✨ hotswapping resources: ✨ Lambda Function \u0026#39;CdkWorkshopStack-HelloHandler2E4FBA4D-tEZTcXqG8YYe\u0026#39; ✨ Lambda Function \u0026#39;CdkWorkshopStack-HelloHandler2E4FBA4D-tEZTcXqG8YYe\u0026#39; hotswapped! ✅ CdkWorkshopStack ✨ Deployment time: 3.07s Stack ARN: arn:aws:cloudformation:REGION:ACCOUNT-ID:stack/CdkWorkshopStack/STACK-ID ✨ Total time: 9.51s さきほどのフルデプロイメントには67秒かかりましたが、なんと、ホットスワップデプロイはたったの3秒でデプロイが完了しました！ しかし、警告メッセージが出ていますね。--hotswapフラグの使用上の注意ですのでよく読んでください。\n⚠️ The --hotswap flag deliberately introduces CloudFormation drift to speed up deployments ⚠️ It should only be used for development - never use it for your production Stacks! --hotswap フラグは、デプロイメントを高速化するために意図的に CloudFormation のドリフトを導入しています。 これは開発のみに使用すべきです - 決して本番のStacksには使用しないでください！\n本当にデプロイできたのでしょうか？ 高速にデプロイされることが確認できたと思います。 実際にコードは変更されたのでしょうか？ AWS Lambda Consoleで再確認してみましょう!\nAWS Lambda Consoleを開きます。 (正しいリージョンにいることを確認してください)\nデプロイした関数を見つけてください。\n関数の名前をクリックします。\nデプロイされたコードが表示されます。変更されていることは確認できましたでしょうか？\nCDK Watch 毎回 cdk deploy や cdk deploy --hotswap を呼び出すよりも、もっと良い方法があるはずです。 cdk watch は cdk deploy と似ていますが、ワンショットの操作ではなく、 コードやアセットの変更を監視して、変更が検出されたときに自動的にデプロイを実行してくれます。 デフォルトでは、cdk watch は --hotswap フラグを使用し、変更を検査し、その変更がホットスワップ可能かどうかを決定します。 cdk watch --no-hotswapを呼び出すと、ホットスワップの動作が無効化されます。\n一度設定すれば、cdk watchを使用して、ホットスワップ可能な変更とCloudFormationのフルデプロイを必要とする変更の両方を検出することができます。\ncdk.json を編集する cdk watch コマンドが実行されると、監視するファイルは cdk.json ファイルにある \u0026quot;watch\u0026quot; 設定によって決定されます。 この設定には、 \u0026quot;include\u0026quot; と \u0026quot;exclude\u0026quot; という2つのサブキーがあり、それぞれ単一の文字列または文字列の配列として使用できます。 各エントリーは cdk.json ファイルの場所からの相対パスとして解釈されます。 glob、つまり* と ** の両方を使用することができます。\nあなたは今、以下のような cdk.json ファイルを持っているはずです。\n{ \u0026#34;app\u0026#34;: \u0026#34;npx ts-node --prefer-ts-exts bin/cdk-workshop.ts\u0026#34;, \u0026#34;watch\u0026#34;: { \u0026#34;include\u0026#34;: [ \u0026#34;**\u0026#34; ], \u0026#34;exclude\u0026#34;: [ \u0026#34;README.md\u0026#34;, \u0026#34;cdk*.json\u0026#34;, \u0026#34;**/*.d.ts\u0026#34;, \u0026#34;**/*.js\u0026#34;, \u0026#34;tsconfig.json\u0026#34;, \u0026#34;package*.json\u0026#34;, \u0026#34;yarn.lock\u0026#34;, \u0026#34;node_modules\u0026#34;, \u0026#34;test\u0026#34; ] }, \u0026#34;context\u0026#34;: { // ... } } 見ての通り、このサンプルアプリでは \u0026quot;watch\u0026quot; 設定が推奨されています。 実際に lambda フォルダにある .js ファイルを監視したいので、 \u0026quot;**/*.js\u0026quot; を \u0026quot;exclude\u0026quot; リストから削除してみましょう。\n{ \u0026#34;app\u0026#34;: \u0026#34;npx ts-node --prefer-ts-exts bin/cdk-workshop.ts\u0026#34;, \u0026#34;watch\u0026#34;: { \u0026#34;include\u0026#34;: [ \u0026#34;**\u0026#34; ], \u0026#34;exclude\u0026#34;: [ \u0026#34;README.md\u0026#34;, \u0026#34;cdk*.json\u0026#34;, \u0026#34;**/*.d.ts\u0026#34;, \u0026#34;tsconfig.json\u0026#34;, \u0026#34;package*.json\u0026#34;, \u0026#34;yarn.lock\u0026#34;, \u0026#34;node_modules\u0026#34;, \u0026#34;test\u0026#34; ] }, \u0026#34;context\u0026#34;: { // ... } } これでcdk watchの準備は万端です!\ncdk watch にかかる時間を測ってみる まず cdk watch を実行してみます。\ncdk watch これで初期デプロイが始まり、すぐに cdk.json で指定したファイルの監視を開始します。\nもう一度、lambda/hello.js を変更してみましょう。\nexports.handler = async function(event) { console.log(\u0026#34;request:\u0026#34;, JSON.stringify(event, undefined, 2)); return { statusCode: 200, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/plain\u0026#34; }, body: `Good Night, CDK! You\u0026#39;ve hit ${event.path}\\n` }; }; Lambda コードファイルの変更を保存すると、cdk watch がファイルが変更されたことを認識し、新しいデプロイメントが開始されます。 今回は、lambdaアセットコードをホットスワップできることを認識し、CloudFormation のデプロイを回避して、代わりに Lambda サービスに直接デプロイされます。\nデプロイはどれくらいの速度で行われたのでしょうか？\nDetected change to \u0026#39;lambda/hello.js\u0026#39; (type: change). Triggering \u0026#39;cdk deploy\u0026#39; ✨ Synthesis time: 5.57s ⚠️ The --hotswap flag deliberately introduces CloudFormation drift to speed up deployments ⚠️ It should only be used for development - never use it for your production Stacks! CdkWorkshopStack: deploying... ✨ hotswapping resources: ✨ Lambda Function \u0026#39;CdkWorkshopStack-HelloHandler2E4FBA4D-tEZTcXqG8YYe\u0026#39; ✨ Lambda Function \u0026#39;CdkWorkshopStack-HelloHandler2E4FBA4D-tEZTcXqG8YYe\u0026#39; hotswapped! ✅ CdkWorkshopStack ✨ Deployment time: 2.54s Stack ARN: arn:aws:cloudformation:REGION:ACCOUNT-ID:stack/CdkWorkshopStack/STACK-ID ✨ Total time: 8.11s まとめ このチュートリアルの残りの部分では、cdk watchの代わりにcdk deployを使い続けます。 しかし、必要であれば、単に cdk watch をオンにしておくこともできます。 もし、完全なデプロイが必要な場合は、cdk watch が cdk deploy を呼び出します。\ncdk watch の使用例についての詳細は、Increasing Development Speed with CDK Watchを参照してください。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/30-hello-cdk/300-cdk-watch.html","title":"CDK Watch","tags":[],"description":"","content":"Faster personal deployments This section is not necessary to complete the workshop, but we recommend that you take the time to see how cdk deploy --hotswap and cdk watch can speed up your personal deployments.\nIt\u0026rsquo;s great that we have a working lambda! But what if we want to tweak the lambda code to get it just right? Let\u0026rsquo;s say that we have now decided that we want our lambda function to respond with \u0026quot;Good Morning, CDK!\u0026quot; instead of \u0026quot;Hello, CDK\u0026quot;.\nSo far, it seems like the only tool we have at our disposal to update our stack is cdk deploy. But cdk deploy takes time; it has to deploy your CloudFormation stack and upload the lambda directory from your disk to the boostrap bucket. If we\u0026rsquo;re just changing our lambda code, we don\u0026rsquo;t actually need to update the CloudFormation stack, so that part of cdk deploy is wasted effort.\nWe really only need to update our lambda code. It would be great if we had some other mechanism for doing only that\u0026hellip;\nTiming cdk deploy First, let\u0026rsquo;s time how long it takes to run cdk deploy. It will help us baseline how long a full CloudFormation deployment takes. To do this, we are going to change the code inside lambda/hello.py:\nimport json def handler(event, context): print(\u0026#39;request: {}\u0026#39;.format(json.dumps(event))) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;headers\u0026#39;: { \u0026#39;Content-Type\u0026#39;: \u0026#39;text/plain\u0026#39; }, \u0026#39;body\u0026#39;: \u0026#39;Good Morning, CDK! You have hit {}\\n\u0026#39;.format(event[\u0026#39;path\u0026#39;]) } Then, we can run cdk deploy:\ncdk deploy The output will look something like this:\n✨ Synthesis time: 6s CdkWorkshopStack: deploying... CdkWorkshopStack: creating CloudFormation changeset... ✅ CdkWorkshopStack ✨ Deployment time: 66.82s Stack ARN: arn:aws:cloudformation:REGION:ACCOUNT-ID:stack/CdkWorkshopStack/STACK-ID ✨ Total time: 72.82s The exact time will vary but we should get a pretty good idea of how long a normal deployment takes!\nHotswap deployments This command deliberately introduces drift in CloudFormation stacks in order to speed up deployments. For this reason, only use it for development purposes. Never use hotswap for your production deployments!\nWe can speed up that deployment time with cdk deploy --hotswap, which will assess whether a hotswap deployment can be performed instead of a CloudFormation deployment. If possible, the CDK CLI will use AWS service APIs to directly make the changes; otherwise it will fall back to performing a full CloudFormation deployment.\nHere, we will use cdk deploy --hotswap to deploy a hotswappable change to your AWS Lambda asset code.\nTiming cdk deploy --hotswap Let\u0026rsquo;s change the lambda code in lambda/hello.py another time:\nimport json def handler(event, context): print(\u0026#39;request: {}\u0026#39;.format(json.dumps(event))) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;headers\u0026#39;: { \u0026#39;Content-Type\u0026#39;: \u0026#39;text/plain\u0026#39; }, \u0026#39;body\u0026#39;: \u0026#39;Good Afternoon, CDK! You have hit {}\\n\u0026#39;.format(event[\u0026#39;path\u0026#39;]) } Now, let\u0026rsquo;s run cdk deploy --hotswap:\ncdk deploy --hotswap The output will look something like this:\n✨ Synthesis time: 6.44s ⚠️ The --hotswap flag deliberately introduces CloudFormation drift to speed up deployments ⚠️ It should only be used for development - never use it for your production Stacks! CdkWorkshopStack: deploying... ✨ hotswapping resources: ✨ Lambda Function \u0026#39;CdkWorkshopStack-HelloHandler2E4FBA4D-tEZTcXqG8YYe\u0026#39; ✨ Lambda Function \u0026#39;CdkWorkshopStack-HelloHandler2E4FBA4D-tEZTcXqG8YYe\u0026#39; hotswapped! ✅ CdkWorkshopStack ✨ Deployment time: 3.07s Stack ARN: arn:aws:cloudformation:REGION:ACCOUNT-ID:stack/CdkWorkshopStack/STACK-ID ✨ Total time: 9.51s Wow, deploying a hotswapped change took 3 seconds, while a full deployment took 67 seconds! But take a look and read the warning message thoroughly - it\u0026rsquo;s important!\n⚠️ The --hotswap flag deliberately introduces CloudFormation drift to speed up deployments ⚠️ It should only be used for development - never use it for your production Stacks! Did the code actually change? Wow that was fast. Did the code actually change? Let\u0026rsquo;s go to the AWS Lambda Console and double check!\nOpen the AWS Lambda Console (make sure you are in the correct region).\nYou should see our function:\nClick on the function name to go to the console.\nThe code should be loaded onto the screen. Did your change show up?\nCDK Watch We can do better than calling cdk deploy or cdk deploy --hotswap each time. cdk watch is similar to cdk deploy except that instead of being a one-shot operation, it monitors your code and assets for changes and attempts to perform a deployment automatically when a change is detected. By default, cdk watch will use the --hotswap flag, which inspects the changes and determines if those changes can be hotswapped. Calling cdk watch --no-hotswap will disable the hotswap behavior.\nOnce we set it up, we can use cdk watch to detect both hotswappable changes and changes that require full CloudFormation deployment.\nLooking at your cdk.json file When the cdk watch command runs, the files that it observes are determined by the \u0026quot;watch\u0026quot; setting in the cdk.json file. It has two sub-keys, \u0026quot;include\u0026quot; and \u0026quot;exclude\u0026quot;, each of which can be either a single string or an array of strings. Each entry is interpreted as a path relative to the location of the cdk.json file. Globs, both * and **, are allowed to be used.\nYour cdk.json file should look similar to this:\n{ \u0026#34;app\u0026#34;: \u0026#34;python3 app.py\u0026#34;, \u0026#34;watch\u0026#34;: { \u0026#34;include\u0026#34;: [ \u0026#34;**\u0026#34; ], \u0026#34;exclude\u0026#34;: [ \u0026#34;README.md\u0026#34;, \u0026#34;cdk*.json\u0026#34;, \u0026#34;requirements*.txt\u0026#34;, \u0026#34;source.bat\u0026#34;, \u0026#34;**/__init__.py\u0026#34;, \u0026#34;python/__pycache__\u0026#34;, \u0026#34;tests\u0026#34; ] }, \u0026#34;context\u0026#34;: { // ... } } As you can see, the sample app comes with a suggested \u0026quot;watch\u0026quot; setting. We don\u0026rsquo;t need to change anything for our use case, but if you did want cdk watch to watch other files, you can change the settings here.\nYou\u0026rsquo;re all set to start watching!\nTiming cdk watch First, call cdk watch:\ncdk watch This will trigger an initial deployment and immediately begin observing the files we\u0026rsquo;ve specified in cdk.json.\nLet\u0026rsquo;s change our lambda asset code in lambda/hello.py one more time:\nimport json def handler(event, context): print(\u0026#39;request: {}\u0026#39;.format(json.dumps(event))) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;headers\u0026#39;: { \u0026#39;Content-Type\u0026#39;: \u0026#39;text/plain\u0026#39; }, \u0026#39;body\u0026#39;: \u0026#39;Good Night, CDK! You have hit {}\\n\u0026#39;.format(event[\u0026#39;path\u0026#39;]) } Once you save the changes to your Lambda code file, cdk watch will recognize that your file has changed and trigger a new deployment. In this case, it will recognize that we can hotswap the lambda asset code, so it will bypass a CloudFormation deployment and deploy directly to the Lambda service instead.\nHow fast did deployment take?\nDetected change to \u0026#39;lambda/hello.py\u0026#39; (type: change). Triggering \u0026#39;cdk deploy\u0026#39; ✨ Synthesis time: 5.57s ⚠️ The --hotswap flag deliberately introduces CloudFormation drift to speed up deployments ⚠️ It should only be used for development - never use it for your production Stacks! CdkWorkshopStack: deploying... ✨ hotswapping resources: ✨ Lambda Function \u0026#39;CdkWorkshopStack-HelloHandler2E4FBA4D-tEZTcXqG8YYe\u0026#39; ✨ Lambda Function \u0026#39;CdkWorkshopStack-HelloHandler2E4FBA4D-tEZTcXqG8YYe\u0026#39; hotswapped! ✅ CdkWorkshopStack ✨ Deployment time: 2.54s Stack ARN: arn:aws:cloudformation:REGION:ACCOUNT-ID:stack/CdkWorkshopStack/STACK-ID ✨ Total time: 8.11s Wrap Up The rest of this tutorial will continue using cdk deploy instead of cdk watch. But if you want to, you can simply keep cdk watch on. If you need to make a full deployment, cdk watch will call cdk deploy for you.\nFor a deeper dive on cdk watch use cases, read Increasing Development Speed with CDK Watch.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/30-hello-cdk/300-cdk-watch.html","title":"CDK Watch","tags":[],"description":"","content":"Faster personal deployments This section is not necessary to complete the workshop, but we recommend that you take the time to see how cdk deploy --hotswap and cdk watch can speed up your personal deployments.\nIt\u0026rsquo;s great that we have a working lambda! But what if we want to tweak the lambda code to get it just right? Let\u0026rsquo;s say that we have now decided that we want our lambda function to respond with \u0026quot;Good Morning, CDK!\u0026quot; instead of \u0026quot;Hello, CDK\u0026quot;.\nSo far, it seems like the only tool we have at our disposal to update our stack is cdk deploy. But cdk deploy takes time; it has to deploy your CloudFormation stack and upload the lambda directory from your disk to the boostrap bucket. If we\u0026rsquo;re just changing our lambda code, we don\u0026rsquo;t actually need to update the CloudFormation stack, so that part of cdk deploy is wasted effort.\nWe really only need to update our lambda code. It would be great if we had some other mechanism for doing only that\u0026hellip;\nTiming cdk deploy First, let\u0026rsquo;s time how long it takes to run cdk deploy. It will help us baseline how long a full CloudFormation deployment takes. To do this, we are going to change the code inside lambda/hello.js:\nexports.handler = async function(event) { console.log(\u0026#34;request:\u0026#34;, JSON.stringify(event, undefined, 2)); return { statusCode: 200, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/plain\u0026#34; }, body: `Good Morning, CDK! You\u0026#39;ve hit ${event.path}\\n` }; }; Then, we can run cdk deploy:\ncdk deploy The output will look something like this:\n✨ Synthesis time: 6s CdkWorkshopStack: deploying... CdkWorkshopStack: creating CloudFormation changeset... ✅ CdkWorkshopStack ✨ Deployment time: 66.82s Stack ARN: arn:aws:cloudformation:REGION:ACCOUNT-ID:stack/CdkWorkshopStack/STACK-ID ✨ Total time: 72.82s The exact time will vary but we should get a pretty good idea of how long a normal deployment takes!\nHotswap deployments This command deliberately introduces drift in CloudFormation stacks in order to speed up deployments. For this reason, only use it for development purposes. Never use hotswap for your production deployments!\nWe can speed up that deployment time with cdk deploy --hotswap, which will assess whether a hotswap deployment can be performed instead of a CloudFormation deployment. If possible, the CDK CLI will use AWS service APIs to directly make the changes; otherwise it will fall back to performing a full CloudFormation deployment.\nHere, we will use cdk deploy --hotswap to deploy a hotswappable change to your AWS Lambda asset code.\nTiming cdk deploy --hotswap Let\u0026rsquo;s change the lambda code in lambda/hello.js another time:\nexports.handler = async function(event) { console.log(\u0026#34;request:\u0026#34;, JSON.stringify(event, undefined, 2)); return { statusCode: 200, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/plain\u0026#34; }, body: `Good Afternoon, CDK! You\u0026#39;ve hit ${event.path}\\n` }; }; Now, let\u0026rsquo;s run cdk deploy --hotswap:\ncdk deploy --hotswap The output will look something like this:\n✨ Synthesis time: 6.44s ⚠️ The --hotswap flag deliberately introduces CloudFormation drift to speed up deployments ⚠️ It should only be used for development - never use it for your production Stacks! CdkWorkshopStack: deploying... ✨ hotswapping resources: ✨ Lambda Function \u0026#39;CdkWorkshopStack-HelloHandler2E4FBA4D-tEZTcXqG8YYe\u0026#39; ✨ Lambda Function \u0026#39;CdkWorkshopStack-HelloHandler2E4FBA4D-tEZTcXqG8YYe\u0026#39; hotswapped! ✅ CdkWorkshopStack ✨ Deployment time: 3.07s Stack ARN: arn:aws:cloudformation:REGION:ACCOUNT-ID:stack/CdkWorkshopStack/STACK-ID ✨ Total time: 9.51s Wow, deploying a hotswapped change took 3 seconds, while a full deployment took 67 seconds! But take a look and read the warning message thoroughly - it\u0026rsquo;s important!\n⚠️ The --hotswap flag deliberately introduces CloudFormation drift to speed up deployments ⚠️ It should only be used for development - never use it for your production Stacks! Did the code actually change? Wow that was fast. Did the code actually change? Let\u0026rsquo;s go to the AWS Lambda Console and double check!\nOpen the AWS Lambda Console (make sure you are in the correct region).\nYou should see our function:\nClick on the function name to go to the console.\nThe code should be loaded onto the screen. Did your change show up?\nCDK Watch We can do better than calling cdk deploy or cdk deploy --hotswap each time. cdk watch is similar to cdk deploy except that instead of being a one-shot operation, it monitors your code and assets for changes and attempts to perform a deployment automatically when a change is detected. By default, cdk watch will use the --hotswap flag, which inspects the changes and determines if those changes can be hotswapped. Calling cdk watch --no-hotswap will disable the hotswap behavior.\nOnce we set it up, we can use cdk watch to detect both hotswappable changes and changes that require full CloudFormation deployment.\nLook at your cdk.json file When the cdk watch command runs, the files that it observes are determined by the \u0026quot;watch\u0026quot; setting in the cdk.json file. It has two sub-keys, \u0026quot;include\u0026quot; and \u0026quot;exclude\u0026quot;, each of which can be either a single string or an array of strings. Each entry is interpreted as a path relative to the location of the cdk.json file. Globs, both * and **, are allowed to be used.\nYour cdk.json file should look similar to this:\n{ \u0026#34;app\u0026#34;: \u0026#34;dotnet run -p src/CdkWorkshop/CdkWorkshop.csproj\u0026#34;, \u0026#34;watch\u0026#34;: { \u0026#34;include\u0026#34;: [ \u0026#34;**\u0026#34; ], \u0026#34;exclude\u0026#34;: [ \u0026#34;README.md\u0026#34;, \u0026#34;cdk*.json\u0026#34;, \u0026#34;src/*/obj\u0026#34;, \u0026#34;src/*/bin\u0026#34;, \u0026#34;src/*.sln\u0026#34;, \u0026#34;src/*/GlobalSuppressions.cs\u0026#34;, \u0026#34;src/*/*.csproj\u0026#34; ] }, \u0026#34;context\u0026#34;: { // ... } } As you can see, the sample app comes with a suggested \u0026quot;watch\u0026quot; setting. We don\u0026rsquo;t need to change anything for our use case, but if you did want cdk watch to watch other files, you can change the settings here.\nYou\u0026rsquo;re all set to start watching!\nTiming cdk watch First, call cdk watch:\ncdk watch This will trigger an initial deployment and immediately begin observing the files we\u0026rsquo;ve specified in cdk.json.\nLet\u0026rsquo;s change our lambda asset code in lambda/hello.js one more time:\nexports.handler = async function(event) { console.log(\u0026#34;request:\u0026#34;, JSON.stringify(event, undefined, 2)); return { statusCode: 200, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/plain\u0026#34; }, body: `Good Night, CDK! You\u0026#39;ve hit ${event.path}\\n` }; }; Once you save the changes to your Lambda code file, cdk watch will recognize that your file has changed and trigger a new deployment. In this case, it will recognize that we can hotswap the lambda asset code, so it will bypass a CloudFormation deployment and deploy directly to the Lambda service instead.\nHow fast did deployment take?\nDetected change to \u0026#39;lambda/hello.js\u0026#39; (type: change). Triggering \u0026#39;cdk deploy\u0026#39; ✨ Synthesis time: 5.57s ⚠️ The --hotswap flag deliberately introduces CloudFormation drift to speed up deployments ⚠️ It should only be used for development - never use it for your production Stacks! CdkWorkshopStack: deploying... ✨ hotswapping resources: ✨ Lambda Function \u0026#39;CdkWorkshopStack-HelloHandler2E4FBA4D-tEZTcXqG8YYe\u0026#39; ✨ Lambda Function \u0026#39;CdkWorkshopStack-HelloHandler2E4FBA4D-tEZTcXqG8YYe\u0026#39; hotswapped! ✅ CdkWorkshopStack ✨ Deployment time: 2.54s Stack ARN: arn:aws:cloudformation:REGION:ACCOUNT-ID:stack/CdkWorkshopStack/STACK-ID ✨ Total time: 8.11s Wrap Up The rest of this tutorial will continue using cdk deploy instead of cdk watch. But if you want to, you can simply keep cdk watch on. If you need to make a full deployment, cdk watch will call cdk deploy for you.\nFor a deeper dive on cdk watch use cases, read Increasing Development Speed with CDK Watch.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/30-hello-cdk/300-cdk-watch.html","title":"CDK Watch","tags":[],"description":"","content":"Faster personal deployments This section is not necessary to complete the workshop, but we recommend that you take the time to see how cdk deploy --hotswap and cdk watch can speed up your personal deployments.\nIt\u0026rsquo;s great that we have a working lambda! But what if we want to tweak the lambda code to get it just right? Let\u0026rsquo;s say that we have now decided that we want our lambda function to respond with \u0026quot;Good Morning, CDK!\u0026quot; instead of \u0026quot;Hello, CDK\u0026quot;.\nSo far, it seems like the only tool we have at our disposal to update our stack is cdk deploy. But cdk deploy takes time; it has to deploy your CloudFormation stack and upload the lambda directory from your disk to the boostrap bucket. If we\u0026rsquo;re just changing our lambda code, we don\u0026rsquo;t actually need to update the CloudFormation stack, so that part of cdk deploy is wasted effort.\nWe really only need to update our lambda code. It would be great if we had some other mechanism for doing only that\u0026hellip;\nTiming cdk deploy First, let\u0026rsquo;s time how long it takes to run cdk deploy. It will help us baseline how long a full CloudFormation deployment takes. To do this, we are going to change the code inside lambda/hello.js:\nexports.handler = async function(event) { console.log(\u0026#34;request:\u0026#34;, JSON.stringify(event, undefined, 2)); return { statusCode: 200, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/plain\u0026#34; }, body: `Good Morning, CDK! You\u0026#39;ve hit ${event.path}\\n` }; }; Then, we can run cdk deploy:\ncdk deploy The output will look something like this:\n✨ Synthesis time: 6s CdkWorkshopStack: deploying... CdkWorkshopStack: creating CloudFormation changeset... ✅ CdkWorkshopStack ✨ Deployment time: 66.82s Stack ARN: arn:aws:cloudformation:REGION:ACCOUNT-ID:stack/CdkWorkshopStack/STACK-ID ✨ Total time: 72.82s The exact time will vary but we should get a pretty good idea of how long a normal deployment takes!\nHotswap deployments This command deliberately introduces drift in CloudFormation stacks in order to speed up deployments. For this reason, only use it for development purposes. Never use hotswap for your production deployments!\nWe can speed up that deployment time with cdk deploy --hotswap, which will assess whether a hotswap deployment can be performed instead of a CloudFormation deployment. If possible, the CDK CLI will use AWS service APIs to directly make the changes; otherwise it will fall back to performing a full CloudFormation deployment.\nHere, we will use cdk deploy --hotswap to deploy a hotswappable change to your AWS Lambda asset code.\nTiming cdk deploy --hotswap Let\u0026rsquo;s change the lambda code in lambda/hello.js another time:\nexports.handler = async function(event) { console.log(\u0026#34;request:\u0026#34;, JSON.stringify(event, undefined, 2)); return { statusCode: 200, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/plain\u0026#34; }, body: `Good Afternoon, CDK! You\u0026#39;ve hit ${event.path}\\n` }; }; Now, let\u0026rsquo;s run cdk deploy --hotswap:\ncdk deploy --hotswap The output will look something like this:\n✨ Synthesis time: 6.44s ⚠️ The --hotswap flag deliberately introduces CloudFormation drift to speed up deployments ⚠️ It should only be used for development - never use it for your production Stacks! CdkWorkshopStack: deploying... ✨ hotswapping resources: ✨ Lambda Function \u0026#39;CdkWorkshopStack-HelloHandler2E4FBA4D-tEZTcXqG8YYe\u0026#39; ✨ Lambda Function \u0026#39;CdkWorkshopStack-HelloHandler2E4FBA4D-tEZTcXqG8YYe\u0026#39; hotswapped! ✅ CdkWorkshopStack ✨ Deployment time: 3.07s Stack ARN: arn:aws:cloudformation:REGION:ACCOUNT-ID:stack/CdkWorkshopStack/STACK-ID ✨ Total time: 9.51s Wow, deploying a hotswapped change took 3 seconds, while a full deployment took 67 seconds! But take a look and read the warning message thoroughly - it\u0026rsquo;s important!\n⚠️ The --hotswap flag deliberately introduces CloudFormation drift to speed up deployments ⚠️ It should only be used for development - never use it for your production Stacks! Did the code actually change? Wow that was fast. Did the code actually change? Let\u0026rsquo;s go to the AWS Lambda Console and double check!\nOpen the AWS Lambda Console (make sure you are in the correct region).\nYou should see our function:\nClick on the function name to go to the console.\nThe code should be loaded onto the screen. Did your change show up?\nCDK Watch We can do better than calling cdk deploy or cdk deploy --hotswap each time. cdk watch is similar to cdk deploy except that instead of being a one-shot operation, it monitors your code and assets for changes and attempts to perform a deployment automatically when a change is detected. By default, cdk watch will use the --hotswap flag, which inspects the changes and determines if those changes can be hotswapped. Calling cdk watch --no-hotswap will disable the hotswap behavior.\nOnce we set it up, we can use cdk watch to detect both hotswappable changes and changes that require full CloudFormation deployment.\nLook at your cdk.json file When the cdk watch command runs, the files that it observes are determined by the \u0026quot;watch\u0026quot; setting in the cdk.json file. It has two sub-keys, \u0026quot;include\u0026quot; and \u0026quot;exclude\u0026quot;, each of which can be either a single string or an array of strings. Each entry is interpreted as a path relative to the location of the cdk.json file. Globs, both * and **, are allowed to be used.\nYour cdk.json file should look similar to this:\n{ \u0026#34;app\u0026#34;: \u0026#34;mvn -e -q compile exec:java\u0026#34;, \u0026#34;watch\u0026#34;: { \u0026#34;include\u0026#34;: [ \u0026#34;**\u0026#34; ], \u0026#34;exclude\u0026#34;: [ \u0026#34;README.md\u0026#34;, \u0026#34;cdk*.json\u0026#34;, \u0026#34;target\u0026#34;, \u0026#34;pom.xml\u0026#34;, \u0026#34;src/test\u0026#34; ] }, \u0026#34;context\u0026#34;: { // ... } } As you can see, the sample app comes with a suggested \u0026quot;watch\u0026quot; setting. We don\u0026rsquo;t need to change anything for our use case, but if you did want cdk watch to watch other files, you can change the settings here.\nYou\u0026rsquo;re all set to start watching!\nTiming cdk watch First, call cdk watch:\ncdk watch This will trigger an initial deployment and immediately begin observing the files we\u0026rsquo;ve specified in cdk.json.\nLet\u0026rsquo;s change our lambda asset code in lambda/hello.js one more time:\nexports.handler = async function(event) { console.log(\u0026#34;request:\u0026#34;, JSON.stringify(event, undefined, 2)); return { statusCode: 200, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/plain\u0026#34; }, body: `Good Night, CDK! You\u0026#39;ve hit ${event.path}\\n` }; }; Once you save the changes to your Lambda code file, cdk watch will recognize that your file has changed and trigger a new deployment. In this case, it will recognize that we can hotswap the lambda asset code, so it will bypass a CloudFormation deployment and deploy directly to the Lambda service instead.\nHow fast did deployment take?\nDetected change to \u0026#39;lambda/hello.js\u0026#39; (type: change). Triggering \u0026#39;cdk deploy\u0026#39; ✨ Synthesis time: 5.57s ⚠️ The --hotswap flag deliberately introduces CloudFormation drift to speed up deployments ⚠️ It should only be used for development - never use it for your production Stacks! CdkWorkshopStack: deploying... ✨ hotswapping resources: ✨ Lambda Function \u0026#39;CdkWorkshopStack-HelloHandler2E4FBA4D-tEZTcXqG8YYe\u0026#39; ✨ Lambda Function \u0026#39;CdkWorkshopStack-HelloHandler2E4FBA4D-tEZTcXqG8YYe\u0026#39; hotswapped! ✅ CdkWorkshopStack ✨ Deployment time: 2.54s Stack ARN: arn:aws:cloudformation:REGION:ACCOUNT-ID:stack/CdkWorkshopStack/STACK-ID ✨ Total time: 8.11s Wrap Up The rest of this tutorial will continue using cdk deploy instead of cdk watch. But if you want to, you can simply keep cdk watch on. If you need to make a full deployment, cdk watch will call cdk deploy for you.\nFor a deeper dive on cdk watch use cases, read Increasing Development Speed with CDK Watch.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/40-hit-counter/300-resources.html","title":"Define resources","tags":[],"description":"","content":"Add resources to the hit counter construct Now, let\u0026rsquo;s define the AWS Lambda function and the DynamoDB table in our HitCounter construct. Go back to cdkworkshop/hitcounter.py and add the following highlighted code:\nfrom constructs import Construct from aws_cdk import ( aws_lambda as _lambda, aws_dynamodb as ddb, ) class HitCounter(Construct): @property def handler(self): return self._handler def __init__(self, scope: Construct, id: str, downstream: _lambda.IFunction, **kwargs): super().__init__(scope, id, **kwargs) table = ddb.Table( self, \u0026#39;Hits\u0026#39;, partition_key={\u0026#39;name\u0026#39;: \u0026#39;path\u0026#39;, \u0026#39;type\u0026#39;: ddb.AttributeType.STRING} ) self._handler = _lambda.Function( self, \u0026#39;HitCountHandler\u0026#39;, runtime=_lambda.Runtime.PYTHON_3_7, handler=\u0026#39;hitcount.handler\u0026#39;, code=_lambda.Code.from_asset(\u0026#39;lambda\u0026#39;), environment={ \u0026#39;DOWNSTREAM_FUNCTION_NAME\u0026#39;: downstream.function_name, \u0026#39;HITS_TABLE_NAME\u0026#39;: table.table_name, } ) What did we do here? This code is hopefully quite easy to understand:\nWe defined a DynamoDB table with path as the partition key (every DynamoDB table must have a single partition key). We defined a Lambda function which is bound to the lambda/hitcount.handler code. We wired the Lambda\u0026rsquo;s environment variables to the function_name and table_name of our resources. Late-bound values The function_name and table_name properties are values that only resolve when we deploy our stack (notice that we haven\u0026rsquo;t configured these physical names when we defined the table/function, only logical IDs). This means that if you print their values during synthesis, you will get a \u0026ldquo;TOKEN\u0026rdquo;, which is how the CDK represents these late-bound values. You should treat tokens as opaque strings. This means you can concatenate them together for example, but don\u0026rsquo;t be tempted to parse them in your code.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/40-hit-counter/300-resources.html","title":"Define resources","tags":[],"description":"","content":"Add resources to the hit counter construct Now, let\u0026rsquo;s define the AWS Lambda function and the DynamoDB table in our HitCounter construct.\nNow, go back to src/CdkWorkshop/HitCounter.cs and add the following highlighted code:\nusing Amazon.CDK; using Amazon.CDK.AWS.DynamoDB; using Amazon.CDK.AWS.Lambda; using Constructs; using System.Collections.Generic; namespace CdkWorkshop { public class HitCounterProps { // The function for which we want to count url hits public IFunction Downstream { get; set; } } public class HitCounter : Construct { public Function Handler { get; } public HitCounter(Construct scope, string id, HitCounterProps props) : base(scope, id) { var table = new Table(this, \u0026#34;Hits\u0026#34;, new TableProps { PartitionKey = new Attribute { Name = \u0026#34;path\u0026#34;, Type = AttributeType.STRING } }); Handler = new Function(this, \u0026#34;HitCounterHandler\u0026#34;, new FunctionProps { Runtime = Runtime.NODEJS_14_X, Handler = \u0026#34;hitcounter.handler\u0026#34;, Code = Code.FromAsset(\u0026#34;lambda\u0026#34;), Environment = new Dictionary\u0026lt;string, string\u0026gt; { [\u0026#34;DOWNSTREAM_FUNCTION_NAME\u0026#34;] = props.Downstream.FunctionName, [\u0026#34;HITS_TABLE_NAME\u0026#34;] = table.TableName } }); } } } What did we do here? This code is hopefully quite easy to understand:\nWe defined a DynamoDB table with path as the partition key (every DynamoDB table must have a single partition key). We defined a Lambda function which is bound to the lambda/hitcounter.handler code. We wired the Lambda\u0026rsquo;s environment variables to the FunctionName and TableName of our resources. Late-bound values The FunctionName and TableName properties are values that only resolve when we deploy our stack (notice that we haven\u0026rsquo;t configured these physical names when we defined the table/function, only logical IDs). This means that if you print their values during synthesis, you will get a \u0026ldquo;TOKEN\u0026rdquo;, which is how the CDK represents these late-bound values. You should treat tokens as opaque strings. This means you can concatenate them together for example, but don\u0026rsquo;t be tempted to parse them in your code.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/40-hit-counter/300-resources.html","title":"Define resources","tags":[],"description":"","content":"Add resources to the hit counter construct Now, let\u0026rsquo;s define the AWS Lambda function and the DynamoDB table in our HitCounter construct.\nNow, go back to ~/HitCounter.java and add the following highlighted code:\npackage com.myorg; import java.util.HashMap; import java.util.Map; import software.constructs.Construct; import software.amazon.awscdk.services.dynamodb.Attribute; import software.amazon.awscdk.services.dynamodb.AttributeType; import software.amazon.awscdk.services.dynamodb.Table; import software.amazon.awscdk.services.lambda.Code; import software.amazon.awscdk.services.lambda.Function; import software.amazon.awscdk.services.lambda.Runtime; public class HitCounter extends Construct { private final Function handler; private final Table table; public HitCounter(final Construct scope, final String id, final HitCounterProps props) { super(scope, id); this.table = Table.Builder.create(this, \u0026#34;Hits\u0026#34;) .partitionKey(Attribute.builder() .name(\u0026#34;path\u0026#34;) .type(AttributeType.STRING) .build()) .build(); final Map\u0026lt;String, String\u0026gt; environment = new HashMap\u0026lt;\u0026gt;(); environment.put(\u0026#34;DOWNSTREAM_FUNCTION_NAME\u0026#34;, props.getDownstream().getFunctionName()); environment.put(\u0026#34;HITS_TABLE_NAME\u0026#34;, this.table.getTableName()); this.handler = Function.Builder.create(this, \u0026#34;HitCounterHandler\u0026#34;) .runtime(Runtime.NODEJS_14_X) .handler(\u0026#34;hitcounter.handler\u0026#34;) .code(Code.fromAsset(\u0026#34;lambda\u0026#34;)) .environment(environment) .build(); } /** * @return the counter definition */ public Function getHandler() { return this.handler; } /** * @return the counter table */ public Table getTable() { return this.table; } } What did we do here? This code is hopefully easy to understand:\nWe defined a DynamoDB table, table, with path as the partition key (every DynamoDB table must have a single partition key). We defined a Lambda function which is bound to the lambda/hitcounter.handler code. We wired the Lambda\u0026rsquo;s environment variables to the Function.name and Table.name of our resources via environment.put(...). Late-bound values The FunctionName and TableName properties are values that only resolve when we deploy our stack (notice that we haven\u0026rsquo;t configured these physical names when we defined the table/function, only logical IDs). This means that if you print their values during synthesis, you will get a \u0026ldquo;TOKEN\u0026rdquo;, which is how the CDK represents these late-bound values. You should treat tokens as opaque strings. This means you can concatenate them together for example, but don\u0026rsquo;t be tempted to parse them in your code.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/15-prerequisites/300-nodejs.html","title":"Node.js","tags":[],"description":"","content":"The AWS CDK uses Node.js (\u0026gt;= 10.13.0, except for versions 13.0.0 - 13.6.0). A version in active long-term support (16.x at this writing) is recommended.\nTo install Node.js visit the node.js website.\nWindows: if you have an old version of Node.js installed on your system, it may be required to run the .msi installation as Administrator. If you already have Node.js installed, verify that you have a compatible version:\nnode --version Output should be \u0026gt;= 10.13.0:\nv10.3.0 "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/20-create-project/300-structure.html","title":"Project structure","tags":[],"description":"","content":"Open your IDE Now\u0026rsquo;s a good time to open the project in your favorite IDE and explore.\nIf you use VSCode, you can just type code . within the project directory.\nExplore your project directory You\u0026rsquo;ll see something like this:\n.venv - The python virtual envirnment information discussed in the previous section. cdk_workshop — A Python module directory. cdk_workshop.egg-info - Folder that contains build information relevant for the packaging on the project cdk_workshop_stack.py—A custom CDK stack construct for use in your CDK application. tests — Contains all tests. unit — Contains unit tests. test_cdk_workshop.py—A trivial test of the custom CDK stack created in the cdk_workshop package. This is mainly to demonstrate how tests can be hooked up to the project. app.py — The “main” for this sample application. cdk.json — A configuration file for CDK that defines what executable CDK should run to generate the CDK construct tree. README.md — The introductory README for this project. requirements.txt—This file is used by pip to install all of the dependencies for your application. In this case, it contains only -e . This tells pip to install the requirements specified in setup.py. It also tells pip to run python setup.py develop to install the code in the cdk_workshop module so that it can be edited in place. setup.py — Defines how this Python package would be constructed and what the dependencies are. Your app\u0026rsquo;s entry point Let\u0026rsquo;s have a quick look at app.py:\n#!/usr/bin/env python3 import aws_cdk as cdk from cdk_workshop.cdk_workshop_stack import CdkWorkshopStack app = cdk.App() CdkWorkshopStack(app, \u0026#34;cdk-workshop\u0026#34;) app.synth() This code loads and instantiates an instance of the CdkWorkshopStack class from cdk_workshop/cdk_workshop_stack.py file. We won\u0026rsquo;t need to look at this file anymore.\nThe main stack Open up cdk_workshop/cdk_workshop_stack.py. This is where the meat of our application is:\nfrom constructs import Construct from aws_cdk import ( Duration, Stack, aws_sqs as sqs, aws_sns as sns, aws_sns_subscriptions as subs, ) class CdkWorkshopStack(Stack): def __init__(self, scope: Construct, id: str, **kwargs) -\u0026gt; None: super().__init__(scope, id, **kwargs) queue = sqs.Queue( self, \u0026#34;CdkWorkshopQueue\u0026#34;, visibility_timeout=Duration.seconds(300), ) topic = sns.Topic( self, \u0026#34;CdkWorkshopTopic\u0026#34; ) topic.add_subscription(subs.SqsSubscription(queue)) As you can see, our app was created with sample CDK stack (CdkWorkshopStack).\nThe stack includes:\nSQS Queue (sqs.Queue) SNS Topic (sns.Topic) Subscribes the queue to receive any messages published to the topic (topic.add_subscription) "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/20-create-project/300-structure.html","title":"Project structure","tags":[],"description":"","content":"Open your IDE Now\u0026rsquo;s a good time to open the project in your favorite IDE and explore.\nIf you use VSCode, you can just type code . within the project directory.\nYou may see a notification saying Required assets to build and debug are missing from 'YOURPROJECT'. Add them?\nThis can be ignored for our purposes.\nExplore your project directory You\u0026rsquo;ll see something like this:\nsrc/CdkWorkshop/Program.cs is the entrypoint for the CDK application it will load the stack defined in src/CdkWorkshop/CdkWorkshopStack.cs src/CdkWorkshop/CdkWorkshopStack.cs is where your CDK application\u0026rsquo;s main stack is defined. This is the file we\u0026rsquo;ll be spending most of our time in. cdk.json tells the toolkit how to run your app. In our case it will be \u0026quot;dotnet run -p src/CdkWorkshop/CdkWorkshop.csproj\u0026quot; src/CdkWorkshop/CdkWorkshop.csproj is the C# project file. It is an xml file and contains information on references. This will be useful to you down the line, but is not relevant for the purposes of this workshop. src/CdkWorkshop/GlobalSuppressions.cs disables the Roslyn analyzer for RECS0026:Possible unassigned object created by 'new' as this generates many false positives with CDK. src/CdkWorkshop.sln is the C# solution file that provides build information. You should not need to interface with this file. .gitignore tells git which files to include/exclude from source control and when publishing this module to the package manager. The src/CdkWorkshop/bin and src/CdkWorkshop/obj folders are the build folders for the project and can be ignored. Your app\u0026rsquo;s entry point Let\u0026rsquo;s have a quick look at src/CdkWorkshop/Program.cs:\nusing Amazon.CDK; namespace CdkWorkshop { class Program { static void Main(string[] args) { var app = new App(); new CdkWorkshopStack(app, \u0026#34;CdkWorkshopStack\u0026#34;); app.Synth(); } } } This code loads and instantiates the CdkWorkshopStack class from the src/CdkWorkshop/CdkWorkshopStack.cs file. We won\u0026rsquo;t need to look at this file anymore.\nThe main stack Open up src/CdkWorkshop/CdkWorkshopStack.cs. This is where the meat of our application is:\nusing Amazon.CDK; using Amazon.CDK.AWS.SNS; using Amazon.CDK.AWS.SNS.Subscriptions; using Amazon.CDK.AWS.SQS; using Constructs; namespace CdkWorkshop { public class CdkWorkshopStack : Stack { public CdkWorkshopStack(Construct scope, string id, IStackProps props = null) : base(scope, id, props) { // The CDK includes built-in constructs for most resource types, such as Queues and Topics. var queue = new Queue(this, \u0026#34;CdkWorkshopQueue\u0026#34;, new QueueProps { VisibilityTimeout = Duration.Seconds(300) }); var topic = new Topic(this, \u0026#34;CdkWorkshopTopic\u0026#34;); topic.AddSubscription(new SqsSubscription(queue)); } } } As you can see, our app was created with a sample CDK stack (CdkWorkshopStack).\nThe stack includes:\nSQS Queue (new Queue) SNS Topic (new Topic) Subscribing the queue to receive any messages published to the topic (topic.AddSubscription) "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/20-create-project/300-structure.html","title":"Project structure","tags":[],"description":"","content":"Open your IDE Now\u0026rsquo;s a good time to open the project in your favorite IDE and explore.\nIf you use VSCode, you can just type code . within the project directory.\nExplore your project directory You\u0026rsquo;ll see something like this:\nsrc/main/java/com/myorg/ is the main project directory for Java code in the app, and will be henceforth referred to (to shorten the paths) as ~/ ~/CdkWorkshopApp.java is the entrypoint for the CDK application it will load the stack defined in ~/CdkWorkshopStack.java ~/CdkWorkshopStack.java is where your CDK application\u0026rsquo;s main stack is defined. This is the file we\u0026rsquo;ll be spending most of our time in. cdk.json tells the toolkit how to run your app. In our case it will be \u0026quot;mvn -q exec:java\u0026quot; pom.xml is the Maven project file. It is an xml file and contains information on build properties, dependencies, and app information. This will be useful to you down the line, but is not relevant for the purposes of this workshop. test/java/com/myorg/CdkWorkshopStackTest.java Is a build test that is run againt the Java application on build and will indicated success or failure in the terminal. We will not be using this for the purposes of the workshop. .gitignore tells git which files to include/exclude from source control. .classpath, .project, .settings/, and target/ files/folders are automated Java/Maven project files. These should be ignored. Your app\u0026rsquo;s entry point Let\u0026rsquo;s have a quick look at ~/CdkWorkshopApp.java:\npackage com.myorg; import software.amazon.awscdk.App; public final class CdkWorkshopApp { public static void main(final String[] args) { App app = new App(); new CdkWorkshopStack(app, \u0026#34;CdkWorkshopStack\u0026#34;); app.synth(); } } This code loads and instantiates the CdkWorkshopStack class from the ~/CdkWorkshopStack.java file. We won\u0026rsquo;t need to look at this file anymore.\nThe main stack Open up ~/CdkWorkshopStack.java. This is where the meat of our application is:\npackage com.myorg; import software.constructs.Construct; import software.amazon.awscdk.Duration; import software.amazon.awscdk.Stack; import software.amazon.awscdk.StackProps; import software.amazon.awscdk.services.sns.Topic; import software.amazon.awscdk.services.sns.subscriptions.SqsSubscription; import software.amazon.awscdk.services.sqs.Queue; public class CdkWorkshopStack extends Stack { public CdkWorkshopStack(final Construct parent, final String id) { this(parent, id, null); } public CdkWorkshopStack(final Construct parent, final String id, final StackProps props) { super(parent, id, props); final Queue queue = Queue.Builder.create(this, \u0026#34;CdkWorkshopQueue\u0026#34;) .visibilityTimeout(Duration.seconds(300)) .build(); final Topic topic = Topic.Builder.create(this, \u0026#34;CdkWorkshopTopic\u0026#34;) .displayName(\u0026#34;My First Topic Yeah\u0026#34;) .build(); topic.addSubscription(new SqsSubscription(queue)); } } As you can see, our app was created with a sample CDK stack (CdkWorkshopStack).\nThe stack includes:\nSQS Queue (final Queue queue) SNS Topic (final Topic topic) Subscribing the queue to receive any messages published to the topic (topic.AddSubscription) "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/70-advanced-topics/100-construct-testing/2000-validation-tests.html","title":"Validation Tests","tags":[],"description":"","content":"Validation Tests Sometimes we want the inputs to be configurable, but we also want to put constraints on those inputs or validate that the input is valid.\nSuppose for the HitCounter construct we want to allow the user to specify the readCapacity on the DynamoDB table, but we also want to ensure the value is within a reasonable range. We can write a test to make sure that the validation logic works: pass in invalid values and see what happens.\nFirst, add a readCapacity property to the HitCounterProps interface:\nexport interface HitCounterProps { /** the function for which we want to count url hits **/ downstream: lambda.IFunction; /** * The read capacity units for the table * * Must be greater than 5 and lower than 20 * * @default 5 */ readCapacity?: number; } Then update the DynamoDB table resource to add the readCapacity property.\nconst table = new dynamodb.Table(this, \u0026#39;Hits\u0026#39;, { partitionKey: { name: \u0026#39;path\u0026#39;, type: dynamodb.AttributeType.STRING }, encryption: dynamodb.TableEncryption.AWS_MANAGED, readCapacity: props.readCapacity ?? 5 }); Now add a validation which will throw an error if the readCapacity is not in the allowed range.\nexport class HitCounter extends Construct { /** allows accessing the counter function */ public readonly handler: lambda.Function; /** the hit counter table */ public readonly table: dynamodb.Table; constructor(scope: Construct, id: string, props: HitCounterProps) { if (props.readCapacity !== undefined \u0026amp;\u0026amp; (props.readCapacity \u0026lt; 5 || props.readCapacity \u0026gt; 20)) { throw new Error(\u0026#39;readCapacity must be greater than 5 and less than 20\u0026#39;); } super(scope, id); // ... } } Now lets add a test that validates the error is thrown.\ntest(\u0026#39;read capacity can be configured\u0026#39;, () =\u0026gt; { const stack = new cdk.Stack(); expect(() =\u0026gt; { new HitCounter(stack, \u0026#39;MyTestConstruct\u0026#39;, { downstream: new lambda.Function(stack, \u0026#39;TestFunction\u0026#39;, { runtime: lambda.Runtime.NODEJS_14_X, handler: \u0026#39;hello.handler\u0026#39;, code: lambda.Code.fromAsset(\u0026#39;lambda\u0026#39;) }), readCapacity: 3 }); }).toThrowError(/readCapacity must be greater than 5 and less than 20/); }); Run the test.\n$ npm run test You should see an output like this:\n$ npm run test \u0026gt; cdk-workshop@0.1.0 test /home/aws-cdk-intro-workshop \u0026gt; jest PASS test/hitcounter.test.ts ✓ DynamoDB Table Created (206 ms) ✓ Lambda Has Environment Variables (61 ms) ✓ DynamoDB Table Created With Encryption (55 ms) ✓ Read Capacity can be configured (14 ms) Test Suites: 1 passed, 1 total Tests: 4 passed, 4 total Snapshots: 0 total Time: 4.755 s, estimated 5 s Ran all test suites. "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/70-advanced-topics/100-construct-testing/2000-validation-tests.html","title":"Validation Tests","tags":[],"description":"","content":"Validation Tests Sometimes we want the inputs to be configurable, but we also want to put constraints on those inputs or validate that the input is valid.\nSuppose for the HitCounter construct we want to allow the user to specify the read_capacity on the DynamoDB table, but we also want to ensure the value is within a reasonable range. We can write a test to make sure that the validation logic works: pass in invalid values and see what happens.\nFirst, add a read_capacity property to HitCounter:\nclass HitCounter(Construct): @property def handler(self): return self._handler @property def table(self): return self._table def __init__(self, scope: Construct, id: str, downstream: _lambda.IFunction, read_capacity: int = 5, **kwargs): ... Then update the DynamoDB table resource to add the read_capacity property.\nself._table = ddb.Table( self, \u0026#39;Hits\u0026#39;, partition_key={\u0026#39;name\u0026#39;: \u0026#39;path\u0026#39;, \u0026#39;type\u0026#39;: ddb.AttributeType.STRING}, encryption=ddb.TableEncryption.AWS_MANAGED, read_capacity=read_capacity, ) Now add a validation which will throw an error if the read_capacity is not in the allowed range.\nclass HitCounter(Construct): @property def handler(self): return self._handler @property def table(self): return self._table def __init__(self, scope: Construct, id: str, downstream: _lambda.IFunction, read_capacity: int = 5, **kwargs): if read_capacity \u0026lt; 5 or read_capacity \u0026gt; 20: raise ValueError(\u0026#34;readCapacity must be greater than 5 or less than 20\u0026#34;) super().__init__(scope, id, **kwargs) ... Now lets add a test that validates the error is thrown.\ndef test_dynamodb_raises(): stack = Stack() with pytest.raises(Exception): HitCounter(stack, \u0026#34;HitCounter\u0026#34;, downstream=_lambda.Function(stack, \u0026#34;TestFunction\u0026#34;, runtime=_lambda.Runtime.PYTHON_3_7, handler=\u0026#39;hello.handler\u0026#39;, code=_lambda.Code.from_asset(\u0026#39;lambda\u0026#39;)), read_capacity=1, ) Run the test.\n$ pytest You should see an output like this:\n$ pytest ================================================================================================= test session starts ================================================================================================= platform linux -- Python 3.9.6, pytest-6.2.5, py-1.10.0, pluggy-1.0.0 rootdir: ... collected 4 items tests/unit/test_cdk_workshop.py .... [100%] ================================================================================================== 4 passed in 1.59s ================================================================================================== "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/70-advanced-topics/100-construct-testing/2000-validation-tests.html","title":"Validation Tests","tags":[],"description":"","content":"Validation Tests Sometimes we want the inputs to be configurable, but we also want to put constraints on those inputs or validate that the input is valid.\nSuppose for the HitCounter construct we want to allow the user to specify the readCapacity on the DynamoDB table, but we also want to ensure the value is within a reasonable range. We can write a test to make sure that the validation logic works: pass in invalid values and see what happens.\nFirst, add a readCapacity property to HitCounterProps:\nEdit HitCounterProps.java package com.myorg; import software.amazon.awscdk.services.lambda.IFunction; public interface HitCounterProps { // Public constructor for the props builder public static Builder builder() { return new Builder(); } // The function for which we want to count url hits IFunction getDownstream(); Number getReadCapacity(); // The builder for the props interface public static class Builder { private IFunction downstream; private Number readCapacity; public Builder downstream(final IFunction function) { this.downstream = function; return this; } public Builder readCapacity(final Number readCapacity) { this.readCapacity = readCapacity; return this; } public HitCounterProps build() { if(this.downstream == null) { throw new NullPointerException(\u0026#34;The downstream property is required!\u0026#34;); } return new HitCounterProps() { @Override public IFunction getDownstream() { return downstream; } @Override public Number getReadCapacity() { return readCapacity; } }; } } }\nThen update the DynamoDB table resource to add the readCapacity property.\nNumber readCapacity = (props.getReadCapacity() == null) ? 5 : props.getReadCapacity(); this.table = Table.Builder.create(this, \u0026#34;Hits\u0026#34;) .partitionKey(Attribute.builder() .name(\u0026#34;path\u0026#34;) .type(AttributeType.STRING) .build()) .encryption(TableEncryption.AWS_MANAGED) .readCapacity(readCapacity) .build(); Now add a validation which will throw an error if the readCapacity is not in the allowed range.\npublic class HitCounter extends Construct { private final Function handler; private final Table table; public HitCounter(final Construct scope, final String id, final HitCounterProps props) throws RuntimeException { super(scope, id); if (props.getReadCapacity() != null) { if (props.getReadCapacity().intValue() \u0026lt; 5 || props.getReadCapacity().intValue() \u0026gt; 20) { throw new RuntimeException(\u0026#34;readCapacity must be greater than 5 or less than 20\u0026#34;); } } ... } } Now lets add a test that validates the error is thrown.\n@Test public void testDynamoDBRaises() throws IOException { Stack stack = new Stack(); Function hello = Function.Builder.create(stack, \u0026#34;HelloHandler\u0026#34;) .runtime(Runtime.NODEJS_14_X) .code(Code.fromAsset(\u0026#34;lambda\u0026#34;)) .handler(\u0026#34;hello.handler\u0026#34;) .build(); assertThrows(RuntimeException.class, () -\u0026gt; { new HitCounter(stack, \u0026#34;HelloHitCounter\u0026#34;, HitCounterProps.builder() .downstream(hello) .readCapacity(1) .build()); }); } Run the test.\n$ mvn test You should see an output like this:\n$ mvn test ------------------------------------------------------- T E S T S ------------------------------------------------------- Running com.myorg.HitCounterTest Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.828 sec Results : Tests run: 4, Failures: 0, Errors: 0, Skipped: 0 [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 10.148 s [INFO] Finished at: 2021-11-01T12:54:45Z [INFO] ------------------------------------------------------------------------ "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/20-create-project/300-structure.html","title":"プロジェクト構造","tags":[],"description":"","content":"IDEを開く 使い慣れたIDEでプロジェクトを開いてみましょう。\nCloud9 を使用する場合は、すでにIDEの画面で操作を行っています。\nVSCodeを使用する場合は、 code . コマンドをプロジェクトディレクトリ内で実行すれば簡単に開けます。\nプロジェクトディレクトリを確認する 以下のようなディレクトリ構成が確認できます。\nlib/cdk-workshop-stack.ts CDKアプリケーションのメインスタックが定義されます。 今回のワークショップではこのファイルを主に修正します。 bin/cdk-workshop.ts CDKアプリケーションのエントリポイントです。 lib/cdk-workshop-stack.ts で定義されたスタックをロードします。 package.json npmモジュールのマニフェストです。 アプリの名前、バージョン、依存関係、\u0026ldquo;watch\u0026rdquo; や \u0026ldquo;build\u0026rdquo; 用のビルドスクリプトなどの情報が含まれます（package-lock.json はnpmによって管理されます） cdk.json アプリの実行方法をツールキットに指示させるためのファイルです。 今回の場合は、 \u0026quot;npx ts-node bin/cdk-workshop.ts\u0026quot; です。 tsconfig.json プロジェクトの TypeScript設定 です。 .gitignore, .npmignore Gitとnpm用のファイルです。 ソースコードの管理に含める/除外するファイルと、パッケージマネージャーへの公開用設定が含まれています。 node_modules npmによって管理され、プロジェクトのすべての依存関係が含まれます。 アプリのエントリポイント bin/cdk-workshop.tsを簡単に見てみましょう。\n#!/usr/bin/env node import * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import { CdkWorkshopStack } from \u0026#39;../lib/cdk-workshop-stack\u0026#39;; const app = new cdk.App(); new CdkWorkshopStack(app, \u0026#39;CdkWorkshopStack\u0026#39;); このコードは、lib/cdk-workshop-stack.tsファイルを開き、 CdkWorkshopStack クラス をロードして初期化するものです。 一度読んだら、もうこのファイルを見る必要はありません。\nメインスタック lib/cdk-workshop-stack.tsを開いてみましょう。これがアプリケーションの要です。\nimport { Duration, Stack, StackProps } from \u0026#39;aws-cdk-lib\u0026#39;; import * as sns from \u0026#39;aws-cdk-lib/aws-sns\u0026#39;; import * as subs from \u0026#39;aws-cdk-lib/aws-sns-subscriptions\u0026#39;; import * as sqs from \u0026#39;aws-cdk-lib/aws-sqs\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; export class CdkWorkshopStack extends Stack { constructor(scope: Construct, id: string, props?: StackProps) { super(scope, id, props); const queue = new sqs.Queue(this, \u0026#39;CdkWorkshopQueue\u0026#39;, { visibilityTimeout: Duration.seconds(300) }); const topic = new sns.Topic(this, \u0026#39;CdkWorkshopTopic\u0026#39;); topic.addSubscription(new subs.SqsSubscription(queue)); } } ご覧のとおり、アプリはサンプルCDKスタック(CdkWorkshopStack)です.\nこのスタックは次のものを含みます。\nSQS キュー (new sqs.Queue) SNS トピック (new sns.Topic) キューをサブスクライブして、トピックに発行されたメッセージを受信します (topic.addSubscription) "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/40-hit-counter/300-resources.html","title":"リソースの定義","tags":[],"description":"","content":"HitCounterコンストラクトにリソースを追加する 次に、Lambda関数とDynamoDBテーブルをHitCounterコンストラクトに定義します。\nlib/hitcounter.ts に戻って、以下のコードを追記しましょう。\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import * as lambda from \u0026#39;aws-cdk-lib/aws-lambda\u0026#39;; import * as dynamodb from \u0026#39;aws-cdk-lib/aws-dynamodb\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; export interface HitCounterProps { /** the function for which we want to count url hits **/ downstream: lambda.IFunction; } export class HitCounter extends Construct { /** allows accessing the counter function */ public readonly handler: lambda.Function; constructor(scope: Construct, id: string, props: HitCounterProps) { super(scope, id); const table = new dynamodb.Table(this, \u0026#39;Hits\u0026#39;, { partitionKey: { name: \u0026#39;path\u0026#39;, type: dynamodb.AttributeType.STRING } }); this.handler = new lambda.Function(this, \u0026#39;HitCounterHandler\u0026#39;, { runtime: lambda.Runtime.NODEJS_16_X, handler: \u0026#39;hitcounter.handler\u0026#39;, code: lambda.Code.fromAsset(\u0026#39;lambda\u0026#39;), environment: { DOWNSTREAM_FUNCTION_NAME: props.downstream.functionName, HITS_TABLE_NAME: table.tableName } }); } } コードの解説 DynamoDBテーブルにpathパーティションキーを定義しました。 lambda/hitcounter.handlerにバインドされるLambda関数を定義しました。 Lambdaの環境変数とdownstream.functionName、table.tableNameとを紐付けました。 遅延バインディング値 functionNameとtableNameプロパティは、CloudFormationスタックをデプロイするタイミングで解決される値です （テーブル/関数を定義した時点では、まだ物理名が決まっていないことに注目してください。論理IDだけが決まっています。）。 CloudFormationテンプレート生成時にそれらの値を表示すると、\u0026ldquo;TOKEN\u0026rdquo; という値が得られます。 この値は、CDKがこれらの遅延バインディング値をどのように表現するかを示しています。 CDKはこれらの遅延バインディング値を未定の値として扱う必要があります。 例えば、それらを連結することはできますが、コード内でそれらを解析（splitやsubstringなど）しても正しく動作することはありません。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/30-hello-cdk/400-apigw.html","title":"API Gateway","tags":[],"description":"","content":"次のステップでは、API Gatewayを関数の前に追加していきます。 API GatewayはパブリックHTTPエンドポイントを公開します。このエンドポイントは、インターネット上の誰もが curlやウェブブラウザのようなHTTPクライアントでヒットできます。\nAPI Gatewayのルートには、 Lambda proxy integrationを利用します。 つまり、どのURLパスへのリクエストも、直接Lambda関数にプロキシされ、関数からのレスポンスがユーザーに返されることになります。\nLambdaRestApi コンストラクトを追加する lib/cdk-workshop-stack.ts に戻り、APIエンドポイントを定義してLambda関数に関連付けましょう。\nimport { Stack, StackProps } from \u0026#39;aws-cdk-lib\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; import * as lambda from \u0026#39;aws-cdk-lib/aws-lambda\u0026#39; import * as apigw from \u0026#39;aws-cdk-lib/aws-apigateway\u0026#39;; export class CdkWorkshopStack extends Stack { constructor(scope: Construct, id: string, props?: StackProps) { super(scope, id, props); // defines an AWS Lambda resource const hello = new lambda.Function(this, \u0026#39;HelloHandler\u0026#39;, { runtime: lambda.Runtime.NODEJS_16_X, // execution environment code: lambda.Code.fromAsset(\u0026#39;lambda\u0026#39;), // code loaded from \u0026#34;lambda\u0026#34; directory handler: \u0026#39;hello.handler\u0026#39;, // file is \u0026#34;hello\u0026#34;, function is \u0026#34;handler\u0026#34; }); // defines an API Gateway REST API resource backed by our \u0026#34;hello\u0026#34; function. new apigw.LambdaRestApi(this, \u0026#39;Endpoint\u0026#39;, { handler: hello, }); } } 以上です。これで、すべてのリクエストをAWS Lambda関数にプロキシするAPI Gatewayが定義されました。\ncdk diff これをデプロイするとどうなるのか見てみましょう。\ncdk diff 出力は次のようになります。\nStack CdkWorkshopStack IAM Statement Changes ┌───┬─────────────────────┬────────┬───────────────────────┬──────────────────────────────────────────────────────────────────┬───────────────────────────────────────────────────────────────────┐ │ │ Resource │ Effect │ Action │ Principal │ Condition │ ├───┼─────────────────────┼────────┼───────────────────────┼──────────────────────────────────────────────────────────────────┼───────────────────────────────────────────────────────────────────┤ │ + │ ${HelloHandler.Arn} │ Allow │ lambda:InvokeFunction │ Service:apigateway.amazonaws.com │ \u0026#34;ArnLike\u0026#34;: { │ │ │ │ │ │ │ \u0026#34;AWS:SourceArn\u0026#34;: \u0026#34;arn:${AWS::Partition}:execute-api:${AWS::Regi │ │ │ │ │ │ │ on}:${AWS::AccountId}:${EndpointEEF1FD8F}/${Endpoint/DeploymentSt │ │ │ │ │ │ │ age.prod}/*/*\u0026#34; │ │ │ │ │ │ │ } │ │ + │ ${HelloHandler.Arn} │ Allow │ lambda:InvokeFunction │ Service:apigateway.amazonaws.com │ \u0026#34;ArnLike\u0026#34;: { │ │ │ │ │ │ │ \u0026#34;AWS:SourceArn\u0026#34;: \u0026#34;arn:${AWS::Partition}:execute-api:${AWS::Regi │ │ │ │ │ │ │ on}:${AWS::AccountId}:${EndpointEEF1FD8F}/test-invoke-stage/*/*\u0026#34; │ │ │ │ │ │ │ } │ │ + │ ${HelloHandler.Arn} │ Allow │ lambda:InvokeFunction │ Service:apigateway.amazonaws.com │ \u0026#34;ArnLike\u0026#34;: { │ │ │ │ │ │ │ \u0026#34;AWS:SourceArn\u0026#34;: \u0026#34;arn:${AWS::Partition}:execute-api:${AWS::Regi │ │ │ │ │ │ │ on}:${AWS::AccountId}:${EndpointEEF1FD8F}/${Endpoint/DeploymentSt │ │ │ │ │ │ │ age.prod}/*/\u0026#34; │ │ │ │ │ │ │ } │ │ + │ ${HelloHandler.Arn} │ Allow │ lambda:InvokeFunction │ Service:apigateway.amazonaws.com │ \u0026#34;ArnLike\u0026#34;: { │ │ │ │ │ │ │ \u0026#34;AWS:SourceArn\u0026#34;: \u0026#34;arn:${AWS::Partition}:execute-api:${AWS::Regi │ │ │ │ │ │ │ on}:${AWS::AccountId}:${EndpointEEF1FD8F}/test-invoke-stage/*/\u0026#34; │ │ │ │ │ │ │ } │ └───┴─────────────────────┴────────┴───────────────────────┴──────────────────────────────────────────────────────────────────┴───────────────────────────────────────────────────────────────────┘ (NOTE: There may be security-related changes not in this list. See https://github.com/aws/aws-cdk/issues/1299) Resources [+] AWS::ApiGateway::RestApi Endpoint EndpointEEF1FD8F [+] AWS::ApiGateway::Deployment Endpoint/Deployment EndpointDeployment318525DA5f8cdfe532107839d82cbce31f859259 [+] AWS::ApiGateway::Stage Endpoint/DeploymentStage.prod EndpointDeploymentStageprodB78BEEA0 [+] AWS::ApiGateway::Resource Endpoint/Default/{proxy+} Endpointproxy39E2174E [+] AWS::Lambda::Permission Endpoint/Default/{proxy+}/ANY/ApiPermission.CdkWorkshopStackEndpoint018E8349.ANY..{proxy+} EndpointproxyANYApiPermissionCdkWorkshopStackEndpoint018E8349ANYproxy747DCA52 [+] AWS::Lambda::Permission Endpoint/Default/{proxy+}/ANY/ApiPermission.Test.CdkWorkshopStackEndpoint018E8349.ANY..{proxy+} EndpointproxyANYApiPermissionTestCdkWorkshopStackEndpoint018E8349ANYproxy41939001 [+] AWS::ApiGateway::Method Endpoint/Default/{proxy+}/ANY EndpointproxyANYC09721C5 [+] AWS::Lambda::Permission Endpoint/Default/ANY/ApiPermission.CdkWorkshopStackEndpoint018E8349.ANY.. EndpointANYApiPermissionCdkWorkshopStackEndpoint018E8349ANYE84BEB04 [+] AWS::Lambda::Permission Endpoint/Default/ANY/ApiPermission.Test.CdkWorkshopStackEndpoint018E8349.ANY.. EndpointANYApiPermissionTestCdkWorkshopStackEndpoint018E8349ANYB6CC1B64 [+] AWS::ApiGateway::Method Endpoint/Default/ANY EndpointANY485C938B Outputs [+] Output Endpoint/Endpoint Endpoint8024A810: {\u0026#34;Value\u0026#34;:{\u0026#34;Fn::Join\u0026#34;:[\u0026#34;\u0026#34;,[\u0026#34;https://\u0026#34;,{\u0026#34;Ref\u0026#34;:\u0026#34;EndpointEEF1FD8F\u0026#34;},\u0026#34;.execute-api.\u0026#34;,{\u0026#34;Ref\u0026#34;:\u0026#34;AWS::Region\u0026#34;},\u0026#34;.\u0026#34;,{\u0026#34;Ref\u0026#34;:\u0026#34;AWS::URLSuffix\u0026#34;},\u0026#34;/\u0026#34;,{\u0026#34;Ref\u0026#34;:\u0026#34;EndpointDeploymentStageprodB78BEEA0\u0026#34;},\u0026#34;/\u0026#34;]]}} 追加したコードにより、10個の新しいリソースがスタックに追加されることがわかります。\ncdk deploy デプロイする準備が整いました。\ncdk deploy Stack outputs デプロイが完了すると、次の内容が出力されているはずです。\nCdkWorkshopStack.Endpoint8024A810 = https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ これは、API Gatewayコンストラクトによって自動的に追加されるstack outputであり、API GatewayエンドポイントのURLが含まれます。\nアプリをテストする。 次に、このエンドポイントを curl で叩いてみましょう。 URLをコピーして実行します。（プレフィックスとリージョンは異なる可能性があります）\ncurlをインストールしていない場合は、WebブラウザでこのURLにアクセスしてみてください。\ncurl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ 出力は次のようになります。\nHello, CDK! You\u0026#39;ve hit / Webブラウザでも確認できます。\nこの出力がされていれば、アプリは正常に動作しています。\n正常に動作していないとき API Gatewayから5xxエラーを受け取った場合、次の2つの問題のいずれかが該当しています。\nlambda関数が返した応答は、API Gatewayが期待するものと一致していません。 手順を戻って、Lambdaのhandler関数の返り値にstatusCode, body, header フィールドが含まれているか確認してください。 (参照: Lambdaのhandler関数のコード) 何らかの理由で関数が失敗しています。 Lambda関数をデバッグするには、このセクションで、Lambdaログをどのように表示するか学べます。 お疲れさまでした！ 次の章では再利用可能な独自のコンストラクトを作成します。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/30-hello-cdk/400-apigw.html","title":"API Gateway","tags":[],"description":"","content":"Next step is to add an API Gateway in front of our function. API Gateway will expose a public HTTP endpoint that anyone on the internet can hit with an HTTP client such as curl or a web browser.\nWe will use Lambda proxy integration mounted to the root of the API. This means that any request to any URL path will be proxied directly to our Lambda function, and the response from the function will be returned back to the user.\nAdd a LambdaRestApi construct to your stack Let\u0026rsquo;s define an API endpoint and associate it with our Lambda function. Add this code to cdk_workshop_stack.py (which you should still have open from the last step):\nfrom constructs import Construct from aws_cdk import ( Stack, aws_lambda as _lambda, aws_apigateway as apigw, ) class CdkWorkshopStack(Stack): def __init__(self, scope: Construct, id: str, **kwargs) -\u0026gt; None: super().__init__(scope, id, **kwargs) my_lambda = _lambda.Function( self, \u0026#39;HelloHandler\u0026#39;, runtime=_lambda.Runtime.PYTHON_3_7, code=_lambda.Code.from_asset(\u0026#39;lambda\u0026#39;), handler=\u0026#39;hello.handler\u0026#39;, ) apigw.LambdaRestApi( self, \u0026#39;Endpoint\u0026#39;, handler=my_lambda, ) That\u0026rsquo;s it. This is all you need to do in order to define an API Gateway which proxies all requests to an AWS Lambda function.\ncdk diff Let\u0026rsquo;s see what\u0026rsquo;s going to happen when we deploy this:\ncdk diff Output should look like this:\nThe cdk-workshop stack uses assets, which are currently not accounted for in the diff output! See https://github.com/awslabs/aws-cdk/issues/395 IAM Statement Changes ┌───┬────────────────────┬────────┬────────────────────┬────────────────────┬───────────────────────┐ │ │ Resource │ Effect │ Action │ Principal │ Condition │ ├───┼────────────────────┼────────┼────────────────────┼────────────────────┼───────────────────────┤ │ + │ ${Endpoint/CloudWa │ Allow │ sts:AssumeRole │ Service:apigateway │ │ │ │ tchRole.Arn} │ │ │ .${AWS::URLSuffix} │ │ ├───┼────────────────────┼────────┼────────────────────┼────────────────────┼───────────────────────┤ │ + │ ${HelloHandler.Arn │ Allow │ lambda:InvokeFunct │ Service:apigateway │ \u0026#34;ArnLike\u0026#34;: { │ │ │ } │ │ ion │ .amazonaws.com │ \u0026#34;AWS:SourceArn\u0026#34;: \u0026#34;a │ │ │ │ │ │ │ rn:${AWS::Partition}: │ │ │ │ │ │ │ execute-api:us-east-2 │ │ │ │ │ │ │ :${AWS::AccountId}:${ │ │ │ │ │ │ │ Endpoint}/${EndpointD │ │ │ │ │ │ │ eploymentStageprodB78 │ │ │ │ │ │ │ BEEA0}/*/\u0026#34; │ │ │ │ │ │ │ } │ │ + │ ${HelloHandler.Arn │ Allow │ lambda:InvokeFunct │ Service:apigateway │ \u0026#34;ArnLike\u0026#34;: { │ │ │ } │ │ ion │ .amazonaws.com │ \u0026#34;AWS:SourceArn\u0026#34;: \u0026#34;a │ │ │ │ │ │ │ rn:${AWS::Partition}: │ │ │ │ │ │ │ execute-api:us-east-2 │ │ │ │ │ │ │ :${AWS::AccountId}:${ │ │ │ │ │ │ │ Endpoint}/test-invoke │ │ │ │ │ │ │ -stage/*/\u0026#34; │ │ │ │ │ │ │ } │ │ + │ ${HelloHandler.Arn │ Allow │ lambda:InvokeFunct │ Service:apigateway │ \u0026#34;ArnLike\u0026#34;: { │ │ │ } │ │ ion │ .amazonaws.com │ \u0026#34;AWS:SourceArn\u0026#34;: \u0026#34;a │ │ │ │ │ │ │ rn:${AWS::Partition}: │ │ │ │ │ │ │ execute-api:us-east-2 │ │ │ │ │ │ │ :${AWS::AccountId}:${ │ │ │ │ │ │ │ Endpoint}/${EndpointD │ │ │ │ │ │ │ eploymentStageprodB78 │ │ │ │ │ │ │ BEEA0}/*/{proxy+}\u0026#34; │ │ │ │ │ │ │ } │ │ + │ ${HelloHandler.Arn │ Allow │ lambda:InvokeFunct │ Service:apigateway │ \u0026#34;ArnLike\u0026#34;: { │ │ │ } │ │ ion │ .amazonaws.com │ \u0026#34;AWS:SourceArn\u0026#34;: \u0026#34;a │ │ │ │ │ │ │ rn:${AWS::Partition}: │ │ │ │ │ │ │ execute-api:us-east-2 │ │ │ │ │ │ │ :${AWS::AccountId}:${ │ │ │ │ │ │ │ Endpoint}/test-invoke │ │ │ │ │ │ │ -stage/*/{proxy+}\u0026#34; │ │ │ │ │ │ │ } │ └───┴────────────────────┴────────┴────────────────────┴────────────────────┴───────────────────────┘ IAM Policy Changes ┌───┬────────────────────────────┬──────────────────────────────────────────────────────────────────┐ │ │ Resource │ Managed Policy ARN │ ├───┼────────────────────────────┼──────────────────────────────────────────────────────────────────┤ │ + │ ${Endpoint/CloudWatchRole} │ arn:${AWS::Partition}:iam::aws:policy/service-role/AmazonAPIGate │ │ │ │ wayPushToCloudWatchLogs │ └───┴────────────────────────────┴──────────────────────────────────────────────────────────────────┘ (NOTE: There may be security-related changes not in this list. See http://bit.ly/cdk-2EhF7Np) Resources [+] AWS::Lambda::Permission HelloHandler/ApiPermission.ANY.. HelloHandlerApiPermissionANYAC4E141E [+] AWS::Lambda::Permission HelloHandler/ApiPermission.Test.ANY.. HelloHandlerApiPermissionTestANYDDD56D72 [+] AWS::Lambda::Permission HelloHandler/ApiPermission.ANY..{proxy+} HelloHandlerApiPermissionANYproxy90E90CD6 [+] AWS::Lambda::Permission HelloHandler/ApiPermission.Test.ANY..{proxy+} HelloHandlerApiPermissionTestANYproxy9803526C [+] AWS::ApiGateway::RestApi Endpoint EndpointEEF1FD8F [+] AWS::ApiGateway::Deployment Endpoint/Deployment EndpointDeployment318525DAb462c597ccb914d9fc1c10f664ed81ca [+] AWS::ApiGateway::Stage Endpoint/DeploymentStage.prod EndpointDeploymentStageprodB78BEEA0 [+] AWS::IAM::Role Endpoint/CloudWatchRole EndpointCloudWatchRoleC3C64E0F [+] AWS::ApiGateway::Account Endpoint/Account EndpointAccountB8304247 [+] AWS::ApiGateway::Resource Endpoint/Default/{proxy+} Endpointproxy39E2174E [+] AWS::ApiGateway::Method Endpoint/Default/{proxy+}/ANY EndpointproxyANYC09721C5 [+] AWS::ApiGateway::Method Endpoint/Default/ANY EndpointANY485C938B Outputs [+] Output Endpoint/Endpoint Endpoint8024A810: {\u0026#34;Value\u0026#34;:{\u0026#34;Fn::Join\u0026#34;:[\u0026#34;\u0026#34;,[\u0026#34;https://\u0026#34;,{\u0026#34;Ref\u0026#34;:\u0026#34;EndpointEEF1FD8F\u0026#34;},\u0026#34;.execute-api.us-east-2.\u0026#34;,{\u0026#34;Ref\u0026#34;:\u0026#34;AWS::URLSuffix\u0026#34;},\u0026#34;/\u0026#34;,{\u0026#34;Ref\u0026#34;:\u0026#34;EndpointDeploymentStageprodB78BEEA0\u0026#34;},\u0026#34;/\u0026#34;]]}} That\u0026rsquo;s nice. This one line of code added 12 new resources to our stack.\ncdk deploy Okay, ready to deploy?\ncdk deploy Stack outputs When deployment is complete, you\u0026rsquo;ll notice this line:\nCdkWorkshopStack.Endpoint8024A810 = https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ This is a stack output that\u0026rsquo;s automatically added by the API Gateway construct and includes the URL of the API Gateway endpoint.\nTesting your app Let\u0026rsquo;s try to hit this endpoint with curl. Copy the URL and execute (your prefix and region will likely be different).\nIf you don\u0026rsquo;t have curl installed, you can always use your favorite web browser to hit this URL.\ncurl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ Output should look like this:\nHello, CDK! You\u0026#39;ve hit / You can also use your web browser for this:\nIf this is the output you received, your app works!\nWhat if it didn\u0026rsquo;t work? If you received a 5xx error from API Gateway, it is likely one of two issues:\nThe response your function returned is not what API Gateway expects. Go back and make sure your handler returns a response that includes a statusCode, body and header fields (see Write handler runtime code). Your function failed for some reason. To debug this, you can quickly jump to this section to learn how to view your Lambda logs. Good job! In the next chapter, we\u0026rsquo;ll write our own reusable construct.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/30-hello-cdk/400-apigw.html","title":"API Gateway","tags":[],"description":"","content":"Next step is to add an API Gateway in front of our function. API Gateway will expose a public HTTP endpoint that anyone on the internet can hit with an HTTP client such as curl or a web browser.\nWe will use Lambda proxy integration mounted to the root of the API. This means that any request to any URL path will be proxied directly to our Lambda function, and the response from the function will be returned back to the user.\nAdd a LambdaRestApi construct to your stack Going back to src/CdkWorkshop/CdkWorkshopStack.cs, let\u0026rsquo;s define an API endpoint and associate it with our Lambda function:\nusing Amazon.CDK; using Amazon.CDK.AWS.Lambda; using Amazon.CDK.AWS.APIGateway; using Constructs; namespace CdkWorkshop { public class CdkWorkshopStack : Stack { public CdkWorkshopStack(Construct scope, string id, IStackProps props = null) : base(scope, id, props) { // Defines a new lambda resource var hello = new Function(this, \u0026#34;HelloHandler\u0026#34;, new FunctionProps { Runtime = Runtime.NODEJS_14_X, // execution environment Code = Code.FromAsset(\u0026#34;lambda\u0026#34;), // Code loaded from the \u0026#34;lambda\u0026#34; directory Handler = \u0026#34;hello.handler\u0026#34; // file is \u0026#34;hello\u0026#34;, function is \u0026#34;handler\u0026#34; }); // defines an API Gateway REST API resource backed by our \u0026#34;hello\u0026#34; function. new LambdaRestApi(this, \u0026#34;Endpoint\u0026#34;, new LambdaRestApiProps { Handler = hello }); } } } That\u0026rsquo;s it. This is all you need to do in order to define an API Gateway which proxies all requests to an AWS Lambda function.\ncdk diff Let\u0026rsquo;s see what\u0026rsquo;s going to happen when we deploy this:\ncdk diff Output should look like this:\nIAM Statement Changes ┌───┬───────────────────────────┬────────┬───────────────────────────┬───────────────────────────┬─────────────────────────────┐ │ │ Resource │ Effect │ Action │ Principal │ Condition │ ├───┼───────────────────────────┼────────┼───────────────────────────┼───────────────────────────┼─────────────────────────────┤ │ + │ ${Endpoint/CloudWatchRole │ Allow │ sts:AssumeRole │ Service:apigateway.${AWS: │ │ │ │ .Arn} │ │ │ :URLSuffix} │ │ ├───┼───────────────────────────┼────────┼───────────────────────────┼───────────────────────────┼─────────────────────────────┤ │ + │ ${HelloHandler.Arn} │ Allow │ lambda:InvokeFunction │ Service:apigateway.amazon │ \u0026#34;ArnLike\u0026#34;: { │ │ │ │ │ │ aws.com │ \u0026#34;AWS:SourceArn\u0026#34;: \u0026#34;arn:${A │ │ │ │ │ │ │ WS::Partition}:execute-api: │ │ │ │ │ │ │ ${AWS::Region}:${AWS::Accou │ │ │ │ │ │ │ ntId}:${EndpointEEF1FD8F}/$ │ │ │ │ │ │ │ {Endpoint/DeploymentStage.p │ │ │ │ │ │ │ rod}/*/\u0026#34; │ │ │ │ │ │ │ } │ │ + │ ${HelloHandler.Arn} │ Allow │ lambda:InvokeFunction │ Service:apigateway.amazon │ \u0026#34;ArnLike\u0026#34;: { │ │ │ │ │ │ aws.com │ \u0026#34;AWS:SourceArn\u0026#34;: \u0026#34;arn:${A │ │ │ │ │ │ │ WS::Partition}:execute-api: │ │ │ │ │ │ │ ${AWS::Region}:${AWS::Accou │ │ │ │ │ │ │ ntId}:${EndpointEEF1FD8F}/t │ │ │ │ │ │ │ est-invoke-stage/*/\u0026#34; │ │ │ │ │ │ │ } │ │ + │ ${HelloHandler.Arn} │ Allow │ lambda:InvokeFunction │ Service:apigateway.amazon │ \u0026#34;ArnLike\u0026#34;: { │ │ │ │ │ │ aws.com │ \u0026#34;AWS:SourceArn\u0026#34;: \u0026#34;arn:${A │ │ │ │ │ │ │ WS::Partition}:execute-api: │ │ │ │ │ │ │ ${AWS::Region}:${AWS::Accou │ │ │ │ │ │ │ ntId}:${EndpointEEF1FD8F}/$ │ │ │ │ │ │ │ {Endpoint/DeploymentStage.p │ │ │ │ │ │ │ rod}/*/{proxy+}\u0026#34; │ │ │ │ │ │ │ } │ │ + │ ${HelloHandler.Arn} │ Allow │ lambda:InvokeFunction │ Service:apigateway.amazon │ \u0026#34;ArnLike\u0026#34;: { │ │ │ │ │ │ aws.com │ \u0026#34;AWS:SourceArn\u0026#34;: \u0026#34;arn:${A │ │ │ │ │ │ │ WS::Partition}:execute-api: │ │ │ │ │ │ │ ${AWS::Region}:${AWS::Accou │ │ │ │ │ │ │ ntId}:${EndpointEEF1FD8F}/t │ │ │ │ │ │ │ est-invoke-stage/*/{proxy+} │ │ │ │ │ │ │ \u0026#34; │ │ │ │ │ │ │ } │ └───┴───────────────────────────┴────────┴───────────────────────────┴───────────────────────────┴─────────────────────────────┘ IAM Policy Changes ┌───┬────────────────────────────┬─────────────────────────────────────────────────────────────────────────────────────────┐ │ │ Resource │ Managed Policy ARN │ ├───┼────────────────────────────┼─────────────────────────────────────────────────────────────────────────────────────────┤ │ + │ ${Endpoint/CloudWatchRole} │ arn:${AWS::Partition}:iam::aws:policy/service-role/AmazonAPIGatewayPushToCloudWatchLogs │ └───┴────────────────────────────┴─────────────────────────────────────────────────────────────────────────────────────────┘ (NOTE: There may be security-related changes not in this list. See http://bit.ly/cdk-2EhF7Np) Resources [+] AWS::Lambda::Permission HelloHandler/ApiPermission.ANY.. HelloHandlerApiPermissionANYAC4E141E [+] AWS::Lambda::Permission HelloHandler/ApiPermission.Test.ANY.. HelloHandlerApiPermissionTestANYDDD56D72 [+] AWS::Lambda::Permission HelloHandler/ApiPermission.ANY..{proxy+} HelloHandlerApiPermissionANYproxy90E90CD6 [+] AWS::Lambda::Permission HelloHandler/ApiPermission.Test.ANY..{proxy+} HelloHandlerApiPermissionTestANYproxy9803526C [+] AWS::ApiGateway::RestApi Endpoint EndpointEEF1FD8F [+] AWS::ApiGateway::Deployment Endpoint/Deployment EndpointDeployment318525DA37c0e38727e25b4317827bf43e918fbf [+] AWS::ApiGateway::Stage Endpoint/DeploymentStage.prod EndpointDeploymentStageprodB78BEEA0 [+] AWS::IAM::Role Endpoint/CloudWatchRole EndpointCloudWatchRoleC3C64E0F [+] AWS::ApiGateway::Account Endpoint/Account EndpointAccountB8304247 [+] AWS::ApiGateway::Resource Endpoint/Default/{proxy+} Endpointproxy39E2174E [+] AWS::ApiGateway::Method Endpoint/Default/{proxy+}/ANY EndpointproxyANYC09721C5 [+] AWS::ApiGateway::Method Endpoint/Default/ANY EndpointANY485C938B Outputs [+] Output Endpoint/Endpoint Endpoint8024A810: {\u0026#34;Value\u0026#34;:{\u0026#34;Fn::Join\u0026#34;:[\u0026#34;\u0026#34;,[\u0026#34;https://\u0026#34;,{\u0026#34;Ref\u0026#34;:\u0026#34;EndpointEEF1FD8F\u0026#34;},\u0026#34;.execute-api.\u0026#34;,{\u0026#34;Ref\u0026#34;:\u0026#34;AWS::Region\u0026#34;},\u0026#34;.\u0026#34;,{\u0026#34;Ref\u0026#34;:\u0026#34;AWS::URLSuffix\u0026#34;},\u0026#34;/\u0026#34;,{\u0026#34;Ref\u0026#34;:\u0026#34;EndpointDeploymentStageprodB78BEEA0\u0026#34;},\u0026#34;/\u0026#34;]]}} That\u0026rsquo;s nice. This one line of code added 12 new resources to our stack.\ncdk deploy Okay, ready to deploy?\ncdk deploy Stack outputs When deployment is complete, you\u0026rsquo;ll notice this line:\nCdkWorkshopStack.Endpoint8024A810 = https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ This is a stack output that\u0026rsquo;s automatically added by the API Gateway construct and includes the URL of the API Gateway endpoint.\nTesting your app Let\u0026rsquo;s try to hit this endpoint with curl. Copy the URL and execute (your prefix and region will likely be different).\nIf you don\u0026rsquo;t have curl installed, you can always use your favorite web browser to hit this URL.\ncurl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ Output should look like this:\nHello, CDK! You\u0026#39;ve hit / You can also use your web browser for this:\nIf this is the output you received, your app works!\nWhat if it didn\u0026rsquo;t work? If you received a 5xx error from API Gateway, it is likely one of two issues:\nThe response your function returned is not what API Gateway expects. Go back and make sure your handler returns a response that includes a statusCode, body and header fields (see Write handler runtime code). Your function failed for some reason. To debug this, you can quickly jump to this section to learn how to view your Lambda logs. Good job! In the next chapter, we\u0026rsquo;ll write our own reusable construct.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/30-hello-cdk/400-apigw.html","title":"API Gateway","tags":[],"description":"","content":"Next step is to add an API Gateway in front of our function. API Gateway will expose a public HTTP endpoint that anyone on the internet can hit with an HTTP client such as curl or a web browser.\nWe will use Lambda proxy integration mounted to the root of the API. This means that any request to any URL path will be proxied directly to our Lambda function, and the response from the function will be returned back to the user.\nAdd a LambdaRestApi construct to your stack Going back to ~/CdkWorkshopStack.java, let\u0026rsquo;s define an API endpoint and associate it with our Lambda function:\npackage com.myorg; import software.constructs.Construct; import software.amazon.awscdk.Stack; import software.amazon.awscdk.StackProps; import software.amazon.awscdk.services.apigateway.LambdaRestApi; import software.amazon.awscdk.services.lambda.Code; import software.amazon.awscdk.services.lambda.Function; import software.amazon.awscdk.services.lambda.Runtime; public class CdkWorkshopStack extends Stack { public CdkWorkshopStack(final Construct parent, final String id) { this(parent, id, null); } public CdkWorkshopStack(final Construct parent, final String id, final StackProps props) { super(parent, id, props); // Defines a new lambda resource final Function hello = Function.Builder.create(this, \u0026#34;HelloHandler\u0026#34;) .runtime(Runtime.NODEJS_14_X) // execution environment .code(Code.fromAsset(\u0026#34;lambda\u0026#34;)) // code loaded from the \u0026#34;lambda\u0026#34; directory .handler(\u0026#34;hello.handler\u0026#34;) // file is \u0026#34;hello\u0026#34;, function is \u0026#34;handler\u0026#34; .build(); // Defines an API Gateway REST API resource backed by our \u0026#34;hello\u0026#34; function LambdaRestApi.Builder.create(this, \u0026#34;Endpoint\u0026#34;) .handler(hello) .build(); } } That\u0026rsquo;s it. This is all you need to do in order to define an API Gateway which proxies all requests to an AWS Lambda function.\ncdk diff Let\u0026rsquo;s see what\u0026rsquo;s going to happen when we deploy this:\nmvn package cdk diff Output should look like this:\nIAM Statement Changes ┌───┬───────────────────────────┬────────┬───────────────────────────┬───────────────────────────┬─────────────────────────────┐ │ │ Resource │ Effect │ Action │ Principal │ Condition │ ├───┼───────────────────────────┼────────┼───────────────────────────┼───────────────────────────┼─────────────────────────────┤ │ + │ ${Endpoint/CloudWatchRole │ Allow │ sts:AssumeRole │ Service:apigateway.${AWS: │ │ │ │ .Arn} │ │ │ :URLSuffix} │ │ ├───┼───────────────────────────┼────────┼───────────────────────────┼───────────────────────────┼─────────────────────────────┤ │ + │ ${HelloHandler.Arn} │ Allow │ lambda:InvokeFunction │ Service:apigateway.amazon │ \u0026#34;ArnLike\u0026#34;: { │ │ │ │ │ │ aws.com │ \u0026#34;AWS:SourceArn\u0026#34;: \u0026#34;arn:${A │ │ │ │ │ │ │ WS::Partition}:execute-api: │ │ │ │ │ │ │ ${AWS::Region}:${AWS::Accou │ │ │ │ │ │ │ ntId}:${EndpointEEF1FD8F}/$ │ │ │ │ │ │ │ {Endpoint/DeploymentStage.p │ │ │ │ │ │ │ rod}/*/\u0026#34; │ │ │ │ │ │ │ } │ │ + │ ${HelloHandler.Arn} │ Allow │ lambda:InvokeFunction │ Service:apigateway.amazon │ \u0026#34;ArnLike\u0026#34;: { │ │ │ │ │ │ aws.com │ \u0026#34;AWS:SourceArn\u0026#34;: \u0026#34;arn:${A │ │ │ │ │ │ │ WS::Partition}:execute-api: │ │ │ │ │ │ │ ${AWS::Region}:${AWS::Accou │ │ │ │ │ │ │ ntId}:${EndpointEEF1FD8F}/t │ │ │ │ │ │ │ est-invoke-stage/*/\u0026#34; │ │ │ │ │ │ │ } │ │ + │ ${HelloHandler.Arn} │ Allow │ lambda:InvokeFunction │ Service:apigateway.amazon │ \u0026#34;ArnLike\u0026#34;: { │ │ │ │ │ │ aws.com │ \u0026#34;AWS:SourceArn\u0026#34;: \u0026#34;arn:${A │ │ │ │ │ │ │ WS::Partition}:execute-api: │ │ │ │ │ │ │ ${AWS::Region}:${AWS::Accou │ │ │ │ │ │ │ ntId}:${EndpointEEF1FD8F}/$ │ │ │ │ │ │ │ {Endpoint/DeploymentStage.p │ │ │ │ │ │ │ rod}/*/{proxy+}\u0026#34; │ │ │ │ │ │ │ } │ │ + │ ${HelloHandler.Arn} │ Allow │ lambda:InvokeFunction │ Service:apigateway.amazon │ \u0026#34;ArnLike\u0026#34;: { │ │ │ │ │ │ aws.com │ \u0026#34;AWS:SourceArn\u0026#34;: \u0026#34;arn:${A │ │ │ │ │ │ │ WS::Partition}:execute-api: │ │ │ │ │ │ │ ${AWS::Region}:${AWS::Accou │ │ │ │ │ │ │ ntId}:${EndpointEEF1FD8F}/t │ │ │ │ │ │ │ est-invoke-stage/*/{proxy+} │ │ │ │ │ │ │ \u0026#34; │ │ │ │ │ │ │ } │ └───┴───────────────────────────┴────────┴───────────────────────────┴───────────────────────────┴─────────────────────────────┘ IAM Policy Changes ┌───┬────────────────────────────┬─────────────────────────────────────────────────────────────────────────────────────────┐ │ │ Resource │ Managed Policy ARN │ ├───┼────────────────────────────┼─────────────────────────────────────────────────────────────────────────────────────────┤ │ + │ ${Endpoint/CloudWatchRole} │ arn:${AWS::Partition}:iam::aws:policy/service-role/AmazonAPIGatewayPushToCloudWatchLogs │ └───┴────────────────────────────┴─────────────────────────────────────────────────────────────────────────────────────────┘ (NOTE: There may be security-related changes not in this list. See http://bit.ly/cdk-2EhF7Np) Resources [+] AWS::Lambda::Permission HelloHandler/ApiPermission.ANY.. HelloHandlerApiPermissionANYAC4E141E [+] AWS::Lambda::Permission HelloHandler/ApiPermission.Test.ANY.. HelloHandlerApiPermissionTestANYDDD56D72 [+] AWS::Lambda::Permission HelloHandler/ApiPermission.ANY..{proxy+} HelloHandlerApiPermissionANYproxy90E90CD6 [+] AWS::Lambda::Permission HelloHandler/ApiPermission.Test.ANY..{proxy+} HelloHandlerApiPermissionTestANYproxy9803526C [+] AWS::ApiGateway::RestApi Endpoint EndpointEEF1FD8F [+] AWS::ApiGateway::Deployment Endpoint/Deployment EndpointDeployment318525DA37c0e38727e25b4317827bf43e918fbf [+] AWS::ApiGateway::Stage Endpoint/DeploymentStage.prod EndpointDeploymentStageprodB78BEEA0 [+] AWS::IAM::Role Endpoint/CloudWatchRole EndpointCloudWatchRoleC3C64E0F [+] AWS::ApiGateway::Account Endpoint/Account EndpointAccountB8304247 [+] AWS::ApiGateway::Resource Endpoint/Default/{proxy+} Endpointproxy39E2174E [+] AWS::ApiGateway::Method Endpoint/Default/{proxy+}/ANY EndpointproxyANYC09721C5 [+] AWS::ApiGateway::Method Endpoint/Default/ANY EndpointANY485C938B Outputs [+] Output Endpoint/Endpoint Endpoint8024A810: {\u0026#34;Value\u0026#34;:{\u0026#34;Fn::Join\u0026#34;:[\u0026#34;\u0026#34;,[\u0026#34;https://\u0026#34;,{\u0026#34;Ref\u0026#34;:\u0026#34;EndpointEEF1FD8F\u0026#34;},\u0026#34;.execute-api.\u0026#34;,{\u0026#34;Ref\u0026#34;:\u0026#34;AWS::Region\u0026#34;},\u0026#34;.\u0026#34;,{\u0026#34;Ref\u0026#34;:\u0026#34;AWS::URLSuffix\u0026#34;},\u0026#34;/\u0026#34;,{\u0026#34;Ref\u0026#34;:\u0026#34;EndpointDeploymentStageprodB78BEEA0\u0026#34;},\u0026#34;/\u0026#34;]]}} That\u0026rsquo;s nice. This one line of code added 12 new resources to our stack.\ncdk deploy Okay, ready to deploy?\ncdk deploy Stack outputs When deployment is complete, you\u0026rsquo;ll notice this line:\nCdkWorkshopStack.Endpoint8024A810 = https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ This is a stack output that\u0026rsquo;s automatically added by the API Gateway construct and includes the URL of the API Gateway endpoint.\nTesting your app Let\u0026rsquo;s try to hit this endpoint with curl. Copy the URL and execute (your prefix and region will likely be different).\nIf you don\u0026rsquo;t have curl installed, you can always use your favorite web browser to hit this URL.\ncurl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ Output should look like this:\nHello, CDK! You\u0026#39;ve hit / You can also use your web browser for this:\nIf this is the output you received, your app works!\nWhat if it didn\u0026rsquo;t work? If you received a 5xx error from API Gateway, it is likely one of two issues:\nThe response your function returned is not what API Gateway expects. Go back and make sure your handler returns a response that includes a statusCode, body and header fields (see Write handler runtime code). Your function failed for some reason. To debug this, you can quickly jump to this section to learn how to view your Lambda logs. Good job! In the next chapter, we\u0026rsquo;ll write our own reusable construct.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/20-create-project/400-synth.html","title":"cdk synth","tags":[],"description":"","content":"アプリからテンプレートを生成する AWS CDKアプリ自体はコードを使用したインフラストラクチャの 定義 にすぎません。 CDKアプリが実行されると、アプリケーションで定義された各スタックのAWS CloudFormationテンプレートが生成（CDKの用語では \u0026quot;synthesize\u0026quot; ）されます。\nCDKアプリを生成するには、 cdk synth コマンドを実行してください。 サンプルアプリから生成されたCloudFormationテンプレートを確認してみましょう。\nCDK CLI はcdk.jsonファイルが配置されているプロジェクトのルートディレクトリで実行する必要があります。 ディレクトリを移動している場合はプロジェクトのルートディレクトリに戻ってからCDKコマンドを実行してください。\ncdk synth 上記コマンドを実行すると、次のCloudFormationテンプレートを出力します。\nResources: CdkWorkshopQueue50D9D426: Type: AWS::SQS::Queue Properties: VisibilityTimeout: 300 UpdateReplacePolicy: Delete DeletionPolicy: Delete Metadata: aws:cdk:path: CdkWorkshopStack/CdkWorkshopQueue/Resource CdkWorkshopQueuePolicyAF2494A5: Type: AWS::SQS::QueuePolicy Properties: PolicyDocument: Statement: - Action: sqs:SendMessage Condition: ArnEquals: aws:SourceArn: Ref: CdkWorkshopTopicD368A42F Effect: Allow Principal: Service: sns.amazonaws.com Resource: Fn::GetAtt: - CdkWorkshopQueue50D9D426 - Arn Version: \u0026#34;2012-10-17\u0026#34; Queues: - Ref: CdkWorkshopQueue50D9D426 Metadata: aws:cdk:path: CdkWorkshopStack/CdkWorkshopQueue/Policy/Resource CdkWorkshopQueueCdkWorkshopStackCdkWorkshopTopicD7BE96438B5AD106: Type: AWS::SNS::Subscription Properties: Protocol: sqs TopicArn: Ref: CdkWorkshopTopicD368A42F Endpoint: Fn::GetAtt: - CdkWorkshopQueue50D9D426 - Arn Metadata: aws:cdk:path: CdkWorkshopStack/CdkWorkshopQueue/CdkWorkshopStackCdkWorkshopTopicD7BE9643/Resource CdkWorkshopTopicD368A42F: Type: AWS::SNS::Topic Metadata: aws:cdk:path: CdkWorkshopStack/CdkWorkshopTopic/Resource CDKMetadata: Type: AWS::CDK::Metadata Properties: Analytics: v2:deflate64:H4sIAAAAAAAA/1WNQQrCMBBFz9J9OhoFxXUvoK17aZMI09akZhJFQu5uk4DgZv7/jwezg/0JeNW/qRZyqmccIHSuFxNb0S3QkyBcvPKKNXddSr5nM6P4/GCZkZFe/c4PJCwuDo1Oxt++mgVFornEmGqryHgr8o/GaInJjEwbqWCkzYsfgB9hW42EWFuvHT4UtCW/VHqIZsEAAAA= Metadata: aws:cdk:path: CdkWorkshopStack/CDKMetadata/Default Condition: CDKMetadataAvailable Conditions: CDKMetadataAvailable: Fn::Or: - Fn::Or: - Fn::Equals: - Ref: AWS::Region - af-south-1 - Fn::Equals: - Ref: AWS::Region - ap-east-1 - Fn::Equals: - Ref: AWS::Region - ap-northeast-1 - Fn::Equals: - Ref: AWS::Region - ap-northeast-2 - Fn::Equals: - Ref: AWS::Region - ap-south-1 - Fn::Equals: - Ref: AWS::Region - ap-southeast-1 - Fn::Equals: - Ref: AWS::Region - ap-southeast-2 - Fn::Equals: - Ref: AWS::Region - ca-central-1 - Fn::Equals: - Ref: AWS::Region - cn-north-1 - Fn::Equals: - Ref: AWS::Region - cn-northwest-1 - Fn::Or: - Fn::Equals: - Ref: AWS::Region - eu-central-1 - Fn::Equals: - Ref: AWS::Region - eu-north-1 - Fn::Equals: - Ref: AWS::Region - eu-south-1 - Fn::Equals: - Ref: AWS::Region - eu-west-1 - Fn::Equals: - Ref: AWS::Region - eu-west-2 - Fn::Equals: - Ref: AWS::Region - eu-west-3 - Fn::Equals: - Ref: AWS::Region - me-south-1 - Fn::Equals: - Ref: AWS::Region - sa-east-1 - Fn::Equals: - Ref: AWS::Region - us-east-1 - Fn::Equals: - Ref: AWS::Region - us-east-2 - Fn::Or: - Fn::Equals: - Ref: AWS::Region - us-west-1 - Fn::Equals: - Ref: AWS::Region - us-west-2 Parameters: BootstrapVersion: Type: AWS::SSM::Parameter::Value\u0026lt;String\u0026gt; Default: /cdk-bootstrap/hnb659fds/version Description: Version of the CDK Bootstrap resources in this environment, automatically retrieved from SSM Parameter Store. [cdk:skip] Rules: CheckBootstrapVersion: Assertions: - Assert: Fn::Not: - Fn::Contains: - - \u0026#34;1\u0026#34; - \u0026#34;2\u0026#34; - \u0026#34;3\u0026#34; - \u0026#34;4\u0026#34; - \u0026#34;5\u0026#34; - Ref: BootstrapVersion AssertDescription: CDK bootstrap stack version 6 required. Please run \u0026#39;cdk bootstrap\u0026#39; with a recent version of the CDK CLI. ご覧のとおり、このテンプレートには4つのリソースが含まれています。\nAWS::SQS::Queue - キュー AWS::SNS::Topic - トピック AWS::SNS::Subscription - キューとトピックの間のサブスクリプション AWS::SQS::QueuePolicy - このトピックがメッセージをキューに送信できるようにするリソースポリシー AWS::CDK::Metadata リソースは、ツールキットによって自動的に各スタックに追加されます。 AWS CDKチームはこれを分析のために使用し、セキュリティ上の問題があるバージョンを特定できるようにします。 詳細については、AW​​S CDKユーザーガイドのVersion Reportingを参照してください。 このワークショップの残りの説明では、メタデータリソースに関する詳細は省略します。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/20-create-project/400-synth.html","title":"cdk synth","tags":[],"description":"","content":"Synthesize a template from your app AWS CDK apps are effectively only a definition of your infrastructure using code. When CDK apps are executed, they produce (or \u0026ldquo;synthesize\u0026rdquo;, in CDK parlance) an AWS CloudFormation template for each stack defined in your application.\nTo synthesize a CDK app, use the cdk synth command. Let\u0026rsquo;s check out the template synthesized from the sample app.\nThe CDK CLI requires you to be in the same directory as your cdk.json file. If you have changed directories in your terminal, please navigate back now.\n$ cdk ls cdk_workshop $ cd cdk_workshop We can then synthesize:\n$ cdk synth This will output the following CloudFormation template:\nResources: CdkworkshopQueue18864164: Type: AWS::SQS::Queue Properties: VisibilityTimeout: 300 Metadata: aws:cdk:path: cdkworkshop/CdkworkshopQueue/Resource CdkworkshopQueuePolicy78D5BF45: Type: AWS::SQS::QueuePolicy Properties: PolicyDocument: Statement: - Action: sqs:SendMessage Condition: ArnEquals: aws:SourceArn: Ref: CdkworkshopTopic58CFDD3D Effect: Allow Principal: Service: sns.amazonaws.com Resource: Fn::GetAtt: - CdkworkshopQueue18864164 - Arn Version: \u0026#34;2012-10-17\u0026#34; Queues: - Ref: CdkworkshopQueue18864164 Metadata: aws:cdk:path: cdkworkshop/CdkworkshopQueue/Policy/Resource CdkworkshopQueuecdkworkshopCdkworkshopTopic7642CC2FCF70B637: Type: AWS::SNS::Subscription Properties: Protocol: sqs TopicArn: Ref: CdkworkshopTopic58CFDD3D Endpoint: Fn::GetAtt: - CdkworkshopQueue18864164 - Arn Metadata: aws:cdk:path: cdkworkshop/CdkworkshopQueue/cdkworkshopCdkworkshopTopic7642CC2F/Resource CdkworkshopTopic58CFDD3D: Type: AWS::SNS::Topic Metadata: aws:cdk:path: cdkworkshop/CdkworkshopTopic/Resource CDKMetadata: Type: AWS::CDK::Metadata Properties: Modules: aws-cdk=1.18.0,jsii-runtime=Python/3.7.3 As you can see, this template includes a bunch of resources:\nAWS::SQS::Queue - our queue AWS::SNS::Topic - our topic AWS::SNS::Subscription - the subscription between the queue and the topic AWS::SQS::QueuePolicy - the IAM policy which allows this topic to send messages to the queue The AWS::CDK::Metadata resource is automatically added by the toolkit to every stack. It is used by the AWS CDK team for analytics and to allow us to identify versions with security issues. See Version Reporting in the AWS CDK User Guide for more details. We will omit the metadata resource in diff views for the rest of this workshop\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/20-create-project/400-synth.html","title":"cdk synth","tags":[],"description":"","content":"Synthesize a template from your app AWS CDK apps are effectively only a definition of your infrastructure using code. When CDK apps are executed, they produce (or \u0026ldquo;synthesize\u0026rdquo;, in CDK parlance) an AWS CloudFormation template for each stack defined in your application.\nTo synthesize a CDK app, use the cdk synth command. Let\u0026rsquo;s check out the template synthesized from the sample app:\nThe CDK CLI requires you to be in the same directory as your cdk.json file. If you have changed directories in your terminal, please navigate back now.\ncdk synth Will output the following CloudFormation template:\nResources: CdkWorkshopQueue50D9D426: Type: AWS::SQS::Queue Properties: VisibilityTimeout: 300 Metadata: aws:cdk:path: CdkWorkshopStack/CdkWorkshopQueue/Resource CdkWorkshopQueuePolicyAF2494A5: Type: AWS::SQS::QueuePolicy Properties: PolicyDocument: Statement: - Action: sqs:SendMessage Condition: ArnEquals: aws:SourceArn: Ref: CdkWorkshopTopicD368A42F Effect: Allow Principal: Service: sns.amazonaws.com Resource: Fn::GetAtt: - CdkWorkshopQueue50D9D426 - Arn Version: \u0026#34;2012-10-17\u0026#34; Queues: - Ref: CdkWorkshopQueue50D9D426 Metadata: aws:cdk:path: CdkWorkshopStack/CdkWorkshopQueue/Policy/Resource CdkWorkshopQueueCdkWorkshopStackCdkWorkshopTopicD7BE96438B5AD106: Type: AWS::SNS::Subscription Properties: Protocol: sqs TopicArn: Ref: CdkWorkshopTopicD368A42F Endpoint: Fn::GetAtt: - CdkWorkshopQueue50D9D426 - Arn Metadata: aws:cdk:path: CdkWorkshopStack/CdkWorkshopQueue/CdkWorkshopStackCdkWorkshopTopicD7BE9643/Resource CdkWorkshopTopicD368A42F: Type: AWS::SNS::Topic Metadata: aws:cdk:path: CdkWorkshopStack/CdkWorkshopTopic/Resource CDKMetadata: Type: AWS::CDK::Metadata Properties: Modules: aws-cdk=1.17.1,@aws-cdk/assets=1.17.1,@aws-cdk/aws-cloudwatch=1.17.1,@aws-cdk/aws-ec2=1.17.1,@aws-cdk/aws-events=1.17.1,@aws-cdk/aws-iam=1.17.1,@aws-cdk/aws-kms=1.17.1,@aws-cdk/aws-lambda=1.17.1,@aws-cdk/aws-logs=1.17.1,@aws-cdk/aws-s3=1.17.1,@aws-cdk/aws-s3-assets=1.17.1,@aws-cdk/aws-sns=1.17.1,@aws-cdk/aws-sns-subscriptions=1.17.1,@aws-cdk/aws-sqs=1.17.1,@aws-cdk/aws-ssm=1.17.1,@aws-cdk/core=1.17.1,@aws-cdk/cx-api=1.17.1,@aws-cdk/region-info=1.17.1,jsii-runtime=DotNet/3.0.0/.NETCoreApp,Version=v3.0/1.0.0.0 Condition: CDKMetadataAvailable Conditions: CDKMetadataAvailable: ... ... As you can see, this template includes four resources:\nAWS::SQS::Queue - our queue AWS::SQS::QueuePolicy - the IAM policy which allows this topic to send messages to the queue AWS::SNS::Subscription - the subscription between the queue and the topic AWS::SNS::Topic - our topic The AWS::CDK::Metadata resource is automatically added by the toolkit to every stack. It is used by the AWS CDK team for analytics and to allow us to identify versions with security issues. See Version Reporting in the AWS CDK User Guide for more details. We will omit the metadata resource in diff views for the rest of this workshop\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/20-create-project/400-synth.html","title":"cdk synth","tags":[],"description":"","content":"Synthesize a template from your app AWS CDK apps are effectively only a definition of your infrastructure using code. When CDK apps are executed, they produce (or \u0026ldquo;synthesize\u0026rdquo;, in CDK parlance) an AWS CloudFormation template for each stack defined in your application.\nTo synthesize a CDK app, use the cdk synth command. Let\u0026rsquo;s check out the template synthesized from the sample app:\nThe CDK CLI requires you to be in the same directory as your cdk.json file. If you have changed directories in your terminal, please navigate back now.\ncdk synth Will output the following CloudFormation template:\nResources: CdkWorkshopQueue50D9D426: Type: AWS::SQS::Queue Properties: VisibilityTimeout: 300 Metadata: aws:cdk:path: CdkWorkshopStack/CdkWorkshopQueue/Resource CdkWorkshopQueuePolicyAF2494A5: Type: AWS::SQS::QueuePolicy Properties: PolicyDocument: Statement: - Action: sqs:SendMessage Condition: ArnEquals: aws:SourceArn: Ref: CdkWorkshopTopicD368A42F Effect: Allow Principal: Service: sns.amazonaws.com Resource: Fn::GetAtt: - CdkWorkshopQueue50D9D426 - Arn Version: \u0026#34;2012-10-17\u0026#34; Queues: - Ref: CdkWorkshopQueue50D9D426 Metadata: aws:cdk:path: CdkWorkshopStack/CdkWorkshopQueue/Policy/Resource CdkWorkshopQueueCdkWorkshopStackCdkWorkshopTopicD7BE96438B5AD106: Type: AWS::SNS::Subscription Properties: Protocol: sqs TopicArn: Ref: CdkWorkshopTopicD368A42F Endpoint: Fn::GetAtt: - CdkWorkshopQueue50D9D426 - Arn Metadata: aws:cdk:path: CdkWorkshopStack/CdkWorkshopQueue/CdkWorkshopStackCdkWorkshopTopicD7BE9643/Resource CdkWorkshopTopicD368A42F: Type: AWS::SNS::Topic Properties: DisplayName: My First Topic Yeah Metadata: aws:cdk:path: CdkWorkshopStack/CdkWorkshopTopic/Resource CDKMetadata: Type: AWS::CDK::Metadata Properties: Modules: aws-cdk=1.17.1,@aws-cdk/assets=1.17.1,@aws-cdk/aws-cloudwatch=1.17.1,@aws-cdk/aws-ec2=1.17.1,@aws-cdk/aws-events=1.17.1,@aws-cdk/aws-iam=1.17.1,@aws-cdk/aws-kms=1.17.1,@aws-cdk/aws-lambda=1.17.1,@aws-cdk/aws-logs=1.17.1,@aws-cdk/aws-s3=1.17.1,@aws-cdk/aws-s3-assets=1.17.1,@aws-cdk/aws-sns=1.17.1,@aws-cdk/aws-sns-subscriptions=1.17.1,@aws-cdk/aws-sqs=1.17.1,@aws-cdk/aws-ssm=1.17.1,@aws-cdk/core=1.17.1,@aws-cdk/cx-api=1.17.1,@aws-cdk/region-info=1.17.1,jsii-runtime=Java/1.8.0_202 Condition: CDKMetadataAvailable Conditions: CDKMetadataAvailable: ... As you can see, this template includes four resources:\nAWS::SQS::Queue - our queue AWS::SQS::QueuePolicy - the IAM policy which allows this topic to send messages to the queue AWS::SNS::Subscription - the subscription between the queue and the topic AWS::SNS::Topic - our topic The AWS::CDK::Metadata resource is automatically added by the toolkit to every stack. It is used by the AWS CDK team for analytics and to allow us to identify versions with security issues. See Version Reporting in the AWS CDK User Guide for more details. We will omit the metadata resource in diff views for the rest of this workshop\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/50-table-viewer/400-deploy.html","title":"Deploying our app","tags":[],"description":"","content":"cdk diff Before we deploy, let\u0026rsquo;s take a look at what will happen when we deploy our app (this is just the Resources section of the output):\n$ mvn package ... $ cdk diff Resources [+] AWS::IAM::Role ViewHitCounter/Rendered/ServiceRole ViewHitCounterRenderedServiceRole254DB4EA [+] AWS::IAM::Policy ViewHitCounter/Rendered/ServiceRole/DefaultPolicy ViewHitCounterRenderedServiceRoleDefaultPolicy9ADB8C83 [+] AWS::Lambda::Function ViewHitCounter/Rendered ViewHitCounterRendered9C783E45 [+] AWS::Lambda::Permission ViewHitCounter/Rendered/ApiPermission.ANY.. ViewHitCounterRenderedApiPermissionANY72263B1A [+] AWS::Lambda::Permission ViewHitCounter/Rendered/ApiPermission.Test.ANY.. ViewHitCounterRenderedApiPermissionTestANYA4794B81 [+] AWS::Lambda::Permission ViewHitCounter/Rendered/ApiPermission.ANY..{proxy+} ViewHitCounterRenderedApiPermissionANYproxy42B9E676 [+] AWS::Lambda::Permission ViewHitCounter/Rendered/ApiPermission.Test.ANY..{proxy+} ViewHitCounterRenderedApiPermissionTestANYproxy104CA88E [+] AWS::ApiGateway::RestApi ViewHitCounter/ViewerEndpoint ViewHitCounterViewerEndpoint5A0EF326 [+] AWS::ApiGateway::Deployment ViewHitCounter/ViewerEndpoint/Deployment ViewHitCounterViewerEndpointDeployment1CE7C5768689ca8f54dfa4f161d3df0ebffcdcff [+] AWS::ApiGateway::Stage ViewHitCounter/ViewerEndpoint/DeploymentStage.prod ViewHitCounterViewerEndpointDeploymentStageprodF3901FC7 [+] AWS::IAM::Role ViewHitCounter/ViewerEndpoint/CloudWatchRole ViewHitCounterViewerEndpointCloudWatchRole87B94D6A [+] AWS::ApiGateway::Account ViewHitCounter/ViewerEndpoint/Account ViewHitCounterViewerEndpointAccount0B75E76A [+] AWS::ApiGateway::Resource ViewHitCounter/ViewerEndpoint/{proxy+} ViewHitCounterViewerEndpointproxy2F4C239F [+] AWS::ApiGateway::Method ViewHitCounter/ViewerEndpoint/{proxy+}/ANY ViewHitCounterViewerEndpointproxyANYFF4B8F5B [+] AWS::ApiGateway::Method ViewHitCounter/ViewerEndpoint/ANY ViewHitCounterViewerEndpointANY66F2285B You\u0026rsquo;ll notice that the table viewer adds another API Gateway endpoint, a Lambda function, permissions, outputs, all sorts of goodies.\nConstruct libraries are a very powerful concept. They allow you to add complex capabilities to your apps with minimum effort. However, you must understand that with great power comes great responsibility. Constructs can add IAM permissions, expose data to the public or cause your application not to function. We are working on providing you tools for protecting your app, and identifying potential security issues with your stacks, but it is your responsibility to understand how certain constructs that you use impact your application, and to make sure you only use construct libraries from vendors you trust\ncdk deploy $ cdk deploy ... CdkWorkshopStack.ViewHitCounterViewerEndpointCA1B1E4B = https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ You\u0026rsquo;ll see the viewer endpoint as an output.\nViewing the hit counter table Open your browser and browse to the hit counter viewer endpoint URL. You should see something like this:\nSend a few requests Send a few more requests to your \u0026ldquo;hello\u0026rdquo; endpoint and monitor your hit counter viewer. You should see the values update in real-time.\nUse curl or your web browser to produce a few hits:\n$ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hoooot $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hoooot $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hoooot $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hoooot $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 Interested in how the Table Viewer works? It\u0026rsquo;s easy to find out! Hold Ctrl (or Command) and click on the TableViewer identifier to navigate to its source code.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/50-table-viewer/400-expose-table.html","title":"Exposing our hit counter table","tags":[],"description":"","content":"Add a table property to our hit counter Edit hitcounter.ts and modify it as such table is exposed as a public property.\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import * as lambda from \u0026#39;aws-cdk-lib/aws-lambda\u0026#39;; import * as dynamodb from \u0026#39;aws-cdk-lib/aws-dynamodb\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; export interface HitCounterProps { /** the function for which we want to count url hits **/ downstream: lambda.IFunction; } export class HitCounter extends Construct { /** allows accessing the counter function */ public readonly handler: lambda.Function; /** the hit counter table */ public readonly table: dynamodb.Table; constructor(scope: Construct, id: string, props: HitCounterProps) { super(scope, id); const table = new dynamodb.Table(this, \u0026#34;Hits\u0026#34;, { partitionKey: { name: \u0026#34;path\u0026#34;, type: dynamodb.AttributeType.STRING } }); this.table = table; this.handler = new lambda.Function(this, \u0026#39;HitCounterHandler\u0026#39;, { runtime: lambda.Runtime.NODEJS_14_X, handler: \u0026#39;hitcounter.handler\u0026#39;, code: lambda.Code.fromAsset(\u0026#39;lambda\u0026#39;), environment: { DOWNSTREAM_FUNCTION_NAME: props.downstream.functionName, HITS_TABLE_NAME: table.tableName } }); // grant the lambda role read/write permissions to our table table.grantReadWriteData(this.handler); // grant the lambda role invoke permissions to the downstream function props.downstream.grantInvoke(this.handler); } } Now we can access the table from our stack Go back to cdk-workshop-stack.ts and assign the table property of the table viewer:\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import * as lambda from \u0026#39;aws-cdk-lib/aws-lambda\u0026#39;; import * as apigw from \u0026#39;aws-cdk-lib/aws-apigateway\u0026#39;; import { HitCounter } from \u0026#39;./hitcounter\u0026#39;; import { TableViewer } from \u0026#39;cdk-dynamo-table-viewer\u0026#39;; export class CdkWorkshopStack extends cdk.Stack { constructor(scope: cdk.App, id: string, props?: cdk.StackProps) { super(scope, id, props); const hello = new lambda.Function(this, \u0026#39;HelloHandler\u0026#39;, { runtime: lambda.Runtime.NODEJS_14_X, code: lambda.Code.fromAsset(\u0026#39;lambda\u0026#39;), handler: \u0026#39;hello.handler\u0026#39; }); const helloWithCounter = new HitCounter(this, \u0026#39;HelloHitCounter\u0026#39;, { downstream: hello }); // defines an API Gateway REST API resource backed by our \u0026#34;hello\u0026#34; function. new apigw.LambdaRestApi(this, \u0026#39;Endpoint\u0026#39;, { handler: helloWithCounter.handler }); new TableViewer(this, \u0026#39;ViewHitCounter\u0026#39;, { title: \u0026#39;Hello Hits\u0026#39;, table: helloWithCounter.table }); } } We\u0026rsquo;re finished making code changes, so once you save this file, you can close the npm run watch command with Ctrl-C.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/50-table-viewer/400-expose-table.html","title":"Exposing our hit counter table","tags":[],"description":"","content":"Add a table property to our hit counter Edit hitcounter.py and modify it as such table is exposed as a public property.\nfrom constructs import Construct from aws_cdk import ( aws_lambda as _lambda, aws_dynamodb as ddb, ) class HitCounter(Construct): @property def handler(self): return self._handler @property def table(self): return self._table def __init__(self, scope: Construct, id: str, downstream: _lambda.IFunction, **kwargs): super().__init__(scope, id, **kwargs) self._table = ddb.Table( self, \u0026#39;Hits\u0026#39;, partition_key={\u0026#39;name\u0026#39;: \u0026#39;path\u0026#39;, \u0026#39;type\u0026#39;: ddb.AttributeType.STRING} ) self._handler = _lambda.Function( self, \u0026#39;HitCountHandler\u0026#39;, runtime=_lambda.Runtime.PYTHON_3_7, handler=\u0026#39;hitcount.handler\u0026#39;, code=_lambda.Code.from_asset(\u0026#39;lambda\u0026#39;), environment={ \u0026#39;DOWNSTREAM_FUNCTION_NAME\u0026#39;: downstream.function_name, \u0026#39;HITS_TABLE_NAME\u0026#39;: self._table.table_name, } ) self._table.grant_read_write_data(self.handler) downstream.grant_invoke(self.handler) Now we can access the table from our stack Go back to cdk_workshop_stack.py and assign the table property of the table viewer:\nfrom constructs import Construct from aws_cdk import ( Stack, aws_lambda as _lambda, aws_apigateway as apigw, ) from cdk_dynamo_table_view import TableViewer from .hitcounter import HitCounter class CdkWorkshopStack(Stack): def __init__(self, scope: Construct, id: str, **kwargs) -\u0026gt; None: super().__init__(scope, id, **kwargs) # Defines an AWS Lambda resource hello = _lambda.Function( self, \u0026#39;HelloHandler\u0026#39;, runtime=_lambda.Runtime.PYTHON_3_7, code=_lambda.Code.from_asset(\u0026#39;lambda\u0026#39;), handler=\u0026#39;hello.handler\u0026#39;, ) hello_with_counter = HitCounter( self, \u0026#39;HelloHitCounter\u0026#39;, downstream=hello, ) apigw.LambdaRestApi( self, \u0026#39;Endpoint\u0026#39;, handler=hello_with_counter._handler, ) TableViewer( self, \u0026#39;ViewHitCounter\u0026#39;, title=\u0026#39;Hello Hits\u0026#39;, table=hello_with_counter.table, ) "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/50-table-viewer/400-expose-table.html","title":"Exposing our hit counter table","tags":[],"description":"","content":"Add a table property to our hit counter Edit src/CdkWorkshop/HitCounter.cs and modify it so that table is exposed as a public property called MyTable.\nusing Amazon.CDK; using Amazon.CDK.AWS.DynamoDB; using Amazon.CDK.AWS.Lambda; using Constructs; using System.Collections.Generic; namespace CdkWorkshop { public class HitCounterProps { // The function for which we want to count url hits public IFunction Downstream { get; set; } } public class HitCounter : Construct { public readonly Function Handler; public readonly Table MyTable; public HitCounter(Construct scope, string id, HitCounterProps props) : base(scope, id) { var table = new Table(this, \u0026#34;Hits\u0026#34;, new TableProps { PartitionKey = new Attribute { Name = \u0026#34;path\u0026#34;, Type = AttributeType.STRING } }); MyTable = table; Handler = new Function(this, \u0026#34;HitCounterHandler\u0026#34;, new FunctionProps { Runtime = Runtime.NODEJS_14_X, Handler = \u0026#34;hitcounter.handler\u0026#34;, Code = Code.FromAsset(\u0026#34;lambda\u0026#34;), Environment = new Dictionary\u0026lt;string, string\u0026gt; { [\u0026#34;DOWNSTREAM_FUNCTION_NAME\u0026#34;] = props.Downstream.FunctionName, [\u0026#34;HITS_TABLE_NAME\u0026#34;] = table.TableName } }); // Grant the lambda role read/write permissions to our table table.GrantReadWriteData(Handler); // Grant the lambda role invoke permissions to the downstream function props.Downstream.GrantInvoke(Handler); } } } Now we can access the table from our stack Go back to CdkWorkshopStack.cs and assign the Table property of the table viewer:\nusing Amazon.CDK; using Amazon.CDK.AWS.APIGateway; using Amazon.CDK.AWS.Lambda; using Cdklabs.DynamoTableViewer; using Constructs; namespace CdkWorkshop { public class CdkWorkshopStack : Stack { public CdkWorkshopStack(Construct scope, string id) : base(scope, id) { // Defines a new lambda resource var hello = new Function(this, \u0026#34;HelloHandler\u0026#34;, new FunctionProps { Runtime = Runtime.NODEJS_14_X, // execution environment Code = Code.FromAsset(\u0026#34;lambda\u0026#34;), // Code loaded from the \u0026#34;lambda\u0026#34; directory Handler = \u0026#34;hello.handler\u0026#34; // file is \u0026#34;hello\u0026#34;, function is \u0026#34;handler\u0026#34; }); // Defines out HitCounter resource var helloWithCounter = new HitCounter(this, \u0026#34;HelloHitCounter\u0026#34;, new HitCounterProps { Downstream = hello }); // Defines an API Gateway REST API resource backed by our \u0026#34;hello\u0026#34; function. new LambdaRestApi(this, \u0026#34;Endpoint\u0026#34;, new LambdaRestApiProps { Handler = helloWithCounter.Handler }); // Defines a new TableViewer resource new TableViewer(this, \u0026#34;ViewerHitCount\u0026#34;, new TableViewerProps { Title = \u0026#34;Hello Hits\u0026#34;, Table = helloWithCounter.MyTable }); } } } We\u0026rsquo;re finished making code changes, congratulations! You can now save and exit out of your code editor if you want.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/40-hit-counter/400-use.html","title":"HitCounterの使用","tags":[],"description":"","content":"スタックにHitCounterを追加する HitCounterの準備ができましたのでアプリに実装していきましょう。 lib/cdk-workshop-stack.tsを開き、次の強調表示されたコードを追加します。\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import * as lambda from \u0026#39;aws-cdk-lib/aws-lambda\u0026#39;; import * as apigw from \u0026#39;aws-cdk-lib/aws-apigateway\u0026#39;; import { HitCounter } from \u0026#39;./hitcounter\u0026#39;; export class CdkWorkshopStack extends cdk.Stack { constructor(scope: cdk.App, id: string, props?: cdk.StackProps) { super(scope, id, props); const hello = new lambda.Function(this, \u0026#39;HelloHandler\u0026#39;, { runtime: lambda.Runtime.NODEJS_16_X, code: lambda.Code.fromAsset(\u0026#39;lambda\u0026#39;), handler: \u0026#39;hello.handler\u0026#39; }); const helloWithCounter = new HitCounter(this, \u0026#39;HelloHitCounter\u0026#39;, { downstream: hello }); // defines an API Gateway REST API resource backed by our \u0026#34;hello\u0026#34; function. new apigw.LambdaRestApi(this, \u0026#39;Endpoint\u0026#39;, { handler: helloWithCounter.handler }); } } API GatewayのハンドラーをhelloからhelloWithCounter.handlerに変更しています。 これは、エンドポイントが実行されるたびに、API GatewayがHitCounterハンドラーにリクエストをルーティングし、 HitCounterハンドラーが実行されてログに記録し、hello関数に中継することを意味します。 レスポンスはユーザーに返されるまで逆順でリレーされます。\nデプロイ cdk deploy デプロイには少し時間がかかります。\n出力は次のとおりです。\nCdkWorkshopStack.Endpoint8024A810 = https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ テスト 準備ができたので実行してみましょう。（「deploy」コマンドの実行結果からAPIのURLを確認してください。）\ncurl コマンドを実行するか、ブラウザにエンドポイントのURLを入力してみてください。なお、-iオプションをつけてcurlコマンドを実行すると、HTTPレスポンスのフィールドにステータスコードが表示されます。\ncurl -i https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ 実行すると、何かがうまくいってないことが分かるはずです。\nHTTP/2 502 Bad Gateway ... {\u0026#34;message\u0026#34;: \u0026#34;Internal server error\u0026#34;} 次の章で、原因を調べて、修正してみましょう。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/15-prerequisites/400-ide.html","title":"IDE for your programming language","tags":[],"description":"","content":"One of the benefits of the AWS CDK is that you can leverage your favorite development environments and have a rich experience when exploring the hundreds of different services and features of AWS.\nWe highly recommend to use an IDE that supports code-completion and syntax highlighting for your language of choice:\nVSCode (recommended) AWS Cloud9 Atom with the atom-typescript plugin vim with tsuquyomi WebStorm Emacs with the tide mode PyCharm Eclipse "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/40-hit-counter/400-use.html","title":"Use the hit counter","tags":[],"description":"","content":"Add a hit counter to our stack Okay, our hit counter is ready. Let\u0026rsquo;s use it in our app. Open cdk_workshop_stack.py and add the following highlighted code:\nfrom constructs import Construct from aws_cdk import ( Stack, aws_lambda as _lambda, aws_apigateway as apigw, ) from .hitcounter import HitCounter class CdkWorkshopStack(Stack): def __init__(self, scope: Construct, id: str, **kwargs) -\u0026gt; None: super().__init__(scope, id, **kwargs) # Defines an AWS Lambda resource my_lambda = _lambda.Function( self, \u0026#39;HelloHandler\u0026#39;, runtime=_lambda.Runtime.PYTHON_3_7, code=_lambda.Code.from_asset(\u0026#39;lambda\u0026#39;), handler=\u0026#39;hello.handler\u0026#39;, ) hello_with_counter = HitCounter( self, \u0026#39;HelloHitCounter\u0026#39;, downstream=my_lambda, ) apigw.LambdaRestApi( self, \u0026#39;Endpoint\u0026#39;, handler=hello_with_counter._handler, ) Notice that we changed our API Gateway handler to hello_with_counter._handler instead of my_lambda. This basically means that whenever our endpoint is hit, API Gateway will route the request to our hit counter handler, which will log the hit and relay it over to the my_lambda function. Then, the responses will be relayed back in the reverse order all the way to the user.\nDeploy cdk deploy It might take a little while.\nAnd the output:\ncdkworkshop.Endpoint8024A810 = https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ Test Okay, ready to give this a go? (you should, again, see the URL of your API in the output of the \u0026ldquo;deploy\u0026rdquo; command).\nUse curl or your web browser to hit your endpoint (we use -i to show HTTP response fields and status code):\ncurl -i https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ Oh no\u0026hellip; seems like something went wrong:\nHTTP/1.1 502 Bad Gateway ... {\u0026#34;message\u0026#34;: \u0026#34;Internal server error\u0026#34;} Let\u0026rsquo;s see how to find out what happened and fix it.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/40-hit-counter/400-use.html","title":"Use the hit counter","tags":[],"description":"","content":"Add a hit counter to our stack Okay, our hit counter is ready. Let\u0026rsquo;s use it in our app. Open src/CdkWorkshop/CdkWorkshopStack.cs and add the following highlighted code:\nusing Amazon.CDK; using Amazon.CDK.AWS.APIGateway; using Amazon.CDK.AWS.Lambda; using Constructs; namespace CdkWorkshop { public class CdkWorkshopStack : Stack { public CdkWorkshopStack(Construct scope, string id, IStackProps props = null) : base(scope, id, props) { // Defines a new lambda resource var hello = new Function(this, \u0026#34;HelloHandler\u0026#34;, new FunctionProps { Runtime = Runtime.NODEJS_14_X, // execution environment Code = Code.FromAsset(\u0026#34;lambda\u0026#34;), // Code loaded from the \u0026#34;lambda\u0026#34; directory Handler = \u0026#34;hello.handler\u0026#34; // file is \u0026#34;hello\u0026#34;, function is \u0026#34;handler\u0026#34; }); var helloWithCounter = new HitCounter(this, \u0026#34;HelloHitCounter\u0026#34;, new HitCounterProps { Downstream = hello }); // defines an API Gateway REST API resource backed by our \u0026#34;hello\u0026#34; function. new LambdaRestApi(this, \u0026#34;Endpoint\u0026#34;, new LambdaRestApiProps { Handler = helloWithCounter.Handler }); } } } Notice that we changed our API Gateway handler to helloWithCounter.handler instead of hello. This basically means that whenever our endpoint is hit, API Gateway will route the request to our hit counter handler, which will log the hit and relay it over to the hello function. Then, the responses will be relayed back in the reverse order all the way to the user.\nDeploy cdk deploy It might take a little while.\nAnd the output:\nCdkWorkshopStack.Endpoint8024A810 = https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ Test Okay, ready to give this a go? (you should, again, see the URL of your API in the output of the \u0026ldquo;deploy\u0026rdquo; command).\nUse curl or your web browser to hit your endpoint (we use -i to show HTTP response fields and status code):\ncurl -i https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ Oh no\u0026hellip; seems like something went wrong:\nHTTP/1.1 502 Bad Gateway ... {\u0026#34;message\u0026#34;: \u0026#34;Internal server error\u0026#34;} Let\u0026rsquo;s see how to find out what happened and fix it.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/40-hit-counter/400-use.html","title":"Use the hit counter","tags":[],"description":"","content":"Add a hit counter to our stack Okay, our hit counter is ready. Let\u0026rsquo;s use it in our app. Open ~/CdkWorkshopStack.java and add the following highlighted code:\npackage com.myorg; import software.constructs.Construct; import software.amazon.awscdk.Stack; import software.amazon.awscdk.StackProps; import software.amazon.awscdk.services.apigateway.LambdaRestApi; import software.amazon.awscdk.services.lambda.Code; import software.amazon.awscdk.services.lambda.Function; import software.amazon.awscdk.services.lambda.Runtime; public class CdkWorkshopStack extends Stack { public CdkWorkshopStack(final Construct parent, final String id) { this(parent, id, null); } public CdkWorkshopStack(final Construct parent, final String id, final StackProps props) { super(parent, id, props); // Defines a new lambda resource final Function hello = Function.Builder.create(this, \u0026#34;HelloHandler\u0026#34;) .runtime(Runtime.NODEJS_14_X) // execution environment .code(Code.fromAsset(\u0026#34;lambda\u0026#34;)) // code loaded from the \u0026#34;lambda\u0026#34; directory .handler(\u0026#34;hello.handler\u0026#34;) // file is \u0026#34;hello\u0026#34;, function is \u0026#34;handler\u0026#34; .build(); // Defines our hitcounter resource final HitCounter helloWithCounter = new HitCounter(this, \u0026#34;HelloHitCounter\u0026#34;, HitCounterProps.builder() .downstream(hello) .build()); // Defines an API Gateway REST API resource backed by our \u0026#34;hello\u0026#34; function LambdaRestApi.Builder.create(this, \u0026#34;Endpoint\u0026#34;) .handler(helloWithCounter.getHandler()) .build(); } } Notice that we changed our API Gateway handler to helloWithCounter.getHandler() instead of hello. This basically means that whenever our endpoint is hit, API Gateway will route the request to our hit counter handler, which will log the hit and relay it over to the hello function. Then, the responses will be relayed back in the reverse order all the way to the user.\nDeploy mvn package cdk deploy It might take a little while.\nAnd the output:\nCdkWorkshopStack.Endpoint8024A810 = https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ Test Okay, ready to give this a go? (you should, again, see the URL of your API in the output of the \u0026ldquo;deploy\u0026rdquo; command).\nUse curl or your web browser to hit your endpoint (we use -i to show HTTP response fields and status code):\ncurl -i https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ Oh no\u0026hellip; seems like something went wrong:\nHTTP/1.1 502 Bad Gateway ... {\u0026#34;message\u0026#34;: \u0026#34;Internal server error\u0026#34;} Let\u0026rsquo;s see how to find out what happened and fix it.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/15-prerequisites/500-toolkit.html","title":"AWS CDK Toolkit","tags":[],"description":"","content":"Next, we\u0026rsquo;ll install the AWS CDK Toolkit. The toolkit is a command-line utility which allows you to work with CDK apps.\nOpen a terminal session and run the following command:\nWindows: you\u0026rsquo;ll need to run this as an Administrator POSIX: on some systems you may need to run this with sudo npm install -g aws-cdk You can check the toolkit version:\n$ cdk --version 2.0.0 (build 4b6ce31) "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/20-create-project/500-deploy.html","title":"cdk deploy","tags":[],"description":"","content":"CloudFormationテンプレートが作成されました。次は何を行うでしょうか？ AWSへのデプロイをしましょう！\n環境の初期構築 AWS CDKアプリを環境（アカウント/リージョン）に初めてデプロイするときは、Bootstrapスタックを構築する必要があります。 このスタックには、ツールキットの操作に必要なリソースが含まれています。 たとえば、スタックにはデプロイプロセスで使われるCloudformationテンプレートとアセットを保存するために使用されるS3バケットが含まれます。\ncdk bootstrap コマンドを実行すれば、bootstrapスタックがAWS環境にデプロイされます。\ncdk bootstrap 実行すると以下のように表示されます。\n⏳ Bootstrapping environment aws://999999999999/us-east-1... ... アクセス拒否エラーとなるときはAWS CLIのクレデンシャル情報が正しく設定されているか、 現在のプロファイルが CloudFormationのcloudformation:CreateChangeSetを実行する権限を持っているか確認してください。\nデプロイしましょう！ cdk deploy コマンドを使用することで、CDKアプリをデプロイできます。\ncdk deploy 次のような警告が表示されるはずです。\nThis deployment will make potentially sensitive changes according to your current security approval level (--require-approval broadening). Please confirm you intend to make the following modifications: IAM Statement Changes ┌───┬─────────────────────────┬────────┬─────────────────┬───────────────────────────┬─────────────────────────────────────────────────────────┐ │ │ Resource │ Effect │ Action │ Principal │ Condition │ ├───┼─────────────────────────┼────────┼─────────────────┼───────────────────────────┼─────────────────────────────────────────────────────────┤ │ + │ ${CdkWorkshopQueue.Arn} │ Allow │ sqs:SendMessage │ Service:sns.amazonaws.com │ \u0026#34;ArnEquals\u0026#34;: { │ │ │ │ │ │ │ \u0026#34;aws:SourceArn\u0026#34;: \u0026#34;${CdkWorkshopTopic}\u0026#34; │ │ │ │ │ │ │ } │ └───┴─────────────────────────┴────────┴─────────────────┴───────────────────────────┴─────────────────────────────────────────────────────────┘ (NOTE: There may be security-related changes not in this list. See https://github.com/aws/aws-cdk/issues/1299) Do you wish to deploy these changes (y/n)? これは、アプリのデプロイにはリスクが伴うことを警告しています。 トピックがメッセージをキューに送信できるようにする必要があるため、yを入力してスタックをデプロイし、リソースを作成します。\n出力は次のようになります。 ACCOUNT-IDはアカウントID、REGIONはアプリを作成したリージョン、STACK-IDはスタックを一意に特定する識別子です。\nCdkWorkshopStack: deploying... CdkWorkshopStack: creating CloudFormation changeset... ✅ CdkWorkshopStack ✨ Deployment time: 93.21s Stack ARN: arn:aws:cloudformation:REGION:ACCOUNT-ID:stack/CdkWorkshopStack/STACK-ID ✨ Total time: 107.65s CloudFormationコンソール CDKアプリはAWS CloudFormationを介してデプロイされます。 各CDKスタックはCloudFormationスタックと1：1に対応します。\nなので、AWS CloudFormationコンソールでスタックを管理することができます。\nAWS CloudFormationコンソールを見てみましょう。\n次のようなものが表示されるはずです。（表示されない場合、正しいリージョンにいるか確認してください。）\nCdkWorkshopStack を選択し、リソースタブを開けば、リソースの物理IDを確認できます。\nこれでコーディングの準備が整いました！ "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/20-create-project/500-deploy.html","title":"cdk deploy","tags":[],"description":"","content":"Okay, we\u0026rsquo;ve got a CloudFormation template. What\u0026rsquo;s next? Let\u0026rsquo;s deploy it into our account!\nBootstrapping an environment The first time you deploy an AWS CDK app into an environment (account/region), you\u0026rsquo;ll need to install a \u0026ldquo;bootstrap stack\u0026rdquo;. This stack includes resources that are needed for the toolkit\u0026rsquo;s operation. For example, the stack includes an S3 bucket that is used to store templates and assets during the deployment process.\nYou can use the cdk bootstrap command to install the bootstrap stack into an environment:\ncdk bootstrap Then:\n⏳ Bootstrapping environment 999999999999/us-east-1... ... Hopefully this command finished successfully and we can move on to deploy our app.\nLet\u0026rsquo;s deploy Use cdk deploy to deploy a CDK app:\ncdk deploy You should see a warning like the following:\nThis deployment will make potentially sensitive changes according to your current security approval level (--require-approval broadening). Please confirm you intend to make the following modifications: IAM Statement Changes ┌───┬─────────────────────────┬────────┬─────────────────┬───────────────────────────┬─────────────────────────────────────────────────────────┐ │ │ Resource │ Effect │ Action │ Principal │ Condition │ ├───┼─────────────────────────┼────────┼─────────────────┼───────────────────────────┼─────────────────────────────────────────────────────────┤ │ + │ ${CdkworkshopQueue.Arn} │ Allow │ sqs:SendMessage │ Service:sns.amazonaws.com │ \u0026#34;ArnEquals\u0026#34;: { │ │ │ │ │ │ │ \u0026#34;aws:SourceArn\u0026#34;: \u0026#34;${CdkworkshopTopic}\u0026#34; │ │ │ │ │ │ │ } │ └───┴─────────────────────────┴────────┴─────────────────┴───────────────────────────┴─────────────────────────────────────────────────────────┘ (NOTE: There may be security-related changes not in this list. See https://github.com/aws/aws-cdk/issues/1299) Do you wish to deploy these changes (y/n)? This is warning you that deploying the app contains security-sensitive changes. Since we need to allow the topic to send messages to the queue, enter y to deploy the stack and create the resources.\nOutput should look like the following, where ACCOUNT-ID is your account ID, REGION is the region in which you created the app, and STACK-ID is the unique identifier for your stack:\ncdk-workshop: deploying... cdk-workshop: creating CloudFormation changeset... 0/6 | 1:31:31 PM | CREATE_IN_PROGRESS | AWS::CDK::Metadata | CDKMetadata 0/6 | 1:31:31 PM | CREATE_IN_PROGRESS | AWS::SQS::Queue | CdkworkshopQueue (CdkworkshopQueue18864164) 0/6 | 1:31:32 PM | CREATE_IN_PROGRESS | AWS::SNS::Topic | CdkworkshopTopic (CdkworkshopTopic58CFDD3D) 0/6 | 1:31:32 PM | CREATE_IN_PROGRESS | AWS::SQS::Queue | CdkworkshopQueue (CdkworkshopQueue18864164) Resource creation Initiated 0/6 | 1:31:32 PM | CREATE_IN_PROGRESS | AWS::SNS::Topic | CdkworkshopTopic (CdkworkshopTopic58CFDD3D) Resource creation Initiated 0/6 | 1:31:33 PM | CREATE_IN_PROGRESS | AWS::CDK::Metadata | CDKMetadata Resource creation Initiated 1/6 | 1:31:33 PM | CREATE_COMPLETE | AWS::CDK::Metadata | CDKMetadata 2/6 | 1:31:33 PM | CREATE_COMPLETE | AWS::SQS::Queue | CdkworkshopQueue (CdkworkshopQueue18864164) 3/6 | 1:31:42 PM | CREATE_COMPLETE | AWS::SNS::Topic | CdkworkshopTopic (CdkworkshopTopic58CFDD3D) 3/6 | 1:31:44 PM | CREATE_IN_PROGRESS | AWS::SQS::QueuePolicy | CdkworkshopQueue/Policy (CdkworkshopQueuePolicy78D5BF45) 3/6 | 1:31:44 PM | CREATE_IN_PROGRESS | AWS::SNS::Subscription | CdkworkshopQueue/cdkworkshopCdkworkshopTopic7642CC2F (CdkworkshopQueuecdkworkshopCdkworkshopTopic7642CC2FCF70B637) 3/6 | 1:31:45 PM | CREATE_IN_PROGRESS | AWS::SQS::QueuePolicy | CdkworkshopQueue/Policy (CdkworkshopQueuePolicy78D5BF45) Resource creation Initiated 3/6 | 1:31:45 PM | CREATE_IN_PROGRESS | AWS::SNS::Subscription | CdkworkshopQueue/cdkworkshopCdkworkshopTopic7642CC2F (CdkworkshopQueuecdkworkshopCdkworkshopTopic7642CC2FCF70B637) Resource creation Initiated 4/6 | 1:31:45 PM | CREATE_COMPLETE | AWS::SQS::QueuePolicy | CdkworkshopQueue/Policy (CdkworkshopQueuePolicy78D5BF45) 5/6 | 1:31:45 PM | CREATE_COMPLETE | AWS::SNS::Subscription | CdkworkshopQueue/cdkworkshopCdkworkshopTopic7642CC2F (CdkworkshopQueuecdkworkshopCdkworkshopTopic7642CC2FCF70B637) ✅ cdk-workshop Stack ARN: arn:aws:cloudformation:us-west-2:************:stack/cdk-workshop/********-****-****-****-************ The CloudFormation Console CDK apps are deployed through AWS CloudFormation. Each CDK stack maps 1:1 with CloudFormation stack.\nThis means that you can use the AWS CloudFormation console in order to manage your stacks.\nLet\u0026rsquo;s take a look at the AWS CloudFormation console.\nYou will likely see something like this (if you don\u0026rsquo;t, make sure you are in the correct region):\nIf you select cdk-workshop and open the Resources tab, you will see the physical identities of our resources:\nI am ready for some actual coding! "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/20-create-project/500-deploy.html","title":"cdk deploy","tags":[],"description":"","content":"Okay, we\u0026rsquo;ve got a CloudFormation template. What\u0026rsquo;s next? Let\u0026rsquo;s deploy it into our account!\nBootstrapping an environment The first time you deploy an AWS CDK app into an environment (account/region), you\u0026rsquo;ll need to install a \u0026ldquo;bootstrap stack\u0026rdquo;. This stack includes resources that are needed for the toolkit\u0026rsquo;s operation. For example, the stack includes an S3 bucket that is used to store templates and assets during the deployment process.\nYou can use the cdk bootstrap command to install the bootstrap stack into an environment:\ncdk bootstrap Then:\n⏳ Bootstrapping environment 999999999999/us-west-2... ... Hopefully this command finished successfully and we can move on to deploy our app.\nLet\u0026rsquo;s deploy Use cdk deploy to deploy a CDK app:\ncdk deploy You should see a warning like the following:\nThis deployment will make potentially sensitive changes according to your current security approval level (--require-approval broadening). Please confirm you intend to make the following modifications: IAM Statement Changes ┌───┬────────────────────────────────┬────────┬─────────────────┬────────────────────────────────┬────────────────────────────────┐ │ │ Resource │ Effect │ Action │ Principal │ Condition │ ├───┼────────────────────────────────┼────────┼─────────────────┼────────────────────────────────┼────────────────────────────────┤ │ + │ ${CdkWorkshopQueue.Arn} │ Allow │ sqs:SendMessage │ Service:sns.amazonaws.com │ \u0026#34;ArnEquals\u0026#34;: { │ │ │ │ │ │ │ \u0026#34;aws:SourceArn\u0026#34;: \u0026#34;${CdkWorks │ │ │ │ │ │ │ hopTopic}\u0026#34; │ │ │ │ │ │ │ } │ └───┴────────────────────────────────┴────────┴─────────────────┴────────────────────────────────┴────────────────────────────────┘ (NOTE: There may be security-related changes not in this list. See https://github.com/aws/aws-cdk/issues/1299) Do you wish to deploy these changes (y/n)? This is warning you that deploying the app contains security-sensitive changes. Since we need to allow the topic to send messages to the queue, enter y to deploy the stack and create the resources.\nOutput should look like the following, where ACCOUNT-ID is your account ID, REGION is the region in which you created the app, and STACK-ID is the unique identifier for your stack:\nCdkWorkshopStack: deploying... CdkWorkshopStack: creating CloudFormation changeset... 0/6 | 7:26:27 PM | CREATE_IN_PROGRESS | AWS::CDK::Metadata | CDKMetadata 0/6 | 7:26:27 PM | CREATE_IN_PROGRESS | AWS::SQS::Queue | CdkWorkshopQueue (CdkWorkshopQueue50D9D426) 0/6 | 7:26:28 PM | CREATE_IN_PROGRESS | AWS::SQS::Queue | CdkWorkshopQueue (CdkWorkshopQueue50D9D426) Resource creation Initiated 0/6 | 7:26:28 PM | CREATE_IN_PROGRESS | AWS::SNS::Topic | CdkWorkshopTopic (CdkWorkshopTopicD368A42F) 0/6 | 7:26:28 PM | CREATE_IN_PROGRESS | AWS::SNS::Topic | CdkWorkshopTopic (CdkWorkshopTopicD368A42F) Resource creation Initiated 0/6 | 7:26:29 PM | CREATE_IN_PROGRESS | AWS::CDK::Metadata | CDKMetadata Resource creation Initiated 1/6 | 7:26:29 PM | CREATE_COMPLETE | AWS::CDK::Metadata | CDKMetadata 2/6 | 7:26:29 PM | CREATE_COMPLETE | AWS::SQS::Queue | CdkWorkshopQueue (CdkWorkshopQueue50D9D426) 3/6 | 7:26:39 PM | CREATE_COMPLETE | AWS::SNS::Topic | CdkWorkshopTopic (CdkWorkshopTopicD368A42F) 3/6 | 7:26:40 PM | CREATE_IN_PROGRESS | AWS::SNS::Subscription | CdkWorkshopQueue/CdkWorkshopStackCdkWorkshopTopicD7BE9643 (CdkWorkshopQueueCdkWorkshopStackCdkWorkshopTopicD7BE96438B5AD106) 3/6 | 7:26:41 PM | CREATE_IN_PROGRESS | AWS::SQS::QueuePolicy | CdkWorkshopQueue/Policy (CdkWorkshopQueuePolicyAF2494A5) 3/6 | 7:26:41 PM | CREATE_IN_PROGRESS | AWS::SQS::QueuePolicy | CdkWorkshopQueue/Policy (CdkWorkshopQueuePolicyAF2494A5) Resource creation Initiated 3/6 | 7:26:41 PM | CREATE_IN_PROGRESS | AWS::SNS::Subscription | CdkWorkshopQueue/CdkWorkshopStackCdkWorkshopTopicD7BE9643 (CdkWorkshopQueueCdkWorkshopStackCdkWorkshopTopicD7BE96438B5AD106) Resource creation Initiated 4/6 | 7:26:41 PM | CREATE_COMPLETE | AWS::SQS::QueuePolicy | CdkWorkshopQueue/Policy (CdkWorkshopQueuePolicyAF2494A5) 5/6 | 7:26:41 PM | CREATE_COMPLETE | AWS::SNS::Subscription | CdkWorkshopQueue/CdkWorkshopStackCdkWorkshopTopicD7BE9643 (CdkWorkshopQueueCdkWorkshopStackCdkWorkshopTopicD7BE96438B5AD106) 6/6 | 7:26:43 PM | CREATE_COMPLETE | AWS::CloudFormation::Stack | CdkWorkshopStack ✅ CdkWorkshopStack Stack ARN: arn:aws:cloudformation:REGION:ACCOUNT-ID:stack/CdkWorkshopStack/STACK-ID The CloudFormation Console CDK apps are deployed through AWS CloudFormation. Each CDK stack maps 1:1 with CloudFormation stack.\nThis means that you can use the AWS CloudFormation console in order to manage your stacks.\nLet\u0026rsquo;s take a look at the AWS CloudFormation console.\nYou will likely see something like this (if you don\u0026rsquo;t, make sure you are in the correct region):\nIf you select CdkWorkshopStack and open the Resources tab, you will see the physical identities of our resources:\nI am ready for some actual coding! "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/20-create-project/500-deploy.html","title":"cdk deploy","tags":[],"description":"","content":"Okay, we\u0026rsquo;ve got a CloudFormation template. What\u0026rsquo;s next? Let\u0026rsquo;s deploy it into our account!\nBootstrapping an environment The first time you deploy an AWS CDK app into an environment (account/region), you\u0026rsquo;ll need to install a \u0026ldquo;bootstrap stack\u0026rdquo;. This stack includes resources that are needed for the toolkit\u0026rsquo;s operation. For example, the stack includes an S3 bucket that is used to store templates and assets during the deployment process.\nYou can use the cdk bootstrap command to install the bootstrap stack into an environment:\ncdk bootstrap Then:\n⏳ Bootstrapping environment 999999999999/us-west-2... ... Hopefully this command finished successfully and we can move on to deploy our app.\nLet\u0026rsquo;s deploy Use mvn package to compile the code, then cdk deploy to deploy a CDK app:\nmvn package cdk deploy You should see a warning like the following:\nThis deployment will make potentially sensitive changes according to your current security approval level (--require-approval broadening). Please confirm you intend to make the following modifications: IAM Statement Changes ┌───┬────────────────────────────────┬────────┬─────────────────┬────────────────────────────────┬────────────────────────────────┐ │ │ Resource │ Effect │ Action │ Principal │ Condition │ ├───┼────────────────────────────────┼────────┼─────────────────┼────────────────────────────────┼────────────────────────────────┤ │ + │ ${CdkWorkshopQueue.Arn} │ Allow │ sqs:SendMessage │ Service:sns.amazonaws.com │ \u0026#34;ArnEquals\u0026#34;: { │ │ │ │ │ │ │ \u0026#34;aws:SourceArn\u0026#34;: \u0026#34;${CdkWorks │ │ │ │ │ │ │ hopTopic}\u0026#34; │ │ │ │ │ │ │ } │ └───┴────────────────────────────────┴────────┴─────────────────┴────────────────────────────────┴────────────────────────────────┘ (NOTE: There may be security-related changes not in this list. See https://github.com/aws/aws-cdk/issues/1299) Do you wish to deploy these changes (y/n)? This is warning you that deploying the app contains security-sensitive changes. Since we need to allow the topic to send messages to the queue, enter y to deploy the stack and create the resources.\nOutput should look like the following, where ACCOUNT-ID is your account ID, REGION is the region in which you created the app, and STACK-ID is the unique identifier for your stack:\nCdkWorkshopStack: deploying... CdkWorkshopStack: creating CloudFormation changeset... ✅ CdkWorkshopStack Stack ARN: arn:aws:cloudformation:REGION:ACCOUNT-ID:stack/CdkWorkshopStack/STACK-ID The CloudFormation Console CDK apps are deployed through AWS CloudFormation. Each CDK stack maps 1:1 with CloudFormation stack.\nThis means that you can use the AWS CloudFormation console in order to manage your stacks.\nLet\u0026rsquo;s take a look at the AWS CloudFormation console.\nYou will likely see something like this (if you don\u0026rsquo;t, make sure you are in the correct region):\nIf you select CdkWorkshopStack and open the Resources tab, you will see the physical identities of our resources:\nI am ready for some actual coding! "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/40-hit-counter/500-logs.html","title":"CloudWatch Logs","tags":[],"description":"","content":"Lambda関数のCloudWatchログを表示する まず始めに、Lambda関数に実装されているHitCounterのログを確認します。\nSAM CLI やawslogs など、 これを行うのに役立つ多くのツールがあります。 このワークショップでは、AWSコンソールからログを見つける方法を紹介します。\nAWS Lambdaコンソールを開きます （東京リージョンに接続されていることを確認してください）。\nHitCounter Lambda関数をクリックします（名前にはCdkWorkshopStack-HelloHitCounterという文字列が含まれています)\nモニタリング をクリックします。\nCloudWatchのログを表示 をクリックします。これにより、AWS CloudWatchコンソールが開きます。\n最新のロググループを選択します。\n文字列「errorMessage」を含む最新のメッセージを探します。次のようなものが表示されるでしょう。\n{ \u0026#34;errorType\u0026#34;: \u0026#34;AccessDeniedException\u0026#34;, \u0026#34;errorMessage\u0026#34;: \u0026#34;User: arn:aws:sts::123456789012:assumed-role/CdkWorkshopStack-HelloHitCounterHitCounterHandlerS-1234567890abc/CdkWorkshopStack-HelloHitCounterHitCounterHandlerD-1234567890ab is not authorized to perform: dynamodb:UpdateItem on resource: arn:aws:dynamodb:ap-northeast-1:123456789012:table/CdkWorkshopStack-HelloHitCounterHits7AAEBF80-1234567890123 because no identity-based policy allows the dynamodb:UpdateItem action\u0026#34;, \u0026#34;code\u0026#34;: \u0026#34;AccessDeniedException\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;User: arn:aws:sts::123456789012:assumed-role/CdkWorkshopStack-HelloHitCounterHitCounterHandlerS-1234567890abc/CdkWorkshopStack-HelloHitCounterHitCounterHandlerD-1234567890ab is not authorized to perform: dynamodb:UpdateItem on resource: arn:aws:dynamodb:ap-northeast-1:123456789012:table/CdkWorkshopStack-HelloHitCounterHits7AAEBF80-1234567890123 because no identity-based policy allows the dynamodb:UpdateItem action\u0026#34;, \u0026#34;time\u0026#34;: \u0026#34;2022-09-23T14:20:32.823Z\u0026#34;, \u0026#34;requestId\u0026#34;: \u0026#34;V46RBHC7KCRS2NRKP47NFLVQJBVV4KQNSO5AEMVJF66Q9ASUAAJG\u0026#34;, \u0026#34;statusCode\u0026#34;: 400, \u0026#34;retryable\u0026#34;: false, \u0026#34;retryDelay\u0026#34;: 30.33595406645787, \u0026#34;stack\u0026#34;: [ \u0026#34;AccessDeniedException: User: arn:aws:sts::123456789012:assumed-role/CdkWorkshopStack-HelloHitCounterHitCounterHandlerS-1234567890abc/CdkWorkshopStack-HelloHitCounterHitCounterHandlerD-1234567890ab is not authorized to perform: dynamodb:UpdateItem on resource: arn:aws:dynamodb:ap-northeast-1:123456789012:table/CdkWorkshopStack-HelloHitCounterHits7AAEBF80-1234567890123 because no identity-based policy allows the dynamodb:UpdateItem action\u0026#34;, \u0026#34; at Request.extractError (/var/runtime/node_modules/aws-sdk/lib/protocol/json.js:52:27)\u0026#34;, \u0026#34; at Request.callListeners (/var/runtime/node_modules/aws-sdk/lib/sequential_executor.js:106:20)\u0026#34;, \u0026#34; at Request.emit (/var/runtime/node_modules/aws-sdk/lib/sequential_executor.js:78:10)\u0026#34;, \u0026#34; at Request.emit (/var/runtime/node_modules/aws-sdk/lib/request.js:686:14)\u0026#34;, \u0026#34; at Request.transition (/var/runtime/node_modules/aws-sdk/lib/request.js:22:10)\u0026#34;, \u0026#34; at AcceptorStateMachine.runTo (/var/runtime/node_modules/aws-sdk/lib/state_machine.js:14:12)\u0026#34;, \u0026#34; at /var/runtime/node_modules/aws-sdk/lib/state_machine.js:26:10\u0026#34;, \u0026#34; at Request.\u0026lt;anonymous\u0026gt; (/var/runtime/node_modules/aws-sdk/lib/request.js:38:9)\u0026#34;, \u0026#34; at Request.\u0026lt;anonymous\u0026gt; (/var/runtime/node_modules/aws-sdk/lib/request.js:688:12)\u0026#34;, \u0026#34; at Request.callListeners (/var/runtime/node_modules/aws-sdk/lib/sequential_executor.js:116:18)\u0026#34; ] } Lambda関数によるDynamoDBテーブルへの書き込みが、権限不足のため失敗していることがわかります。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/40-hit-counter/500-logs.html","title":"CloudWatch Logs","tags":[],"description":"","content":"Viewing CloudWatch logs for our Lambda function The first thing to do is to go and look at the logs of our hit counter AWS Lambda function.\nThere are many tools that help you do that like SAM CLI and awslogs. In this workshop, we\u0026rsquo;ll show you how to find your logs through the AWS console.\nOpen the AWS Lambda console (make sure you are connected to the correct region).\nClick on the HitCounter Lambda function (the name should contain the string HelloHitCounterHitCountHandler`): Click on Monitoring Click on View Logs in CloudWatch. This will open the AWS CloudWatch console. Select the most-recent log group.\nLook for the most-recent message containing the string \u0026ldquo;errorMessage\u0026rdquo;. You\u0026rsquo;ll likely see something like this:\n{ \u0026#34;errorMessage\u0026#34;: \u0026#34;User: arn:aws:sts::585695036304:assumed-role/hello-cdk-1-HelloHitCounterHitCounterHandlerS-TU5M09L1UBID/hello-cdk-1-HelloHitCounterHitCounterHandlerD-144HVUNEWRWEO is not authorized to perform: dynamodb:UpdateItem on resource: arn:aws:dynamodb:us-east-1:585695036304:table/hello-cdk-1-HelloHitCounterHits7AAEBF80-1DZVT3W84LJKB\u0026#34;, \u0026#34;errorType\u0026#34;: \u0026#34;AccessDeniedException\u0026#34;, \u0026#34;stackTrace\u0026#34;: [ \u0026#34;Request.extractError (/var/runtime/node_modules/aws-sdk/lib/protocol/json.js:48:27)\u0026#34;, \u0026#34;Request.callListeners (/var/runtime/node_modules/aws-sdk/lib/sequential_executor.js:105:20)\u0026#34;, \u0026#34;Request.emit (/var/runtime/node_modules/aws-sdk/lib/sequential_executor.js:77:10)\u0026#34;, \u0026#34;Request.emit (/var/runtime/node_modules/aws-sdk/lib/request.js:683:14)\u0026#34;, \u0026#34;Request.transition (/var/runtime/node_modules/aws-sdk/lib/request.js:22:10)\u0026#34;, \u0026#34;AcceptorStateMachine.runTo (/var/runtime/node_modules/aws-sdk/lib/state_machine.js:14:12)\u0026#34;, \u0026#34;/var/runtime/node_modules/aws-sdk/lib/state_machine.js:26:10\u0026#34;, \u0026#34;Request.\u0026lt;anonymous\u0026gt; (/var/runtime/node_modules/aws-sdk/lib/request.js:38:9)\u0026#34;, \u0026#34;Request.\u0026lt;anonymous\u0026gt; (/var/runtime/node_modules/aws-sdk/lib/request.js:685:12)\u0026#34;, \u0026#34;Request.callListeners (/var/runtime/node_modules/aws-sdk/lib/sequential_executor.js:115:18)\u0026#34; ] } It seems like our Lambda function can\u0026rsquo;t write to our DynamoDB table. This actually makes sense - we didn\u0026rsquo;t grant it those permissions! Let\u0026rsquo;s go do that now.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/40-hit-counter/500-logs.html","title":"CloudWatch Logs","tags":[],"description":"","content":"Viewing CloudWatch logs for our Lambda function The first thing to do is to go and look at the logs of our hit counter AWS Lambda function.\nThere are many tools that help you do that like SAM CLI and awslogs. In this workshop, we\u0026rsquo;ll show you how to find your logs through the AWS console.\nOpen the AWS Lambda console (make sure you are connected to the correct region).\nClick on the HitCounter Lambda function (the name should contain the string CdkWorkshopStack-HelloHitCounter): Click on Monitoring Click on View Logs in CloudWatch. This will open the AWS CloudWatch console. Select the most-recent log group.\nLook for the most-recent message containing the string \u0026ldquo;errorMessage\u0026rdquo;. You\u0026rsquo;ll likely see something like this:\n{ \u0026#34;errorMessage\u0026#34;: \u0026#34;User: arn:aws:sts::585695036304:assumed-role/CdkWorkshopStack-HelloHitCounterHitCounterHandlerS-TU5M09L1UBID/CdkWorkshopStack-HelloHitCounterHitCounterHandlerD-144HVUNEWRWEO is not authorized to perform: dynamodb:UpdateItem on resource: arn:aws:dynamodb:us-east-1:585695036304:table/CdkWorkshopStack-HelloHitCounterHits7AAEBF80-1DZVT3W84LJKB\u0026#34;, \u0026#34;errorType\u0026#34;: \u0026#34;AccessDeniedException\u0026#34;, \u0026#34;stackTrace\u0026#34;: [ \u0026#34;Request.extractError (/var/runtime/node_modules/aws-sdk/lib/protocol/json.js:48:27)\u0026#34;, \u0026#34;Request.callListeners (/var/runtime/node_modules/aws-sdk/lib/sequential_executor.js:105:20)\u0026#34;, \u0026#34;Request.emit (/var/runtime/node_modules/aws-sdk/lib/sequential_executor.js:77:10)\u0026#34;, \u0026#34;Request.emit (/var/runtime/node_modules/aws-sdk/lib/request.js:683:14)\u0026#34;, \u0026#34;Request.transition (/var/runtime/node_modules/aws-sdk/lib/request.js:22:10)\u0026#34;, \u0026#34;AcceptorStateMachine.runTo (/var/runtime/node_modules/aws-sdk/lib/state_machine.js:14:12)\u0026#34;, \u0026#34;/var/runtime/node_modules/aws-sdk/lib/state_machine.js:26:10\u0026#34;, \u0026#34;Request.\u0026lt;anonymous\u0026gt; (/var/runtime/node_modules/aws-sdk/lib/request.js:38:9)\u0026#34;, \u0026#34;Request.\u0026lt;anonymous\u0026gt; (/var/runtime/node_modules/aws-sdk/lib/request.js:685:12)\u0026#34;, \u0026#34;Request.callListeners (/var/runtime/node_modules/aws-sdk/lib/sequential_executor.js:115:18)\u0026#34; ] } It seems like our Lambda function can\u0026rsquo;t write to our DynamoDB table. This actually makes sense - we didn\u0026rsquo;t grant it those permissions! Let\u0026rsquo;s go do that now.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/40-hit-counter/500-logs.html","title":"CloudWatch Logs","tags":[],"description":"","content":"Viewing CloudWatch logs for our Lambda function The first thing to do is to go and look at the logs of our hit counter AWS Lambda function.\nThere are many tools that help you do that like SAM CLI and awslogs. In this workshop, we\u0026rsquo;ll show you how to find your logs through the AWS console.\nOpen the AWS Lambda console (make sure you are connected to the correct region).\nClick on the HitCounter Lambda function (the name should contain the string CdkWorkshopStack-HelloHitCounter): Click on Monitoring Click on View Logs in CloudWatch. This will open the AWS CloudWatch console. Select the most-recent log group.\nLook for the most-recent message containing the string \u0026ldquo;errorMessage\u0026rdquo;. You\u0026rsquo;ll likely see something like this:\n{ \u0026#34;errorType\u0026#34;: \u0026#34;AccessDeniedException\u0026#34;, \u0026#34;errorMessage\u0026#34;: \u0026#34;User: arn:aws:sts::XXXXXXXXX:assumed-role/CdkWorkshopStack-HelloHitCounterHitCounterHandlerS-TU5M09L1UBID/CdkWorkshopStack-HelloHitCounterHitCounterHandlerD-144HVUNEWRWEO is not authorized to perform: dynamodb:UpdateItem on resource: arn:aws:dynamodb:us-east-1:XXXXXXXXX:table/CdkWorkshopStack-HelloHitCounterHits7AAEBF80-1DZVT3W84LJKB\u0026#34;, \u0026#34;stack\u0026#34;: [ \u0026#34;AccessDeniedException: User: arn:aws:sts::XXXXXXXXX:assumed-role/CdkWorkshopStack-HelloHitCounterHitCounterHandlerS-TU5M09L1UBID/CdkWorkshopStack-HelloHitCounterHitCounterHandlerD-144HVUNEWRWEO is not authorized to perform: dynamodb:UpdateItem on resource: arn:aws:dynamodb:us-east-1:XXXXXXXXX:table/CdkWorkshopStack-HelloHitCounterHits7AAEBF80-1DZVT3W84LJKB\u0026#34;, \u0026#34;at Request.extractError (/var/runtime/node_modules/aws-sdk/lib/protocol/json.js:48:27)\u0026#34;, \u0026#34;at Request.callListeners (/var/runtime/node_modules/aws-sdk/lib/sequential_executor.js:105:20)\u0026#34;, \u0026#34;at Request.emit (/var/runtime/node_modules/aws-sdk/lib/sequential_executor.js:77:10)\u0026#34;, \u0026#34;at Request.emit (/var/runtime/node_modules/aws-sdk/lib/request.js:683:14)\u0026#34;, \u0026#34;at Request.transition (/var/runtime/node_modules/aws-sdk/lib/request.js:22:10)\u0026#34;, \u0026#34;at AcceptorStateMachine.runTo (/var/runtime/node_modules/aws-sdk/lib/state_machine.js:14:12)\u0026#34;, \u0026#34;at /var/runtime/node_modules/aws-sdk/lib/state_machine.js:26:10\u0026#34;, \u0026#34;at Request.\u0026lt;anonymous\u0026gt; (/var/runtime/node_modules/aws-sdk/lib/request.js:38:9)\u0026#34;, \u0026#34;at Request.\u0026lt;anonymous\u0026gt; (/var/runtime/node_modules/aws-sdk/lib/request.js:685:12)\u0026#34;, \u0026#34;at Request.callListeners (/var/runtime/node_modules/aws-sdk/lib/sequential_executor.js:115:18)\u0026#34; ] } It seems like our Lambda function can\u0026rsquo;t write to our DynamoDB table. This actually makes sense - we didn\u0026rsquo;t grant it those permissions! Let\u0026rsquo;s go do that now.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/50-table-viewer/500-deploy.html","title":"Deploying our app","tags":[],"description":"","content":"cdk diff Before we deploy, let\u0026rsquo;s take a look at what will happen when we deploy our app (this is just the Resources section of the output):\n$ cdk diff Resources [+] AWS::IAM::Role ViewHitCounter/Rendered/ServiceRole ViewHitCounterRenderedServiceRole254DB4EA [+] AWS::IAM::Policy ViewHitCounter/Rendered/ServiceRole/DefaultPolicy ViewHitCounterRenderedServiceRoleDefaultPolicy9ADB8C83 [+] AWS::Lambda::Function ViewHitCounter/Rendered ViewHitCounterRendered9C783E45 [+] AWS::Lambda::Permission ViewHitCounter/Rendered/ApiPermission.ANY.. ViewHitCounterRenderedApiPermissionANY72263B1A [+] AWS::Lambda::Permission ViewHitCounter/Rendered/ApiPermission.Test.ANY.. ViewHitCounterRenderedApiPermissionTestANYA4794B81 [+] AWS::Lambda::Permission ViewHitCounter/Rendered/ApiPermission.ANY..{proxy+} ViewHitCounterRenderedApiPermissionANYproxy42B9E676 [+] AWS::Lambda::Permission ViewHitCounter/Rendered/ApiPermission.Test.ANY..{proxy+} ViewHitCounterRenderedApiPermissionTestANYproxy104CA88E [+] AWS::ApiGateway::RestApi ViewHitCounter/ViewerEndpoint ViewHitCounterViewerEndpoint5A0EF326 [+] AWS::ApiGateway::Deployment ViewHitCounter/ViewerEndpoint/Deployment ViewHitCounterViewerEndpointDeployment1CE7C5768689ca8f54dfa4f161d3df0ebffcdcff [+] AWS::ApiGateway::Stage ViewHitCounter/ViewerEndpoint/DeploymentStage.prod ViewHitCounterViewerEndpointDeploymentStageprodF3901FC7 [+] AWS::IAM::Role ViewHitCounter/ViewerEndpoint/CloudWatchRole ViewHitCounterViewerEndpointCloudWatchRole87B94D6A [+] AWS::ApiGateway::Account ViewHitCounter/ViewerEndpoint/Account ViewHitCounterViewerEndpointAccount0B75E76A [+] AWS::ApiGateway::Resource ViewHitCounter/ViewerEndpoint/{proxy+} ViewHitCounterViewerEndpointproxy2F4C239F [+] AWS::ApiGateway::Method ViewHitCounter/ViewerEndpoint/{proxy+}/ANY ViewHitCounterViewerEndpointproxyANYFF4B8F5B [+] AWS::ApiGateway::Method ViewHitCounter/ViewerEndpoint/ANY ViewHitCounterViewerEndpointANY66F2285B You\u0026rsquo;ll notice that the table viewer adds another API Gateway endpoint, a Lambda function, permissions, outputs, all sorts of goodies.\nConstruct libraries are a very powerful concept. They allow you to add complex capabilities to your apps with minimum effort. However, you must understand that with great power comes great responsibility. Constructs can add IAM permissions, expose data to the public or cause your application not to function. We are working on providing you tools for protecting your app, and identifying potential security issues with your stacks, but it is your responsibility to understand how certain constructs that you use impact your application, and to make sure you only use construct libraries from vendors you trust\ncdk deploy $ cdk deploy ... CdkWorkshopStack.ViewHitCounterViewerEndpointCA1B1E4B = https://xxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ You\u0026rsquo;ll see the viewer endpoint as an output.\nViewing the hit counter table Open your browser and browse to the hit counter viewer endpoint URL. You should see something like this:\nSend a few requests Send a few more requests to your \u0026ldquo;hello\u0026rdquo; endpoint and monitor your hit counter viewer. You should see the values update in real-time.\nUse curl or your web browser to produce a few hits:\n$ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hoooot $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hoooot $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hoooot $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hoooot $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 Interested in how the Table Viewer works? It\u0026rsquo;s easy to find out! Hold Ctrl (or Command) and click on the TableViewer identifier to navigate to its source code.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/50-table-viewer/500-deploy.html","title":"Deploying our app","tags":[],"description":"","content":"cdk diff Before we deploy, let\u0026rsquo;s take a look at what will happen when we deploy our app (this is just the Resources section of the output):\n$ cdk diff Resources [+] AWS::IAM::Role ViewHitCounter/Rendered/ServiceRole ViewHitCounterRenderedServiceRole254DB4EA [+] AWS::IAM::Policy ViewHitCounter/Rendered/ServiceRole/DefaultPolicy ViewHitCounterRenderedServiceRoleDefaultPolicy9ADB8C83 [+] AWS::Lambda::Function ViewHitCounter/Rendered ViewHitCounterRendered9C783E45 [+] AWS::Lambda::Permission ViewHitCounter/Rendered/ApiPermission.ANY.. ViewHitCounterRenderedApiPermissionANY72263B1A [+] AWS::Lambda::Permission ViewHitCounter/Rendered/ApiPermission.Test.ANY.. ViewHitCounterRenderedApiPermissionTestANYA4794B81 [+] AWS::Lambda::Permission ViewHitCounter/Rendered/ApiPermission.ANY..{proxy+} ViewHitCounterRenderedApiPermissionANYproxy42B9E676 [+] AWS::Lambda::Permission ViewHitCounter/Rendered/ApiPermission.Test.ANY..{proxy+} ViewHitCounterRenderedApiPermissionTestANYproxy104CA88E [+] AWS::ApiGateway::RestApi ViewHitCounter/ViewerEndpoint ViewHitCounterViewerEndpoint5A0EF326 [+] AWS::ApiGateway::Deployment ViewHitCounter/ViewerEndpoint/Deployment ViewHitCounterViewerEndpointDeployment1CE7C5761d44312e8424c23ba090a70e0962c36f [+] AWS::ApiGateway::Stage ViewHitCounter/ViewerEndpoint/DeploymentStage.prod ViewHitCounterViewerEndpointDeploymentStageprodF3901FC7 [+] AWS::IAM::Role ViewHitCounter/ViewerEndpoint/CloudWatchRole ViewHitCounterViewerEndpointCloudWatchRole87B94D6A [+] AWS::ApiGateway::Account ViewHitCounter/ViewerEndpoint/Account ViewHitCounterViewerEndpointAccount0B75E76A [+] AWS::ApiGateway::Resource ViewHitCounter/ViewerEndpoint/Default/{proxy+} ViewHitCounterViewerEndpointproxy2F4C239F [+] AWS::ApiGateway::Method ViewHitCounter/ViewerEndpoint/Default/{proxy+}/ANY ViewHitCounterViewerEndpointproxyANYFF4B8F5B [+] AWS::ApiGateway::Method ViewHitCounter/ViewerEndpoint/Default/ANY ViewHitCounterViewerEndpointANY66F2285B You\u0026rsquo;ll notice that the table viewer adds another API Gateway endpoint, a Lambda function, permissions, outputs, all sorts of goodies.\nConstruct libraries are a very powerful concept. They allow you to add complex capabilities to your apps with minimum effort. However, you must understand that with great power comes great responsibility. Constructs can add IAM permissions, expose data to the public or cause your application not to function. We are working on providing you tools for protecting your app, and identifying potential security issues with your stacks, but it is your responsibility to understand how certain constructs that you use impact your application, and to make sure you only use construct libraries from vendors you trust\ncdk deploy $ cdk deploy ... cdk-workshop.ViewHitCounterViewerEndpointCA1B1E4B = https://6i4udz9wb2.execute-api.us-east-2.amazonaws.com/prod/ You\u0026rsquo;ll see the viewer endpoint as an output.\nViewing the hit counter table Open your browser and browse to the hit counter viewer endpoint URL. You should see something like this:\nSend a few requests Send a few more requests to your \u0026ldquo;hello\u0026rdquo; endpoint and monitor your hit counter viewer. You should see the values update in real-time.\nUse curl or your web browser to produce a few hits:\n$ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hoooot $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hoooot $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hoooot $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hoooot $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 Interested in how the Table Viewer works? It\u0026rsquo;s easy to find out! Hold Ctrl (or Command) and click on the TableViewer identifier to navigate to its source code. Or navigate to the Github repository here\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/50-table-viewer/500-deploy.html","title":"Deploying our app","tags":[],"description":"","content":"cdk diff Before we deploy, let\u0026rsquo;s take a look at what will happen when we deploy our app (this is just the Resources section of the output):\n$ cdk diff Resources [+] AWS::IAM::Role ViewHitCounter/Rendered/ServiceRole ViewHitCounterRenderedServiceRole254DB4EA [+] AWS::IAM::Policy ViewHitCounter/Rendered/ServiceRole/DefaultPolicy ViewHitCounterRenderedServiceRoleDefaultPolicy9ADB8C83 [+] AWS::Lambda::Function ViewHitCounter/Rendered ViewHitCounterRendered9C783E45 [+] AWS::Lambda::Permission ViewHitCounter/Rendered/ApiPermission.ANY.. ViewHitCounterRenderedApiPermissionANY72263B1A [+] AWS::Lambda::Permission ViewHitCounter/Rendered/ApiPermission.Test.ANY.. ViewHitCounterRenderedApiPermissionTestANYA4794B81 [+] AWS::Lambda::Permission ViewHitCounter/Rendered/ApiPermission.ANY..{proxy+} ViewHitCounterRenderedApiPermissionANYproxy42B9E676 [+] AWS::Lambda::Permission ViewHitCounter/Rendered/ApiPermission.Test.ANY..{proxy+} ViewHitCounterRenderedApiPermissionTestANYproxy104CA88E [+] AWS::ApiGateway::RestApi ViewHitCounter/ViewerEndpoint ViewHitCounterViewerEndpoint5A0EF326 [+] AWS::ApiGateway::Deployment ViewHitCounter/ViewerEndpoint/Deployment ViewHitCounterViewerEndpointDeployment1CE7C5768689ca8f54dfa4f161d3df0ebffcdcff [+] AWS::ApiGateway::Stage ViewHitCounter/ViewerEndpoint/DeploymentStage.prod ViewHitCounterViewerEndpointDeploymentStageprodF3901FC7 [+] AWS::IAM::Role ViewHitCounter/ViewerEndpoint/CloudWatchRole ViewHitCounterViewerEndpointCloudWatchRole87B94D6A [+] AWS::ApiGateway::Account ViewHitCounter/ViewerEndpoint/Account ViewHitCounterViewerEndpointAccount0B75E76A [+] AWS::ApiGateway::Resource ViewHitCounter/ViewerEndpoint/{proxy+} ViewHitCounterViewerEndpointproxy2F4C239F [+] AWS::ApiGateway::Method ViewHitCounter/ViewerEndpoint/{proxy+}/ANY ViewHitCounterViewerEndpointproxyANYFF4B8F5B [+] AWS::ApiGateway::Method ViewHitCounter/ViewerEndpoint/ANY ViewHitCounterViewerEndpointANY66F2285B You\u0026rsquo;ll notice that the table viewer adds another API Gateway endpoint, a Lambda function, permissions, outputs, all sorts of goodies.\nConstruct libraries are a very powerful concept. They allow you to add complex capabilities to your apps with minimum effort. However, you must understand that with great power comes great responsibility. Constructs can add IAM permissions, expose data to the public or cause your application not to function. We are working on providing you tools for protecting your app, and identifying potential security issues with your stacks, but it is your responsibility to understand how certain constructs that you use impact your application, and to make sure you only use construct libraries from vendors you trust\ncdk deploy $ cdk deploy ... CdkWorkshopStack.ViewHitCounterViewerEndpointCA1B1E4B = https://xxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ You\u0026rsquo;ll see the viewer endpoint as an output.\nViewing the hit counter table Open your browser and browse to the hit counter viewer endpoint URL. You should see something like this:\nSend a few requests Send a few more requests to your \u0026ldquo;hello\u0026rdquo; endpoint and monitor your hit counter viewer. You should see the values update in real-time.\nUse curl or your web browser to produce a few hits:\n$ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hoooot $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hoooot $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hoooot $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hoooot $ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hit1 Interested in how the Table Viewer works? It\u0026rsquo;s easy to find out! Hold Ctrl (or Command) and click on the TableViewer identifier to navigate to its source code.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/50-table-viewer/500-extra-credit.html","title":"Extra credit","tags":[],"description":"","content":"Sort hits by descending order You\u0026rsquo;ll notice that the hits in the table are not sorted. Figure out how to configure the table viewer to sort the table by \u0026ldquo;hits\u0026rdquo; in descending order (top path is first).\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/50-table-viewer/600-extra-credit.html","title":"Extra credit","tags":[],"description":"","content":"Sort hits by descending order You\u0026rsquo;ll notice that the hits in the table are not sorted. Figure out how to configure the table viewer to sort the table by \u0026ldquo;hits\u0026rdquo; in descending order (top path is first).\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/50-table-viewer/600-extra-credit.html","title":"Extra credit","tags":[],"description":"","content":"Sort hits by descending order You\u0026rsquo;ll notice that the hits in the table are not sorted. Figure out how to configure the table viewer to sort the table by \u0026ldquo;hits\u0026rdquo; in descending order (top path is first).\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/50-table-viewer/600-extra-credit.html","title":"Extra credit","tags":[],"description":"","content":"Sort hits by descending order You\u0026rsquo;ll notice that the hits in the table are not sorted. Figure out how to configure the table viewer to sort the table by \u0026ldquo;hits\u0026rdquo; in descending order (top path is first).\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/40-hit-counter/600-permissions.html","title":"Granting permissions","tags":[],"description":"","content":"Allow Lambda to read/write our DynamoDB table Let\u0026rsquo;s give our Lambda\u0026rsquo;s execution role permissions to read/write from our table.\nGo back to hitcounter.py and add the following highlighted line:\nfrom constructs import Construct from aws_cdk import ( aws_lambda as _lambda, aws_dynamodb as ddb, ) class HitCounter(Construct): @property def handler(self): return self._handler def __init__(self, scope: Construct, id: str, downstream: _lambda.IFunction, **kwargs): super().__init__(scope, id, **kwargs) table = ddb.Table( self, \u0026#39;Hits\u0026#39;, partition_key={\u0026#39;name\u0026#39;: \u0026#39;path\u0026#39;, \u0026#39;type\u0026#39;: ddb.AttributeType.STRING} ) self._handler = _lambda.Function( self, \u0026#39;HitCountHandler\u0026#39;, runtime=_lambda.Runtime.PYTHON_3_7, handler=\u0026#39;hitcount.handler\u0026#39;, code=_lambda.Code.from_asset(\u0026#39;lambda\u0026#39;), environment={ \u0026#39;DOWNSTREAM_FUNCTION_NAME\u0026#39;: downstream.function_name, \u0026#39;HITS_TABLE_NAME\u0026#39;: table.table_name, } ) table.grant_read_write_data(self._handler) Deploy Save \u0026amp; deploy:\ncdk deploy Test again Okay, deployment is complete. Let\u0026rsquo;s run our test again (either use curl or your web browser):\ncurl -i https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ Again?\nHTTP/1.1 502 Bad Gateway ... {\u0026#34;message\u0026#34;: \u0026#34;Internal server error\u0026#34;} 😢 Still getting this pesky 5xx error! Let\u0026rsquo;s look at our CloudWatch logs again (click \u0026ldquo;Refresh\u0026rdquo;):\n{ \u0026#34;errorMessage\u0026#34;: \u0026#34;User: arn:aws:sts::585695036304:assumed-role/hello-cdk-1-HelloHitCounterHitCounterHandlerS-TU5M09L1UBID/hello-cdk-1-HelloHitCounterHitCounterHandlerD-144HVUNEWRWEO is not authorized to perform: lambda:InvokeFunction on resource: arn:aws:lambda:us-east-1:585695036304:function:hello-cdk-1-HelloHandler2E4FBA4D-149MVAO4969O7\u0026#34;, \u0026#34;errorType\u0026#34;: \u0026#34;AccessDeniedException\u0026#34;, \u0026#34;stackTrace\u0026#34;: [ \u0026#34;Object.extractError (/var/runtime/node_modules/aws-sdk/lib/protocol/json.js:48:27)\u0026#34;, \u0026#34;Request.extractError (/var/runtime/node_modules/aws-sdk/lib/protocol/rest_json.js:52:8)\u0026#34;, \u0026#34;Request.callListeners (/var/runtime/node_modules/aws-sdk/lib/sequential_executor.js:105:20)\u0026#34;, \u0026#34;Request.emit (/var/runtime/node_modules/aws-sdk/lib/sequential_executor.js:77:10)\u0026#34;, \u0026#34;Request.emit (/var/runtime/node_modules/aws-sdk/lib/request.js:683:14)\u0026#34;, \u0026#34;Request.transition (/var/runtime/node_modules/aws-sdk/lib/request.js:22:10)\u0026#34;, \u0026#34;AcceptorStateMachine.runTo (/var/runtime/node_modules/aws-sdk/lib/state_machine.js:14:12)\u0026#34;, \u0026#34;/var/runtime/node_modules/aws-sdk/lib/state_machine.js:26:10\u0026#34;, \u0026#34;Request.\u0026lt;anonymous\u0026gt; (/var/runtime/node_modules/aws-sdk/lib/request.js:38:9)\u0026#34;, \u0026#34;Request.\u0026lt;anonymous\u0026gt; (/var/runtime/node_modules/aws-sdk/lib/request.js:685:12)\u0026#34; ] } Another access denied, but this time, if you take a close look:\nUser: \u0026lt;VERY-LONG-STRING\u0026gt; is not authorized to perform: lambda:InvokeFunction on resource: \u0026lt;VERY-LONG-STRING\u0026gt;\u0026#34; So it seems like our hit counter actually managed to write to the database. We can confirm by going to the DynamoDB Console:\nBut, we must also give our hit counter permissions to invoke the downstream lambda function.\nGrant invoke permissions Add the highlighted lines to cdk_workshop/hitcounter.py:\nfrom constructs import Construct from aws_cdk import ( aws_lambda as _lambda, aws_dynamodb as ddb, ) class HitCounter(Construct): @property def handler(self): return self._handler def __init__(self, scope: Construct, id: str, downstream: _lambda.IFunction, **kwargs): super().__init__(scope, id, **kwargs) table = ddb.Table( self, \u0026#39;Hits\u0026#39;, partition_key={\u0026#39;name\u0026#39;: \u0026#39;path\u0026#39;, \u0026#39;type\u0026#39;: ddb.AttributeType.STRING} ) self._handler = _lambda.Function( self, \u0026#39;HitCountHandler\u0026#39;, runtime=_lambda.Runtime.PYTHON_3_7, handler=\u0026#39;hitcount.handler\u0026#39;, code=_lambda.Code.from_asset(\u0026#39;lambda\u0026#39;), environment={ \u0026#39;DOWNSTREAM_FUNCTION_NAME\u0026#39;: downstream.function_name, \u0026#39;HITS_TABLE_NAME\u0026#39;: table.table_name, } ) table.grant_read_write_data(self._handler) downstream.grant_invoke(self._handler) Diff You can check what this did using cdk diff:\ncdk diff The Resource section should look something like this, which shows the IAM statement was added to the role:\nStack cdk-workshop The cdk-workshop stack uses assets, which are currently not accounted for in the diff output! See https://github.com/awslabs/aws-cdk/issues/395 IAM Statement Changes ┌───┬────────────────────────┬────────┬────────────────────────┬────────────────────────┬───────────┐ │ │ Resource │ Effect │ Action │ Principal │ Condition │ ├───┼────────────────────────┼────────┼────────────────────────┼────────────────────────┼───────────┤ │ + │ ${HelloHandler.Arn} │ Allow │ lambda:InvokeFunction │ AWS:${HelloHitCounter/ │ │ │ │ │ │ │ HitCounterHandler/Serv │ │ │ │ │ │ │ iceRole} │ │ └───┴────────────────────────┴────────┴────────────────────────┴────────────────────────┴───────────┘ (NOTE: There may be security-related changes not in this list. See http://bit.ly/cdk-2EhF7Np) Resources [~] AWS::IAM::Policy HelloHitCounter/HitCounterHandler/ServiceRole/DefaultPolicy HelloHitCounterHitCounterHandlerServiceRoleDefaultPolicy1487A60A └─ [~] PolicyDocument └─ [~] .Statement: └─ @@ -24,5 +24,15 @@ [ ] \u0026#34;Ref\u0026#34;: \u0026#34;AWS::NoValue\u0026#34; [ ] } [ ] ] [+] }, [+] { [+] \u0026#34;Action\u0026#34;: \u0026#34;lambda:InvokeFunction\u0026#34;, [+] \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, [+] \u0026#34;Resource\u0026#34;: { [+] \u0026#34;Fn::GetAtt\u0026#34;: [ [+] \u0026#34;HelloHandler2E4FBA4D\u0026#34;, [+] \u0026#34;Arn\u0026#34; [+] ] [+] } [ ] } [ ] ] Which is exactly what we wanted.\nDeploy Okay\u0026hellip; let\u0026rsquo;s give this another shot:\ncdk deploy Then hit your endpoint with curl or with your web browser:\ncurl -i https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ Output should look like this:\nHTTP/1.1 200 OK ... Hello, CDK! You\u0026#39;ve hit / If you still get 5xx, give it a few seconds and try again. Sometimes API Gateway takes a little bit to \u0026ldquo;flip\u0026rdquo; the endpoint to use the new deployment.\n😲 "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/40-hit-counter/600-permissions.html","title":"Granting permissions","tags":[],"description":"","content":"Allow Lambda to read/write our DynamoDB table Let\u0026rsquo;s give our Lambda\u0026rsquo;s execution role permissions to read/write from our table.\nGo back to src/CdkWorkshop/HitCounter.cs and add the following highlighted lines:\nusing Amazon.CDK; using Amazon.CDK.AWS.Lambda; using Amazon.CDK.AWS.DynamoDB; using Constructs; using System.Collections.Generic; namespace CdkWorkshop { public class HitCounterProps { // The function for which we want to count url hits public IFunction Downstream { get; set; } } public class HitCounter : Construct { public IFunction Handler { get; }; public HitCounter(Construct scope, string id, HitCounterProps props) : base(scope, id) { var table = new Table(this, \u0026#34;Hits\u0026#34;, new TableProps { PartitionKey = new Attribute { Name = \u0026#34;path\u0026#34;, Type = AttributeType.STRING } }); Handler = new Function(this, \u0026#34;HitCounterHandler\u0026#34;, new FunctionProps { Runtime = Runtime.NODEJS_14_X, Handler = \u0026#34;hitcounter.handler\u0026#34;, Code = Code.FromAsset(\u0026#34;lambda\u0026#34;), Environment = new Dictionary\u0026lt;string, string\u0026gt; { [\u0026#34;DOWNSTREAM_FUNCTION_NAME\u0026#34;] = props.Downstream.FunctionName, [\u0026#34;HITS_TABLE_NAME\u0026#34;] = table.TableName } }); // Grant the lambda role read/write permissions to our table table.GrantReadWriteData(Handler); } } } Deploy Save \u0026amp; deploy:\ncdk deploy Test again Okay, deployment is complete. Let\u0026rsquo;s run our test again (either use curl or your web browser):\ncurl -i https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ Again?\nHTTP/1.1 502 Bad Gateway ... {\u0026#34;message\u0026#34;: \u0026#34;Internal server error\u0026#34;} 😢 Still getting this pesky 5xx error! Let\u0026rsquo;s look at our CloudWatch logs again (click \u0026ldquo;Refresh\u0026rdquo;):\n{ \u0026#34;errorMessage\u0026#34;: \u0026#34;User: arn:aws:sts::585695036304:assumed-role/CdkWorkshopStack-HelloHitCounterHitCounterHandlerS-TU5M09L1UBID/CdkWorkshopStack-HelloHitCounterHitCounterHandlerD-144HVUNEWRWEO is not authorized to perform: lambda:InvokeFunction on resource: arn:aws:lambda:us-east-1:585695036304:function:CdkWorkshopStack-HelloHandler2E4FBA4D-149MVAO4969O7\u0026#34;, \u0026#34;errorType\u0026#34;: \u0026#34;AccessDeniedException\u0026#34;, \u0026#34;stackTrace\u0026#34;: [ \u0026#34;Object.extractError (/var/runtime/node_modules/aws-sdk/lib/protocol/json.js:48:27)\u0026#34;, \u0026#34;Request.extractError (/var/runtime/node_modules/aws-sdk/lib/protocol/rest_json.js:52:8)\u0026#34;, \u0026#34;Request.callListeners (/var/runtime/node_modules/aws-sdk/lib/sequential_executor.js:105:20)\u0026#34;, \u0026#34;Request.emit (/var/runtime/node_modules/aws-sdk/lib/sequential_executor.js:77:10)\u0026#34;, \u0026#34;Request.emit (/var/runtime/node_modules/aws-sdk/lib/request.js:683:14)\u0026#34;, \u0026#34;Request.transition (/var/runtime/node_modules/aws-sdk/lib/request.js:22:10)\u0026#34;, \u0026#34;AcceptorStateMachine.runTo (/var/runtime/node_modules/aws-sdk/lib/state_machine.js:14:12)\u0026#34;, \u0026#34;/var/runtime/node_modules/aws-sdk/lib/state_machine.js:26:10\u0026#34;, \u0026#34;Request.\u0026lt;anonymous\u0026gt; (/var/runtime/node_modules/aws-sdk/lib/request.js:38:9)\u0026#34;, \u0026#34;Request.\u0026lt;anonymous\u0026gt; (/var/runtime/node_modules/aws-sdk/lib/request.js:685:12)\u0026#34; ] } Another access denied, but this time, if you take a close look:\nUser: \u0026lt;VERY-LONG-STRING\u0026gt; is not authorized to perform: lambda:InvokeFunction on resource: \u0026lt;VERY-LONG-STRING\u0026gt;\u0026#34; So it seems like our hit counter actually managed to write to the database. We can confirm by going to the DynamoDB Console:\nBut, we must also give our hit counter permissions to invoke the downstream lambda function.\nGrant invoke permissions Add the highlighted lines to src/CdkWorkshop/HitCounter.cs:\nusing Amazon.CDK; using Amazon.CDK.AWS.Lambda; using Amazon.CDK.AWS.DynamoDB; using Constructs; using System.Collections.Generic; namespace CdkWorkshop { public class HitCounterProps { // The function for which we want to count url hits public IFunction Downstream { get; set; } } public class HitCounter : Construct { public IFunction Handler { get; }; public HitCounter(Construct scope, string id, HitCounterProps props) : base(scope, id) { var table = new Table(this, \u0026#34;Hits\u0026#34;, new TableProps { PartitionKey = new Attribute { Name = \u0026#34;path\u0026#34;, Type = AttributeType.STRING } }); Handler = new Function(this, \u0026#34;HitCounterHandler\u0026#34;, new FunctionProps { Runtime = Runtime.NODEJS_14_X, Handler = \u0026#34;hitcounter.handler\u0026#34;, Code = Code.FromAsset(\u0026#34;lambda\u0026#34;), Environment = new Dictionary\u0026lt;string, string\u0026gt; { [\u0026#34;DOWNSTREAM_FUNCTION_NAME\u0026#34;] = props.Downstream.FunctionName, [\u0026#34;HITS_TABLE_NAME\u0026#34;] = table.TableName } }); // Grant the lambda role read/write permissions to our table table.GrantReadWriteData(Handler); // Grant the lambda role invoke permissions to the downstream function props.Downstream.GrantInvoke(Handler); } } } Diff You can check what this did using cdk diff:\ncdk diff The Resource section should look something like this, which shows the IAM statement was added to the role:\nResources [~] AWS::IAM::Policy HelloHitCounter/HitCounterHandler/ServiceRole/DefaultPolicy HelloHitCounterHitCounterHandlerServiceRoleDefaultPolicy1487A60A └─ [~] PolicyDocument └─ [~] .Statement: └─ @@ -19,5 +19,15 @@ [ ] \u0026#34;Arn\u0026#34; [ ] ] [ ] } [+] }, [+] { [+] \u0026#34;Action\u0026#34;: \u0026#34;lambda:InvokeFunction\u0026#34;, [+] \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, [+] \u0026#34;Resource\u0026#34;: { [+] \u0026#34;Fn::GetAtt\u0026#34;: [ [+] \u0026#34;HelloHandler2E4FBA4D\u0026#34;, [+] \u0026#34;Arn\u0026#34; [+] ] [+] } [ ] } [ ] ] Which is exactly what we wanted.\nDeploy Okay\u0026hellip; let\u0026rsquo;s give this another shot:\ncdk deploy Then hit your endpoint with curl or with your web browser:\ncurl -i https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ Output should look like this:\nHTTP/1.1 200 OK ... Hello, CDK! You\u0026#39;ve hit / If you still get 5xx, give it a few seconds and try again. Sometimes API Gateway takes a little bit to \u0026ldquo;flip\u0026rdquo; the endpoint to use the new deployment.\n😲 "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/40-hit-counter/600-permissions.html","title":"Granting permissions","tags":[],"description":"","content":"Allow Lambda to read/write our DynamoDB table Let\u0026rsquo;s give our Lambda\u0026rsquo;s execution role permissions to read/write from our table.\nGo back to ~/HitCounter.java and add the following highlighted lines:\npackage com.myorg; import java.util.HashMap; import java.util.Map; import software.constructs.Construct; import software.amazon.awscdk.services.dynamodb.Attribute; import software.amazon.awscdk.services.dynamodb.AttributeType; import software.amazon.awscdk.services.dynamodb.Table; import software.amazon.awscdk.services.lambda.Code; import software.amazon.awscdk.services.lambda.Function; import software.amazon.awscdk.services.lambda.Runtime; public class HitCounter extends Construct { private final Function handler; private final Table table; public HitCounter(final Construct scope, final String id, final HitCounterProps props) { super(scope, id); this.table = Table.Builder.create(this, \u0026#34;Hits\u0026#34;) .partitionKey(Attribute.builder() .name(\u0026#34;path\u0026#34;) .type(AttributeType.STRING) .build()) .build(); final Map\u0026lt;String, String\u0026gt; environment = new HashMap\u0026lt;\u0026gt;(); environment.put(\u0026#34;DOWNSTREAM_FUNCTION_NAME\u0026#34;, props.getDownstream().getFunctionName()); environment.put(\u0026#34;HITS_TABLE_NAME\u0026#34;, this.table.getTableName()); this.handler = Function.Builder.create(this, \u0026#34;HitCounterHandler\u0026#34;) .runtime(Runtime.NODEJS_14_X) .handler(\u0026#34;hitcounter.handler\u0026#34;) .code(Code.fromAsset(\u0026#34;lambda\u0026#34;)) .environment(environment) .build(); // Grants the lambda function read/write permissions to our table this.table.grantReadWriteData(this.handler); } /** * @return the counter definition */ public Function getHandler() { return this.handler; } /** * @return the counter table */ public Table getTable() { return this.table; } } Deploy Save \u0026amp; deploy:\nmvn package cdk deploy Test again Okay, deployment is complete. Let\u0026rsquo;s run our test again (either use curl or your web browser):\ncurl -i https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ Again?\nHTTP/1.1 502 Bad Gateway ... {\u0026#34;message\u0026#34;: \u0026#34;Internal server error\u0026#34;} 😢 Still getting this pesky 5xx error! Let\u0026rsquo;s look at our CloudWatch logs again (click \u0026ldquo;Refresh\u0026rdquo;):\n{ \u0026#34;errorType\u0026#34;: \u0026#34;AccessDeniedException\u0026#34;, \u0026#34;errorMessage\u0026#34;: \u0026#34;User: arn:aws:sts::XXXXXXXXXX:assumed-role/CdkWorkshopStack-HelloHitCounterHitCounterHandlerS-TU5M09L1UBID/CdkWorkshopStack-HelloHitCounterHitCounterHandlerD-144HVUNEWRWEO is not authorized to perform: lambda:InvokeFunction on resource: arn:aws:lambda:us-east-1:XXXXXXXXXXX:function:CdkWorkshopStack-HelloHandler2E4FBA4D-149MVAO4969O7\u0026#34;, \u0026#34;stack\u0026#34;: [ \u0026#34;AccessDeniedException: User: arn:aws:sts::XXXXXXXXXX:assumed-role/CdkWorkshopStack-HelloHitCounterHitCounterHandlerS-TU5M09L1UBID/CdkWorkshopStack-HelloHitCounterHitCounterHandlerD-144HVUNEWRWEO is not authorized to perform: lambda:InvokeFunction on resource: arn:aws:lambda:us-east-1:XXXXXXXXXXX:function:CdkWorkshopStack-HelloHandler2E4FBA4D-149MVAO4969O7\u0026#34;, \u0026#34;at Object.extractError (/var/runtime/node_modules/aws-sdk/lib/protocol/json.js:48:27)\u0026#34;, \u0026#34;at Request.extractError (/var/runtime/node_modules/aws-sdk/lib/protocol/rest_json.js:52:8)\u0026#34;, \u0026#34;at Request.callListeners (/var/runtime/node_modules/aws-sdk/lib/sequential_executor.js:105:20)\u0026#34;, \u0026#34;at Request.emit (/var/runtime/node_modules/aws-sdk/lib/sequential_executor.js:77:10)\u0026#34;, \u0026#34;at Request.emit (/var/runtime/node_modules/aws-sdk/lib/request.js:683:14)\u0026#34;, \u0026#34;at Request.transition (/var/runtime/node_modules/aws-sdk/lib/request.js:22:10)\u0026#34;, \u0026#34;at AcceptorStateMachine.runTo (/var/runtime/node_modules/aws-sdk/lib/state_machine.js:14:12)\u0026#34;, \u0026#34;at /var/runtime/node_modules/aws-sdk/lib/state_machine.js:26:10\u0026#34;, \u0026#34;at Request.\u0026lt;anonymous\u0026gt; (/var/runtime/node_modules/aws-sdk/lib/request.js:38:9)\u0026#34;, \u0026#34;at Request.\u0026lt;anonymous\u0026gt; (/var/runtime/node_modules/aws-sdk/lib/request.js:685:12)\u0026#34; ] } Another access denied, but this time, if you take a close look:\nUser: \u0026lt;VERY-LONG-STRING\u0026gt; is not authorized to perform: lambda:InvokeFunction on resource: \u0026lt;VERY-LONG-STRING\u0026gt;\u0026#34; So it seems like our hit counter actually managed to write to the database. We can confirm by going to the DynamoDB Console:\nBut, we must also give our hit counter permissions to invoke the downstream lambda function.\nGrant invoke permissions Add the highlighted lines to src/CdkWorkshop/HitCounter.java:\npackage com.myorg; import java.util.HashMap; import java.util.Map; import software.constructs.Construct; import software.amazon.awscdk.services.dynamodb.Attribute; import software.amazon.awscdk.services.dynamodb.AttributeType; import software.amazon.awscdk.services.dynamodb.Table; import software.amazon.awscdk.services.lambda.Code; import software.amazon.awscdk.services.lambda.Function; import software.amazon.awscdk.services.lambda.Runtime; public class HitCounter extends Construct { private final Function handler; private final Table table; public HitCounter(final Construct scope, final String id, final HitCounterProps props) { super(scope, id); this.table = Table.Builder.create(this, \u0026#34;Hits\u0026#34;) .partitionKey(Attribute.builder() .name(\u0026#34;path\u0026#34;) .type(AttributeType.STRING) .build()) .build(); final Map\u0026lt;String, String\u0026gt; environment = new HashMap\u0026lt;\u0026gt;(); environment.put(\u0026#34;DOWNSTREAM_FUNCTION_NAME\u0026#34;, props.getDownstream().getFunctionName()); environment.put(\u0026#34;HITS_TABLE_NAME\u0026#34;, this.table.getTableName()); this.handler = Function.Builder.create(this, \u0026#34;HitCounterHandler\u0026#34;) .runtime(Runtime.NODEJS_14_X) .handler(\u0026#34;hitcounter.handler\u0026#34;) .code(Code.fromAsset(\u0026#34;lambda\u0026#34;)) .environment(environment) .build(); // Grants the lambda function read/write permissions to our table this.table.grantReadWriteData(this.handler); // Grants the lambda function invoke permissions to the downstream function props.getDownstream().grantInvoke(this.handler); } /** * @return the counter definition */ public Function getHandler() { return this.handler; } /** * @return the counter table */ public Table getTable() { return this.table; } } Diff You can check what this did using cdk diff:\nmvn package cdk diff The Resource section should look something like this, which shows the IAM statement was added to the role:\nIAM Statement Changes ┌───┬────────────────────────────────────────┬────────┬────────────────────────────────────────┬─────────────────────────────────────────┬───────────┐ │ │ Resource │ Effect │ Action │ Principal │ Condition │ ├───┼────────────────────────────────────────┼────────┼────────────────────────────────────────┼─────────────────────────────────────────┼───────────┤ │ + │ ${HelloHandler.Arn} │ Allow │ lambda:InvokeFunction │ AWS:${HelloHitCounter/HitCounterHandler │ │ │ │ │ │ │ /ServiceRole} │ │ ├───┼────────────────────────────────────────┼────────┼────────────────────────────────────────┼─────────────────────────────────────────┼───────────┤ │ + │ ${HelloHitCounter/Hits.Arn} │ Allow │ dynamodb:BatchGetItem │ AWS:${HelloHitCounter/HitCounterHandler │ │ │ │ │ │ dynamodb:BatchWriteItem │ /ServiceRole} │ │ │ │ │ │ dynamodb:DeleteItem │ │ │ │ │ │ │ dynamodb:GetItem │ │ │ │ │ │ │ dynamodb:GetRecords │ │ │ │ │ │ │ dynamodb:GetShardIterator │ │ │ │ │ │ │ dynamodb:PutItem │ │ │ │ │ │ │ dynamodb:Query │ │ │ │ │ │ │ dynamodb:Scan │ │ │ │ │ │ │ dynamodb:UpdateItem │ │ │ └───┴────────────────────────────────────────┴────────┴────────────────────────────────────────┴─────────────────────────────────────────┴───────────┘ (NOTE: There may be security-related changes not in this list. See https://github.com/aws/aws-cdk/issues/1299) Resources [+] AWS::IAM::Policy HelloHitCounter/HitCounterHandler/ServiceRole/DefaultPolicy HelloHitCounterHitCounterHandlerServiceRoleDefaultPolicy1487A60A [~] AWS::Lambda::Function HelloHitCounter/HitCounterHandler HelloHitCounterHitCounterHandlerDAEA7B37 └─ [~] DependsOn └─ @@ -1,3 +1,4 @@ [ ] [ [+] \u0026#34;HelloHitCounterHitCounterHandlerServiceRoleDefaultPolicy1487A60A\u0026#34;, [ ] \u0026#34;HelloHitCounterHitCounterHandlerServiceRoleD45002B8\u0026#34; [ ] ] Which is exactly what we wanted.\nDeploy Okay\u0026hellip; let\u0026rsquo;s give this another shot:\ncdk deploy Then hit your endpoint with curl or with your web browser:\ncurl -i https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ Output should look like this:\nHTTP/1.1 200 OK ... Hello, CDK! You\u0026#39;ve hit / If you still get 5xx, give it a few seconds and try again. Sometimes API Gateway takes a little bit to \u0026ldquo;flip\u0026rdquo; the endpoint to use the new deployment.\n😲 "},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/15-prerequisites/600-python.html","title":"Python","tags":[],"description":"","content":"If you are planning on using the Python Workshop, you obviously will need to have Python installed. Specifically, you will need version 3.6 or later. You can find information about downloading and installing Python here.\nIf you use Windows, be sure Python is on your PATH. To see if it is, type python at a command prompt. The easiest way to make sure Python is on your PATH is to tick the Add Python 3.x to PATH checkbox on the first screen of the Python installer wizard. If you already have Python installed, but it\u0026rsquo;s not on your PATH, you can add it by editing the PATH environment variable. To edit environment variables, click the Environment Variables button in the Advanced page of Windows\u0026rsquo; System Properties. (Quickest way to get there: press and release the Windows key, type env, and choose Edit the system environment variables from the Start menu.)\nAdditionally you will need to have the Python package installer (pip) installed. See installation instructions here.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/40-hit-counter/600-permissions.html","title":"パーミッションの付与","tags":[],"description":"","content":"LambdaがDynamoDBテーブルを読み書きできるようにする Lambdaの実行ロールに、DynamoDBテーブルの読み取り/書き込み権限を与えましょう。\nhitcounter.tsに戻り、次の強調表示された行を追加します。\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import * as lambda from \u0026#39;aws-cdk-lib/aws-lambda\u0026#39;; import * as dynamodb from \u0026#39;aws-cdk-lib/aws-dynamodb\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; export interface HitCounterProps { /** the function for which we want to count url hits **/ downstream: lambda.IFunction; } export class HitCounter extends Construct { /** allows accessing the counter function */ public readonly handler: lambda.Function; constructor(scope: Construct, id: string, props: HitCounterProps) { super(scope, id); const table = new dynamodb.Table(this, \u0026#39;Hits\u0026#39;, { partitionKey: { name: \u0026#39;path\u0026#39;, type: dynamodb.AttributeType.STRING } }); this.handler = new lambda.Function(this, \u0026#39;HitCounterHandler\u0026#39;, { runtime: lambda.Runtime.NODEJS_14_X, handler: \u0026#39;hitcounter.handler\u0026#39;, code: lambda.Code.fromAsset(\u0026#39;lambda\u0026#39;), environment: { DOWNSTREAM_FUNCTION_NAME: props.downstream.functionName, HITS_TABLE_NAME: table.tableName } }); // grant the lambda role read/write permissions to our table table.grantReadWriteData(this.handler); } } デプロイ 保存してデプロイしてみましょう。\ncdk deploy 再テスト さて、デプロイが完了しました。テストをもう一度実行してみましょう（curlコマンドかWebブラウザのいずれかを使用してください）\ncurl -i https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ またもやエラーが発生しました。\nHTTP/2 502 Bad Gateway ... {\u0026#34;message\u0026#34;: \u0026#34;Internal server error\u0026#34;} 再調査 まだこの厄介な5xxエラーが発生しています。CloudWatchログをもう一度見てみましょう（「更新」をクリックします）。\n{ \u0026#34;errorType\u0026#34;: \u0026#34;AccessDeniedException\u0026#34;, \u0026#34;errorMessage\u0026#34;: \u0026#34;User: arn:aws:sts::123456789012:assumed-role/CdkWorkshopStack-HelloHitCounterHitCounterHandlerS-1234567890123/CdkWorkshopStack-HelloHitCounterHitCounterHandlerD-123456789012 is not authorized to perform: lambda:InvokeFunction on resource: arn:aws:lambda:ap-northeast-1:123456789012:function:CdkWorkshopStack-HelloHandler2E4FBA4D-123456789012 because no identity-based policy allows the lambda:InvokeFunction action\u0026#34;, \u0026#34;code\u0026#34;: \u0026#34;AccessDeniedException\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;User: arn:aws:sts::123456789012:assumed-role/CdkWorkshopStack-HelloHitCounterHitCounterHandlerS-1234567890123/CdkWorkshopStack-HelloHitCounterHitCounterHandlerD-123456789012 is not authorized to perform: lambda:InvokeFunction on resource: arn:aws:lambda:ap-northeast-1:123456789012:function:CdkWorkshopStack-HelloHandler2E4FBA4D-123456789012 because no identity-based policy allows the lambda:InvokeFunction action\u0026#34;, \u0026#34;time\u0026#34;: \u0026#34;2022-09-24T14:02:52.516Z\u0026#34;, \u0026#34;requestId\u0026#34;: \u0026#34;2484f30b-70f7-42df-b9ac-134d995c1631\u0026#34;, \u0026#34;statusCode\u0026#34;: 403, \u0026#34;retryable\u0026#34;: false, \u0026#34;retryDelay\u0026#34;: 4.445030300047104, \u0026#34;stack\u0026#34;: [ \u0026#34;AccessDeniedException: User: arn:aws:sts::123456789012:assumed-role/CdkWorkshopStack-HelloHitCounterHitCounterHandlerS-1234567890123/CdkWorkshopStack-HelloHitCounterHitCounterHandlerD-123456789012 is not authorized to perform: lambda:InvokeFunction on resource: arn:aws:lambda:ap-northeast-1:123456789012:function:CdkWorkshopStack-HelloHandler2E4FBA4D-123456789012 because no identity-based policy allows the lambda:InvokeFunction action\u0026#34;, \u0026#34; at Object.extractError (/var/runtime/node_modules/aws-sdk/lib/protocol/json.js:52:27)\u0026#34;, \u0026#34; at Request.extractError (/var/runtime/node_modules/aws-sdk/lib/protocol/rest_json.js:49:8)\u0026#34;, \u0026#34; at Request.callListeners (/var/runtime/node_modules/aws-sdk/lib/sequential_executor.js:106:20)\u0026#34;, \u0026#34; at Request.emit (/var/runtime/node_modules/aws-sdk/lib/sequential_executor.js:78:10)\u0026#34;, \u0026#34; at Request.emit (/var/runtime/node_modules/aws-sdk/lib/request.js:686:14)\u0026#34;, \u0026#34; at Request.transition (/var/runtime/node_modules/aws-sdk/lib/request.js:22:10)\u0026#34;, \u0026#34; at AcceptorStateMachine.runTo (/var/runtime/node_modules/aws-sdk/lib/state_machine.js:14:12)\u0026#34;, \u0026#34; at /var/runtime/node_modules/aws-sdk/lib/state_machine.js:26:10\u0026#34;, \u0026#34; at Request.\u0026lt;anonymous\u0026gt; (/var/runtime/node_modules/aws-sdk/lib/request.js:38:9)\u0026#34;, \u0026#34; at Request.\u0026lt;anonymous\u0026gt; (/var/runtime/node_modules/aws-sdk/lib/request.js:688:12)\u0026#34; ] } Lambda関数の呼び出しエラーが発生していますが、今回は先ほどのDynamoDBへの書き込みエラーは出力されていません。\nUser: \u0026lt;VERY-LONG-STRING\u0026gt; is not authorized to perform: lambda:InvokeFunction on resource: \u0026lt;VERY-LONG-STRING\u0026gt;\u0026#34; HitCounterはどうにかデータベースへの書き込みは行えたようです。 DynamoDBコンソールに移動して確認できます。\nLambda関数にDynamoDBのアクセス許可を与えたように、HitCounterにダウンストリームのLambda関数を呼び出すための権限を与える必要があります。\n呼び出し許可権限を付与する 次のとおり、lib/hitcounter.tsに強調表示された行を追加します。\nimport * as cdk from \u0026#39;aws-cdk-lib\u0026#39;; import * as lambda from \u0026#39;aws-cdk-lib/aws-lambda\u0026#39;; import * as dynamodb from \u0026#39;aws-cdk-lib/aws-dynamodb\u0026#39;; import { Construct } from \u0026#39;constructs\u0026#39;; export interface HitCounterProps { /** the function for which we want to count url hits **/ downstream: lambda.IFunction; } export class HitCounter extends Construct { /** allows accessing the counter function */ public readonly handler: lambda.Function; constructor(scope: Construct, id: string, props: HitCounterProps) { super(scope, id); const table = new dynamodb.Table(this, \u0026#39;Hits\u0026#39;, { partitionKey: { name: \u0026#39;path\u0026#39;, type: dynamodb.AttributeType.STRING } }); this.handler = new lambda.Function(this, \u0026#39;HitCounterHandler\u0026#39;, { runtime: lambda.Runtime.NODEJS_14_X, handler: \u0026#39;hitcounter.handler\u0026#39;, code: lambda.Code.fromAsset(\u0026#39;lambda\u0026#39;), environment: { DOWNSTREAM_FUNCTION_NAME: props.downstream.functionName, HITS_TABLE_NAME: table.tableName } }); // grant the lambda role read/write permissions to our table table.grantReadWriteData(this.handler); // grant the lambda role invoke permissions to the downstream function props.downstream.grantInvoke(this.handler); } } 差分確認 cdk diffを使用して、何が変更されたかをチェックします。\ncdk diff Resource セクションにHitCounterのロールに追加されたIAMポリシーが表示されます。\nResources [~] AWS::IAM::Policy HelloHitCounter/HitCounterHandler/ServiceRole/DefaultPolicy HelloHitCounterHitCounterHandlerServiceRoleDefaultPolicy1487A60A └─ [~] PolicyDocument └─ [~] .Statement: └─ @@ -19,5 +19,15 @@ [ ] \u0026#34;Arn\u0026#34; [ ] ] [ ] } [+] }, [+] { [+] \u0026#34;Action\u0026#34;: \u0026#34;lambda:InvokeFunction\u0026#34;, [+] \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, [+] \u0026#34;Resource\u0026#34;: { [+] \u0026#34;Fn::GetAtt\u0026#34;: [ [+] \u0026#34;HelloHandler2E4FBA4D\u0026#34;, [+] \u0026#34;Arn\u0026#34; [+] ] [+] } [ ] } [ ] ] 意図した通りの変更となっています。\nデプロイ 再度デプロイしてみましょう。\ncdk deploy デプロイが完了したらcurlコマンド、またはWebブラウザでエンドポイントを呼び出してみましょう。\ncurl -i https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ 出力は次のようになります。\nHTTP/2 200 OK ... Hello, CDK! You\u0026#39;ve hit / ようやくエラーが解消されました！次に進みましょう。\nもし、5XXエラーとなる場合は、数秒待ってからもう一度試してください。 API Gatewayのエンドポイントに新しいデプロイを適用するのに少し時間がかかることがあります。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/15-prerequisites/700-dotnet.html","title":".NET","tags":[],"description":"","content":"If you are planning on using the .NET Workshop, you obviously will need to have the .NET Core SDK installed. Specifically, you will need version 3.1 or later. You can find information about downloading and installing .NET Core SDK here.\nWe will be using the .NET Core CLI for this project, so if you are not familiar, please take a look at their documentation.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/20-typescript/40-hit-counter/700-test.html","title":"HitCounterのテスト","tags":[],"description":"","content":"テスト呼び出し いくつかのリクエストを実行して、HitCounterが機能するかどうかを確認しましょう。curlコマンド、またはWebブラウザから確認ができます。\ncurl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hello curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hello/world curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hello/world DynamoDBコンソールを開く DynamoDBコンソールに移動します。\nテーブルを作成したリージョンにいることを確認してください。手順どおりであれば東京リージョンにいることを確認しましょう。\nナビゲーションペインから「テーブル」を選択し、CdkWorkShopStack-HelloHitCounterHitsで始まるテーブルを選択してください。\nテーブルを開き、「テーブルアイテムの探索」を選択します。\n各パスで取得したヒット数を確認します。\n新しいパスでAPIを叩き、アイテムビューを更新してください。 hitsカウントが1の新しいアイテムが表示されます。\nGood job! HitCounterは大変便利だということがご理解いただけたと思います。 基本的に、誰でもAPI Gatewayのプロキシバックエンドとして機能するLambda関数にアタッチでき、このAPIのカウントを記録できます。\nHitCounterはシンプルなJavaScriptクラスであるため、npmモジュールをパッケージ化して、 JavaScriptパッケージマネージャーであるnpmjs.orgに公開できます。 公開後は誰でもnpm install でインストールでき、CDKアプリに追加できます。\n現時点で用意しているハンズオンはコンテンツは以上です。おつかれさまでした。\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/30-python/40-hit-counter/700-test.html","title":"Test the hit counter","tags":[],"description":"","content":"Issue a few test requests Let\u0026rsquo;s issue a few requests and see if our hit counter works. You can also use your web browser to do that:\ncurl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hello curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hello/world curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hello/world Open DynamoDB console Go to the DynamoDB console.\nMake sure you are in the region where you created the table.\nSelect Tables in the navigation pane and select the table that starts with cdkworkshop-HelloHitCounterHits.\nOpen the table and select \u0026ldquo;Items\u0026rdquo;.\nYou should see how many hits you got for each path.\nTry hitting a new path and refresh the Items view. You should see a new item with a hits count of one.\nGood job! The cool thing about our HitCounter is that it\u0026rsquo;s quite useful. It basically allows anyone to \u0026ldquo;attach\u0026rdquo; it to any Lambda function that serves as an API Gateway proxy backend and it will log hits to this API.\nSince our hit counter is a simple Python class, you could package it into a pip module and publish it to PyPi, which is the Python package manager. Then, anyone could pip install it and add it to their CDK apps.\nIn the next chapter we consume a construct library published to pip, which enables us to view the contents of our hit counter table from any browser.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/40-dotnet/40-hit-counter/700-test.html","title":"Test the hit counter","tags":[],"description":"","content":"Issue a few test requests Let\u0026rsquo;s issue a few requests and see if our hit counter works. You can also use your web browser to do that:\ncurl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hello curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hello/world curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hello/world Open DynamoDB console Go to the DynamoDB console.\nMake sure you are in the region where you created the table.\nSelect Tables in the navigation pane and select the table that starts with CdkWorkShopStack-HelloHitCounterHits.\nOpen the table and select \u0026ldquo;Items\u0026rdquo;.\nYou should see how many hits you got for each path.\nTry hitting a new path and refresh the Items view. You should see a new item with a hits count of one.\nGood job! The cool thing about our HitCounter is that it\u0026rsquo;s quite useful. It basically allows anyone to \u0026ldquo;attach\u0026rdquo; it to any Lambda function that serves as an API Gateway proxy backend and it will log hits to this API.\nSince our hit counter is a simple C# class, you could package it into an Nuget package and publish it to nuget.org, which is the C# package manager. Then, anyone could dotnet add package __ it and add it to their CDK apps.\nIn the next chapter we consume a construct library published to Nuget, which enables us to view the contents of our hit counter table from any browser.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/50-java/40-hit-counter/700-test.html","title":"Test the hit counter","tags":[],"description":"","content":"Issue a few test requests Let\u0026rsquo;s issue a few requests and see if our hit counter works. You can also use your web browser to do that:\ncurl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/ curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hello curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hello/world curl https://xxxxxxxxxx.execute-api.us-east-1.amazonaws.com/prod/hello/world Open DynamoDB console Go to the DynamoDB console.\nMake sure you are in the region where you created the table.\nSelect Tables in the navigation pane and select the table that starts with CdkWorkdShopStack-HelloHitCounterHits.\nOpen the table and select \u0026ldquo;Items\u0026rdquo;.\nYou should see how many hits you got for each path.\nTry hitting a new path and refresh the Items view. You should see a new item with a hits count of one.\nGood job! The cool thing about our HitCounter is that it\u0026rsquo;s quite useful. It basically allows anyone to \u0026ldquo;attach\u0026rdquo; it to any Lambda function that serves as an API Gateway proxy backend and it will log hits to this API.\nSince our hit counter is a simple Java class, you could package it into a Maven artifact and publish it to Central Repository, which is the standard Maven package repo. Then, anyone could add it to their pom.xml file to add it to their CDK apps.\nIn the next chapter we consume a construct library published to the Central Repository, which enables us to view the contents of our hit counter table from any browser.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/15-prerequisites/800-java.html","title":"Java","tags":[],"description":"","content":"If you are planning on using the Java Workshop, you obviously will need to have a JDK installed. Specifically, you will need JDK 11 or later. You can find information about downloading and installing the Amazon Corretto 11 distribution here. Other JDK 11 distributions are available if you do not wish to use Amazon Corretto.\n"},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/categories.html","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://jaws-ug-cdk.github.io/aws-cdk-intro-workshop/tags.html","title":"Tags","tags":[],"description":"","content":""}]